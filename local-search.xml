<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>《深入理解Java虚拟机：JVM高级特性与最佳实践》笔记(八)</title>
    <link href="/2019/05/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E3%80%8B%E7%AC%94%E8%AE%B0-%E5%85%AB/"/>
    <url>/2019/05/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E3%80%8B%E7%AC%94%E8%AE%B0-%E5%85%AB/</url>
    
    <content type="html"><![CDATA[<h3 id="Java内存模型与线程"><a href="#Java内存模型与线程" class="headerlink" title="Java内存模型与线程"></a>Java内存模型与线程</h3><h4 id="硬件的效率与一致性"><a href="#硬件的效率与一致性" class="headerlink" title="硬件的效率与一致性"></a>硬件的效率与一致性</h4><p>由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的告诉缓存（Cache）来作为内存与处理器之间的缓冲。虽然高速缓存解决了处理器与内存的速度矛盾，但也引入了新的问题：缓存一致性（Cache Coherence）。</p><p>为了解决一致性问题，需要各个处理器访问缓存时都遵守一些协议，在读写时要根据协议来进行操作，后面提到的”内存模型“一词，可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象，不同架构的物理机可以拥有不一样的内存模型。</p><p>除了增加高速缓存之外，为了使得处理器内部的运算单元尽可能被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。</p><span id="more"></span><h4 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h4><p>Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。</p><p><strong>主内存与工作内存</strong></p><p>Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存取出这样的底层细节。为了获得较好的执行效能，Java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施。</p><p>Java内存模型规定了所有的变量都存储在主内存（Main Memory）中。每条线程还有自己的工作内存（Working Memory），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量，volatile变量也不例外。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。</p><p><strong>内存间交互操作</strong></p><p>一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的细节实现，Java内存模型中定义了以下8种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的。</p><ul><li>lock</li><li>unlock</li><li>read</li><li>load</li><li>use</li><li>assign</li><li>store</li><li>write</li></ul><p><strong>对于volatile型变量的特殊规则</strong></p><p>volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁（使用<code>synchronize</code>或<code>java.util.concurrent</code>中的原子类）来保证原子性。</p><ul><li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li><li>变量不需要与其他的状态变量共同参与不变的约束</li></ul><p>使用volatile变量的第二个语义是禁止指令重排序优化，也就是Java内存模型中描述的所谓的”线程内表现为串行的语义“（Within-Thread As-If-Serial Semantics）。</p><p>在某些情况下，volatile的同步机制的性能确实要优于锁（使用<code>synchronize</code>或<code>java.util.concurrent</code>包里面的锁），但是由于虚拟机对锁实行的许多消除和优化，使得我们很难量化地认为volatile就会比synchronize快多少。如果让volatile自己与自己比较，那可以确定一个原则：volatile变量读操作的性能消耗与普通变量几乎没有什么差别，但写操作则可能会慢一些，因为它需要在本地代码插入许多内存屏障指令来保证处理器不发生乱序执行。不过即便如此，大多数场景下volatile的总开销仍然比锁低，我们在volatile与锁之中选择的唯一依据仅仅是volatile的语义是否能满足使用场景的需求。</p><p><strong>对于long和double型变量的特殊规则</strong></p><p>允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，这点就是所谓的long和double的非原子性协定（Nonatomic Treatment of double and long Variables）。</p><p>不过也允许虚拟机选择把这些操作实现为具有原子性的操作，而且还”强烈建议“虚拟机这样实现。实际开发中，目前各种平台下的商用虚拟机几乎都选择把64位数据的读写操作作为原子操作来对待，因此一般不需要吧用到的long和double型变量专门声明为volatile。</p><p><strong>先行发生原则</strong></p><p>先行发生是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生与操作B，操作A产生的影响能被操作B观察到，”影响“包括修改了内存中共享变量的值、发送了消息、调用了方法等。</p><p>时间先后顺序与先行发生原则之间基本没有太大的关系，所以衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准。</p><h4 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h4><p>Thread类与大部分的Java API有显著的差别，它的所有关键方法都是声明Native的。在Java API中，一个Native方法往往意味着这个方法没有使用或无法使用平台无关的手段来实现。实现线程主要有三种方式：使用内核线程实现、使用用户线程实现和使用用户线程加轻量级进程混合实现。</p><p><strong>使用内核线程实现</strong></p><p>内核线程（Kernel-Level Thread，KLT）就是直接由操作系统内核（Kernel）支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就叫做多线程内核（Multi-Threads Kernel）。</p><p>程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口————轻量级进程（Light Weight Process，LWP），轻量级进程就是我们通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才有轻量级进程。</p><p>由于内核线程的支持，每个轻量级进程都成为一个独立的调度单元，即使有一个轻量级进程在系统调用中阻塞了，也不会影响整个进程继续工作，但是轻量级进程具有它的局限性：首先，由于是基于内核线程实现的，所以各种线程操作，如创建、析构与同步，都需要进行系统调用。而系统调用的代价相对较高，需要在用户态（User Mode）和内核态（Kernel Mode）中来回切换。其次，每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持轻量级进程的数量是有限的。</p><p><strong>使用用户线程实现</strong></p><p>从广义上来讲，一个线程只要不是内核线程，就可以认为是用户线程（User Thread，UT）；而狭义上的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。</p><p>使用用户线程的优势在于不需要系统内核支援，劣势也在于没有系统内核的支援，所有的线程操作都需要用户程序自己处理。而且由于操作系统只把处理器的资源分配到进程，那诸如”阻塞如何处理“、”多处理器系统中如何将线程映射到其他处理器上“这类问题解决起来将会异常困难，甚至不可能完成。Java、Ruby等语言都曾使用过用户线程，最终又都放弃使用它。</p><p><strong>使用用户线程加轻量级进程混合实现</strong></p><p>用户线程还是完全建立在用户空间中，因此用户线程的操作依然廉价，并且可以支持大规模的用户线程并发。而操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级进程来完成，大大降低了整个进程被完全阻塞的风险。</p><h4 id="Java-线程调度"><a href="#Java-线程调度" class="headerlink" title="Java 线程调度"></a>Java 线程调度</h4><p>虽然Java线程调度是系统自动完成的，但是我们还是可以”建议“系统给某些线程多分配一点执行时间，另外的线程少分配一点————设置线程优先级。</p><p>但线程优先级并不太靠谱，原因是Java的线程是通过映射到系统的原生线程上来实现的，所以线程调度最终还是取决于操作系统，虽然现在很多操作系统都提供线程优先级的概念，但是并不见得能与Java线程的优先级一一对应。而且操作系统的线程优先级可能会被系统自行改变。因此不能在程序中通过优先级来完全准确地判断一组状态都为Ready的线程将会先执行哪一个。</p><h4 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h4><p>Java语言定义了5种线程状态，在任意一个时间点，一个线程只能有且只有其中一种状态，分别如下：</p><ul><li>新建（New）</li><li>运行（Runable）</li><li>无限期等待（Waiting）</li><li>限期等待（Timed Waiting）</li><li>阻塞（Blocked）</li><li>结束（Terminated）</li></ul><h3 id="线程安全与锁优化"><a href="#线程安全与锁优化" class="headerlink" title="线程安全与锁优化"></a>线程安全与锁优化</h3><h4 id="Java语言中的线程安全"><a href="#Java语言中的线程安全" class="headerlink" title="Java语言中的线程安全"></a>Java语言中的线程安全</h4><p>线程安全不是一个非此即彼的二元排他项，按照线程安全的”安全程度“由强至弱来排序，我们可以将Java语言中各种操作共享的数据分为五类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p><p><strong>不可变</strong></p><p>在Java语言中，不可变（Immutable）的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障措施。”不可变“带来的安全性是最简单和最纯粹的。</p><p><strong>绝对线程安全</strong></p><p>在Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全。“一个类不管运行时环境如何，调用者不需要额外的同步措施”。</p><p><strong>相对线程安全</strong></p><p>通常意义上所讲的线程安全，保证这个对象单独的操作是线程安全的，但对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。</p><p>在Java语言中，大部分的线程安全类都属于这种类型，例如Vector、HashTable、Collections的synchronizedCollection（）方法包装的集合等。</p><p><strong>线程兼容</strong></p><p>线程兼容指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中安全地使用，Java API中大部分的类都是属于线程兼容的，如前面的Vector和HashTable相对应的集合类ArrayList和HashMap等。</p><p><strong>线程对立</strong></p><p>线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于Java语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。</p><h4 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h4><p><strong>互斥同步</strong></p><p>同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是主要的互斥实现方式。</p><p>在Java中，最基本的互斥同步就是synchronized关键字，synchronized关键字经过编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来知名要锁定和解锁的对象。如果Java程序中的synchronized明确制定了对象参数，那就是这个对象的reference；如果没有明确指定，那就根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象。</p><p>根据虚拟机规范的要求，在执行monitorenter指令时，首先要尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行monitorexit指令时会将锁的计数器减1，当计数器为0时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另一个线程释放为止。</p><p>在虚拟机规范对monitorenter和monitorexit的行为描述中，有两点需要特别注意。首先，synchronized同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题。其次，同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。</p><p>除了synchronized之外，还可以使用<code>java.util.concurrent</code>包中的重入锁（ReentrantLock）来实现同步，在基本用法上，ReentrantLock与synchronized很相似，他们都具备一样的线程重入特性，只是代码写法上有点区别，一个表现为API层面的互斥锁（lock()和unlock()方法配合try/finally语句块来完成），另一个表现为原生语法层面的互斥锁。不过，相比synchronized，ReentrantLock增加了一些高级功能，主要有以下3项：等待可中断、可实现公平锁，以及锁可以绑定多个条件。</p><ul><li>等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。</li><li>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁是非公平的，ReentrantLock默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。</li><li>锁绑定多个条件是指一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait()和notify()或notifyAll()方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而ReentrantLock则无须这样做，只需要多次调用newCondition()方法即可。</li></ul><p><strong>非阻塞同步</strong></p><p>互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也成为阻塞同步（Blocking Synchronization）。从处理问题的方式上说，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施（例如加锁），那就肯定会出现问题，无论共享数据是否真的会出现竞争，它都要进行加锁（这里只讨论概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。随着硬件指令集的发展，我们有了另外一个选择：基于冲突检测的乐观并发策略，通俗地说，就是先进行操作，如果没有其他线程争用共享数据，那就操作成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步（Non-Blocking Synchronization）。</p><p>为什么说使用乐观并发策略需要“硬件指令集的发展”才能进行呢？因为我们需要操作和冲突检测这两个步骤具备原子性，靠什么来保证呢？如果这里再使用互斥同步来保证就失去意义了，所以我们只能靠硬件来完成这件事情，硬件保证一个从语义上看起来需要多次操作的行为只通过一条处理器指令就能完成，这类指令常用的有：</p><ul><li>测试并设置（Test-and-Set）</li><li>获取并增加（Fetch-and-Increment）</li><li>交换（Swap）</li><li>比较并交换（Compare-and-Swap，CAS）</li><li>加载链接/条件存储（Load-Linked/Store-Conditional，LL/SC）</li></ul><p>其中，前面的3条是20世纪就已经存在于大多数指令集之中的处理器指令，后面的两条是现代处理器新增的，而且这两条指令的目的和功能是类似的。</p><p><strong>无同步方案</strong></p><p>同步只是保证共享数据争用时的正确的手段，如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性，因此会有一些代码天生就是线程安全的。</p><ul><li>可重入代码（Reentrant Code）：这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。</li><li>线程本地存储（Thread Local Storage）：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行，如果能保证，就可以把共享数据的可见范围限制在同一个线程内，这样无须同步也能保证线程之间不出现数据争用的问题。</li></ul><h4 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h4><p>互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给操作系统的并发性能带来了很大的压力。同时，虚拟机的开发团队也注意到许多应用上，共享数据的锁定只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。如果物理机器有一个以上的处理器，能让两个或者以上的线程同时并行执行，我们就可以让后面请求锁的线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。</p><p>JDK1.6中引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。</p><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断在一段代码中，对上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。</p><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小————只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。</p><p>大部分情况下上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。</p><p>如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>JDK1.6中加入的新型锁机制，它名字中的“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的，因此传统的锁机制就称为“重量级”锁。轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p><p>如果有两条以上的线程争用同一个轻量级锁，则轻量级锁就不再有效，要膨胀为重量级锁，后面等待锁的线程也要进入阻塞状态。解锁时如果发现有其他线程尝试过获取该锁，那就要在释放锁的同时，唤醒被挂起的线程。</p><p>轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销，但如果存在锁竞争，除了互斥量的开销外，还额外发生了CAS操作，因此在有竞争的情况下，轻量级锁会比传统的重量级锁更慢。</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>也是JDK1.6中引入的一项锁优化，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了。</p><p>当锁对象第一次被线程获取的时候，虚拟机会把对象头中的标识为设为偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象头中，如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块，虚拟机都可以不再进行任何同步操作。</p><p>当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束。根据锁对象目前是否处于被锁的状态，撤销偏向（Revoke Bias）后恢复到未锁定或轻量级锁定的状态，后续的同步操作就如上面介绍的轻量级锁那样执行。</p><p>偏向锁可以提高带有同步但无竞争的程序性能。它同样是一个带有效益权衡（Trade Off）性质的优化，如果程序中大多数的锁总是被多个不同的线程访问，那偏向模式就是多余的。在具体问题具体分析的前提下，有时候禁止偏向锁优化反而可以提升性能。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>Java</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《深入理解Java虚拟机：JVM高级特性与最佳实践》笔记(七)</title>
    <link href="/2019/05/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E3%80%8B%E7%AC%94%E8%AE%B0-%E4%B8%83/"/>
    <url>/2019/05/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E3%80%8B%E7%AC%94%E8%AE%B0-%E4%B8%83/</url>
    
    <content type="html"><![CDATA[<h3 id="早期（编译期）优化"><a href="#早期（编译期）优化" class="headerlink" title="早期（编译期）优化"></a>早期（编译期）优化</h3><p>从Sun Javac的代码来看，编译过程大致分为3个过程，分别是：</p><ul><li>解析与填充符号表过程。</li><li>插入式注解处理器的注解处理过程。</li><li>分析与字节码生成过程。</li></ul><h4 id="解析与填充符号表"><a href="#解析与填充符号表" class="headerlink" title="解析与填充符号表"></a>解析与填充符号表</h4><p>词法分析是将源代码的字符流转变为标记（Token）集合，单个字符是程序编写过程的最小元素，而标记则是编译过程的最小元素，关键字、变量名、字面量、运算符都可以成为标记。在Javac的源码中，词法分析过程由<code>com.sun.tools.javac.parser.Scanner</code>类来实现。</p><p>语法分析是根据token序列构造抽象语法树的过程，抽象语法树（Abstract Syntax Tree，AST）是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程序代码中的一个语法结构（Construct），例如包、类型、修饰符、运算符、接口、返回值甚至代码注释等都可以是一个语法结构。在Javac的源码中，语法分析过程由<code>com.sun.tools.javac.tree.JCTree</code>类表示，经过这个步骤之后，编译器就基本不会再对源码文件进行操作了，后续的操作都建立在抽象语法树之上。</p><p>完成了语法分析和词法分析之后，下一步就是填充符号表的过程。</p><span id="more"></span><p>符号表（Symbol Table）是由一组符号地址和符号信息构成的表格，表中所登记的信息在编译的不同阶段都要用到。在语义分析中，符号表所登记的内容将用于语义检查和产生中间代码。在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的依据。</p><p>在Javac源码中，填充符号表的过程由<code>com.sun.tools.javac.comp.Enter</code>类实现，此过程的出口是一个待处理列表（To Do List），包含了每一个编译单元的抽象语法树的顶级节点，以及package-info.java的顶级节点。</p><h4 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h4><p>在JDK1.6中提供了一组插入式注解处理器的标准API在编译期对注解进行处理，可以看作是一组编译器的插件，在这些插件里面可以读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行了修改，编译器回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环称为一个Round。</p><h4 id="语义分析与字节码生成"><a href="#语义分析与字节码生成" class="headerlink" title="语义分析与字节码生成"></a>语义分析与字节码生成</h4><p>语法分析后，编译器获得了程序代码的抽象语法树表示，语法树能表示一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的。而语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的审查。</p><p>Javac的编译过程中，语义分析过程分为标注检查以及数据及控制流分析两个部分。</p><p>标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配等。</p><p>数据及控制流分析师对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。编译时期的数据及控制流分析与类加载时的数据及控制流分析发目的基本上都是一致的，但校验范围有所区别，有一些校验项只有在编译期或运行期才能进行。</p><h4 id="解语法糖"><a href="#解语法糖" class="headerlink" title="解语法糖"></a>解语法糖</h4><p>Java中最常用的语法糖主要是前面提到过的泛型、变长参数、自动装箱/拆箱等，虚拟机运行时不支持这些语法，它们在编译阶段还愿回简单的基础语法结构，这个过程为解语法糖。</p><p><strong>泛型与类型擦除</strong><br>泛型是JDK1.5中的一项新增特性，它的本质是参数化类型（Parametersized Type）的应用，也就是说所操作的数据类型被指定为一个参数。</p><p>泛型技术在C#和Java之中的使用方式看似相同，但实现上却有着根本性的分歧，C#里面泛型无论在程序源码中、编译后的IL中（Intermediate Language，中间语言，这时候泛型是一个占位符），或是运行期的CLR中，都是切实存在的，List<int>与List<String>就是两个不同的类型，他们在系统运行期生成，有自己的虚方法表和类型数据，这种实现称为类型膨胀，基于这种方法实现的泛型称为真实泛型。</p><p>Java语言中的泛型则不一样，它只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型（Raw Type，也成为裸类型）了，并且在相应的地方插入了强制转型代码，因此对于运行期的Java语言来说，List<int>与List<String>就是同一个类，所以泛型技术实际上是Java语言的一颗语法糖，Java语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型称为伪泛型。</p><p><strong>条件编译</strong></p><p>使用条件为常量的if语句，在编译阶段就会被”运行“，生成的字节码就只包含一条分支的语句，不包含if语句及另一个分支中的语句。</p><p>Java语言中条件编译的实现，也是Java语言的一颗语法糖，根据布尔常量值的真假，编译器将会把分支中不成立的代码块消除掉，这一工作将在编译器解除语法糖阶段完成。</p><h4 id="字节码生成"><a href="#字节码生成" class="headerlink" title="字节码生成"></a>字节码生成</h4><p>字节码生成阶段不仅仅是吧前面各个步骤所生成的信息（语法树、符号表）转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作，比如生成构造器、把字符串的加操作替换为StringBuffer或StringBuilder的append()的操作等。</p><h3 id="晚期（运行期）优化"><a href="#晚期（运行期）优化" class="headerlink" title="晚期（运行期）优化"></a>晚期（运行期）优化</h3><h4 id="解释器与编译器"><a href="#解释器与编译器" class="headerlink" title="解释器与编译器"></a>解释器与编译器</h4><p>当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译时间，立即执行。在程序运行之后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率。当程序运行环境中内存资源限制较大，可以使用解释执行节约内存，反之可以使用编译执行来提升效率。</p><p>Hotspot虚拟机中内置了两个即时编译器，分别称为Client Compiler和Server Compiler，或者简称为C1编译器和C2编译器（也叫Opto编译器）。</p><p>由于即时编译器编译本地代码需要占用程序运行时间，要编译出优化程度更高的代码，所花费的时间可能更长；而且想要编译出一花程度更高的代码，解释器可能还要替编译器收集性能监控信息，这对解释执行的速度也有影响。为了在程序启动响应速度与运行效率之间达到最佳平衡，HotSpot虚拟机还会逐渐启用分层编译（Tiered Compilation）的策略，分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次，其中包括：</p><ul><li>第0层，程序解释执行，解释器不开启性能监控功能（Profiling），可触发第1层编译。</li><li>第1层，也成为C1编译，将字节码编译为本地代码，进行简单、可靠的优化，如有必要将加入性能监控的逻辑</li><li>第2层（或2层以上），也称为C2编译，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。</li></ul><p>实施分层编译后，Client Compiler和Server Compiler将会同时工作，许多代码都可能会被多次编译，用Client Compiler获取更高的编译速度，用Server Compiler来获取更好的编译质量，在解释执行的时候也无须再承担收集性能监控信息的任务。</p><h4 id="编译对象与触发条件"><a href="#编译对象与触发条件" class="headerlink" title="编译对象与触发条件"></a>编译对象与触发条件</h4><p>一个方法被调用的多了，方法体内代码执行的次数自然多，编译器理所当然地会以整个方法作为编译对象，这种编译也是虚拟机中标准的JIT编译方式。循环次数较多的循环体触发编译，编译器依然会以整个方法作为编译对象。这种编译方式因为编译发生在方法执行过程中，因此形象地称之为栈上替换（On Stack Replacement，简称为OSR编译，即方法栈帧还在栈上，方法就被替换了）。</p><p>判断一段代码是不是热点代码，是不是需要触发即时编译，这样的行为称为热点探测（Hot Spot Detection），其实进行热点探测并不一定要知道方法具体被调用多少次，目前主要的热点探测判定方式有两种，分别如下：</p><ul><li>基于采样的热点探测（Sample Based Hot Spot Detection）：采用这种方法的虚拟机会周期性地检查各个线程的栈顶，如果发现某个（或某些）方法经常出现在栈顶，那这个方法就是”热点方法“。基于采样的热点探测的好处是实现简单、高效，还可以很容易地获取方法调用关系（将调用堆栈展开即可），缺点是很难精确地确认一个方法的热度，容易因为收到线程阻塞或别的外界因素的影响而扰乱热点探测。</li><li>基于计数器的热点探测（Counter Based Hot Spot Detection）：采用这种方法的虚拟机会为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定阈值就认为它是”热点方法“。这种统计方法实现起来麻烦一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系，但是它的统计结果相对来说更加精确和严谨。</li></ul><h4 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h4><p>对于Client Compiler来说，它是一个简单快速的三段式编译器，主要的关注点在于局部性的优化，而放弃了许多耗时较长的全局优化手段。而Server Compiler则是专门面向服务端的典型应用并为服务端的性能配置特别调整过的编译器，也是一个充分优化过的高级编译器，几乎能达到GNU C++编译器使用-O2参数时的优化强度，它会执行所有经典的优化动作，还会实施一些与Java语言特性密切相关的优化技术。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>Java</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《深入理解Java虚拟机：JVM高级特性与最佳实践》笔记(六)</title>
    <link href="/2019/04/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E3%80%8B%E7%AC%94%E8%AE%B0-%E5%85%AD/"/>
    <url>/2019/04/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E3%80%8B%E7%AC%94%E8%AE%B0-%E5%85%AD/</url>
    
    <content type="html"><![CDATA[<h3 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h3><p>从外观（Facade）上看，所有的Java虚拟机的执行引擎都是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。</p><h4 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h4><p>栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接接方法返回地址等信息。每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。</p><p>一个线程中的方法调用链可能会很长，很多方法都同时处于执行状态。对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，称当前栈帧（Current Stack Frame），与这个栈帧相关联的方法称为当前方法（Current Method）。执行引擎运行的所有字节码都只针对当前栈帧进行操作。</p><span id="more"></span><p><strong>局部变量表</strong></p><p>局部变量表（Local Variable table）是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。</p><p>局部变量表的容量以变量槽（Variable Slot）为最小单位，虚拟机规范中并没有明确指明一个Slot应占用的内存空间大小，只是很有导向性地说到每个Slot都应该能存放一个boolean、byte、short、float、reference或returnAddress类型的数据。</p><p>为了节省栈帧空间，局部变量表中的Slot是可以重用的，方法体中定义的变量，其作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超出了某个变量的作用域，那这个变量对应的Slot就可以交给其他变量使用。</p><p>局部变量不像类变量那样存在“准备阶段”，如果一个局部变量定义了但没有赋初始值是不能使用的。</p><p><strong>操作数栈</strong></p><p>操作数栈的每一个元素可以是任意的Java数据类型，包括long和double。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2.在方法执行的任何时候，操作数栈的深度都不会超过在max_stacks数据项中设定的最大值。</p><p><strong>动态连接</strong></p><p>每个栈帧都包含一个指向运行时常量池中该栈帧所述方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。Class文件的常量池中存有大量符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析。另一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。</p><p><strong>方法返回地址</strong></p><p>当一个方法开始执行后，只有两种方式可以退出这个方法。第一种是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口（Normal Method Invocation Completetion）。</p><p>另一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，就会导致方法退出，这种退出方法的方式称为异常完成出口（Abrupt Method Invocation Completion）。一个方法使用异常完成出口的方式退出，是不会给它的上层调用者产生任何返回值的。</p><p><strong>附加信息</strong></p><p>虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧之中，在实际开发中，一般都会把动态连接、方法返回地址与其他附加信息全部归为一类，称为栈帧信息。</p><h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><p>方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本，暂时还不涉及方法内部的具体运行过程。一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（相当于之前说的直接引用），需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。</p><p><strong>解析</strong></p><p>所有调用方法中调用的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可变的。换句话说，调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析（Resolution）。</p><p>在Java语言中符合“编译期可知，运行期不可变”这个要求的方法，主要包括静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问。</p><p><strong>分派</strong></p><ul><li>静态分派：重载</li><li>动态分派：重写</li></ul><p>方法的接收者与方法的参数统称为方法的宗量，根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种。单分派是根据一个宗量对目标方法进行选择，多分派则是根据一个宗量对目标方法进行选择。</p><p><strong>动态类型语言支持</strong></p><p>静态类型语言在编译期确定类型，可以提供严谨的类型检查，利于稳定性及代码达到更大规模。而动态类型语言在运行期确定类型，可以为开发人员提供更大的灵活性，实现功能更加清晰简洁，也就意味着开发效率的提升。</p><p><code>java.lang.invoke</code>包主要目的是在之前单纯依靠符号引用来确定调用的目标方法这种方式外，提供一种新的动态确定目标方法的机制，称为MethodHandle。下面的代码演示了MethodHandle的基本用途，无论obj是何种类型，都可以正确地调用到<code>println()</code>方法。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><pre><code class="hljs reasonml">package demo;<br><br>import java.lang.invoke.MethodHandle;<br>import java.lang.invoke.MethodType;<br><br>import static java.lang.invoke.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MethodHandles</span>.</span></span>lookup;<br><br>public <span class="hljs-keyword">class</span> Main &#123;<br>    static <span class="hljs-keyword">class</span> ClassA &#123;<br>        public void println(String s) &#123;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(s);<br>        &#125;<br>    &#125;<br><br>    public static void main(String<span class="hljs-literal">[]</span> args) throws Throwable &#123;<br>        Object obj = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>current<span class="hljs-constructor">TimeMillis()</span> % <span class="hljs-number">2</span><span class="hljs-operator"> == </span><span class="hljs-number">0</span> ? <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out : <span class="hljs-keyword">new</span> <span class="hljs-constructor">ClassA()</span>;<br><br>        get<span class="hljs-constructor">PrintLnHM(<span class="hljs-params">obj</span>)</span>.invoke<span class="hljs-constructor">Exact(<span class="hljs-string">&quot;liubin92&quot;</span>)</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> static MethodHandle get<span class="hljs-constructor">PrintLnHM(Object <span class="hljs-params">reveiver</span>)</span> throws Throwable &#123;<br>        MethodType mt = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MethodType</span>.</span></span><span class="hljs-keyword">method</span><span class="hljs-constructor">Type(<span class="hljs-params">void</span>.<span class="hljs-params">class</span>, String.<span class="hljs-params">class</span>)</span>;<br><br>        return lookup<span class="hljs-literal">()</span>.find<span class="hljs-constructor">Virtual(<span class="hljs-params">reveiver</span>.<span class="hljs-params">getClass</span>()</span>, <span class="hljs-string">&quot;println&quot;</span>, mt).bind<span class="hljs-constructor">To(<span class="hljs-params">reveiver</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>与反射的区别：</p><ul><li>Reflection是在模拟Java代码层次的方法调用，MethodHandle是在模拟字节码层次的方法调用。</li><li>Reflection中的<code>java.lang.reflect.Method</code>对象远比MethodHandle机制中的<code>java.lang.invoke.MethodHandle</code>对象所包含的信息多，通俗地讲，Reflection是重量级，而MethodHandle是轻量级。</li><li>由于MethodHandle是对字节码的方法指令调用的模拟，所以理论上虚拟机在这方面做的各种优化（如方法内联），在MethodHandle上也应当可以采用类似的思路去支持。而通过反射区调用方法则不行。</li></ul><h4 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h4><p><strong>解释执行</strong></p><p>Java语言中，Javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。因为这一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机的内部，所以Java程序的编译就是半独立的实现。</p><p><strong>基于栈的指令集与基于寄存器的指令集</strong></p><p>基于栈的指令集主要的优点就是可移植，代码相对更加紧凑（字节码中每个字节就对应一条指令，而多地址指令集中还需要存放参数）、编译器实现更加简单（不需要考虑空间分配的问题，所需空间都在栈上操作）等。</p><p>栈架构指令集的主要缺点是执行速度相对来说会稍慢一些。所有主流物理机的指令集都是寄存器架构也从侧面印证了这一点。</p><p>虽然栈架构指令集的代码非常紧凑，但是完成相同功能所需的指令数量一般会比寄存器架构多，因为出栈、入栈操作本身就产生了相当多的指令数量。更重要的是，栈实现在内存之中，频繁的栈访问也就意味着频繁的内存访问，相对处理器来说，内存始终是执行速度的瓶颈，所以导致了栈架构指令集的执行速度会相对较慢。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>Java</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《深入理解Java虚拟机：JVM高级特性与最佳实践》笔记(五)</title>
    <link href="/2019/04/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E3%80%8B%E7%AC%94%E8%AE%B0-%E4%BA%94/"/>
    <url>/2019/04/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E3%80%8B%E7%AC%94%E8%AE%B0-%E4%BA%94/</url>
    
    <content type="html"><![CDATA[<h3 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h3><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。与那些在编译时需要进行连接工作的语言不同，在Java语言里，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略虽然会令加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性，Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。</p><span id="more"></span><h4 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h4><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证、准备、解析3个部门统称为连接（Linking）。</p><p>Java虚拟机规范中并没有进行强制约束，但是对于初始化阶段，虚拟机规范则是严格规定了有且只有5种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p><ol><li>遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行初始化，则需要先触发其初始化。</li><li>使用<code>java.lang.reflect</code>包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li><li>当初始化一个类的的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类。</li><li>当使用JDK1.7的动态语言支持时，如果一个<code>java.lang.invoke.MethodHandle</code>实例最后的解析结果REF_getStatic、REF_ putStatic、REF_ invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li></ol><h4 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h4><p><strong>加载</strong></p><p>“加载”是“类加载”（Class Loading）过程的一个阶段，在加载阶段，虚拟机需要完成以下三件事：</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口。</li></ol><p><strong>验证</strong></p><p>验证阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p>大致上会完成下面4个阶段的检验动作：</p><ol><li>文件格式验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，通过验证后进入内存的方法区进行存储。</li><li>元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。</li><li>字节码验证：主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型做完校验后这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。</li><li>符号引用验证：在虚拟机将符号引用转化为直接引用时发生，这个转化动作在解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。</li></ol><p><strong>准备</strong></p><p>准备阶段是正式为<strong>类变量</strong>分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。</p><p><strong>解析</strong></p><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p><ul><li>符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存分布无关，引用的目标并不一定已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。</li><li>直接引用（Direct References）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在内存中存在。</li></ul><p><strong>初始化</strong></p><p>类初始化是类加载过程发最后一步，前面的类加载过程中，除了在加载阶段用户应用可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码（或者说是字节码）。</p><ul><li>虚拟机会保证在子类的<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕。</li><li>父类中定义的静态语句块要优先于子类的变量赋值操作。</li><li><clinit>()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法。</li><li>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，但不需要先执行父接口的<clinit>()方法，只有父接口中定义的变量使用时，父接口才初始化，接口的实现类在初始化时一样不会执行接口的<clinit>()方法。</li><li>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程需要阻塞等待，直到活动线程执行完<clinit>()方法完毕。</li></ul><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p><p><strong>类与类加载器</strong></p><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。</p><p><strong>双亲委派模型</strong></p><ul><li>启动类加载器（Bootstrap ClassLoader）：这个加载器负责存放在<JAVA_HOME>\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别类库加载到虚拟机内存中。</li><li>扩展类加载器（Extension ClassLoader）：由<code>sun.misc.Launcher$ExtClassLoader</code>实现，负责加载<JAVA_HOME>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</li><li>应用程序加载器（Application ClassLoader）：由<code>sun.misc.Launcher$AppClassLoader</code>实现，一般称为系统类加载器，负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器。</li></ul><p>我们的应用程序都是由这3种类加载器互相配合进行加载的，如果有必要还可以加入自己定义的类加载器。</p><p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都是用组合（Composition）关系来复用父加载器的代码。它并不是一个强制性的约束模型，而是Java设计者推荐给开发者的一种类型加载器实现方式。</p><p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去 尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>Java</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《深入理解Java虚拟机：JVM高级特性与最佳实践》笔记(四)</title>
    <link href="/2019/04/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E3%80%8B%E7%AC%94%E8%AE%B0-%E5%9B%9B/"/>
    <url>/2019/04/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E3%80%8B%E7%AC%94%E8%AE%B0-%E5%9B%9B/</url>
    
    <content type="html"><![CDATA[<h3 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h3><p>Class文件是一组以8位字节为基础单位的二进制流。根据Java虚拟机规范的规定，Class文件采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表。</p><p>无符号数属于基本的数据类型，可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成的字符串值。</p><p>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有的表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。</p><p>无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时称这一系列连续的某一类型的数据为某一类型的集合。</p><span id="more"></span><h4 id="class类文件的结构"><a href="#class类文件的结构" class="headerlink" title="class类文件的结构"></a>class类文件的结构</h4><p><strong>魔数（Magic Number）与Class文件的版本</strong></p><p>每个Class文件的头4个字节称之为魔数，它的唯一作用就是确定这个文件是否为一个能被虚拟机接受的Class文件。Class文件的魔数值为：0xCAFEBABE。紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（Minor Version），第7和第8个字节是主版本号（Major Version）。</p><p><strong>常量池</strong></p><p>紧接着主次版本号之后的是常量池入口，常量池可以理解为Class文件之中的资源仓库，他是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一，同时它还是在Class文件中第一个出现的表类型数据项目。</p><p>常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。字面量比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p><ol><li>类和接口的全限定名（Fully Qualified Name）</li><li>字段的名称和描述符（Descriptor）</li><li>方法的名称和描述符</li></ol><p>使用<code>javap -verbose</code>命令输出class文件字节码内容。</p><p><strong>访问标志</strong></p><p>在常量池结束之后，紧接着的两个字节代表访问标志（access_flags），这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等。</p><p><strong>类索引、父类索引与接口索引集合</strong></p><p>访问标志之后是类索引（this class）和父类索引（super class）都是一个u2类型的数据，而接口索引集合（interfaces）是一组u2类型的数据的集合，Class文件中由这三项数据来确定这个类继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，接口索引集合用来描述这个类实现了哪些接口。</p><p><strong>字段表集合</strong></p><p>字段表（field_info）用于描述接口或者类中声明的变量。字段（field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。</p><p>描述一个字段可以包含的信息：</p><ul><li>字段的作用域（public、private、protected）</li><li>是实例变量还是类变量（static）</li><li>可变性（final）</li><li>并发可见性（volatile）</li><li>可否被序列化（transient）</li><li>字段数据类型（基本类型、对象、数组）</li><li>字段名称</li></ul><p>字节码中，如果两个字段的描述符不一致，那字段重名就是合法的。</p><p><strong>方法表集合</strong></p><p>方法表的结构如同字段表一样，依次包括了访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）几项.</p><p>方法里的Java代码，经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为“Code”的属性里面。</p><p>如果父类方法在子类中没有被重写（Override），方法表集合中就不会出现来自父类的方法信息。但同样的有可能会出现由编译器自动添加的方法。</p><p>字节码中，如果两个方法有相同的名称和特征签名，但返回值不同，那么也可以合法共存于同一个Class文件。</p><p><strong>属性表集合</strong></p><p>在Class文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。</p><p>对于每个属性，它的名称需要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示，而属性值的结构则是完全自定义的，只需要通过一个u4的长度属性去说明属性值所占用的位数即可。</p><p><em>1.Code属性</em></p><p>Java程序方法体中的代码经过javac编译器处理后，最终变为字节码指令存储在Code属性内。</p><p>Code属性是Class文件中最重要的一个属性，如果把一个Java程序中的信息分为代码（Code，方法体里的Java代码）和元数据（Metadata，包括类、字段、方法定义及其他信息）两部分，那么在整个Class文件中，Code属性用于描述代码，所有的其他数据项目都用于描述元数据。</p><p><em>2.Exception属性</em></p><p>这里的Exception属性是在方法表中与Code属性平级的一项属性，作用是列举出方法中可能抛出的受查异常（Checked Exceptions），也就是方法描述时在throws关键字后面列举的异常。</p><p><em>3.LineNumberTable属性</em></p><p>LineNumberTable属性用于描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系。它并不是运行时必需的属性，但默认会生成到Class文件之中，可以在编译时选择不生成这项信息，如果不生成，对程序运行产生的最主要的影响就是当抛出异常时，堆栈中将不会显示出错的行号，并且在调试程序时，也无法按照源码行来设置断点。</p><p><em>4.LocalVariableTable属性</em></p><p>LocalVariableTable属性用于描述栈帧中局部变量表中的变量与Java源码中定义的变量之间的关系。它也不是运行时必需的属性，但默认会生成到Class文件中，编译时选择不生成这项信息，最大的影响就是当其他人引用这个方法时，所有的参数名称都将会丢失，IDE将会使用诸如arg0、arg1之类的占位符代替原有的参数名，这对程序运行没有影响，但是会对代码编写带来较大不便，而且在调试期间无法根据参数名称从上下文中获得参数值。</p><p><em>5.SourceFile属性</em></p><p>SourceFile属性用于记录生成这个Class文件的源码文件名称。这个属性也是可选的，编译时如果不生成这项信息，当抛出异常时，堆栈中将不会显示出错代码所属的文件名。</p><p><em>6.ConstantValue属性</em></p><p>ConstantValue属性的作用是通知虚拟机自动为静态变量赋值。如果同时使用final和static来修饰一个变量，并且这个变量的数据类型是基本类型或者java.lang.String的话，就生成ConstantValue属性来进行初始化。</p><p>虚拟机规范要求有ConstantValue属性的字段必须设置ACC_STATIC标志，对final关键字的要求是javac编译器自己加入的限制。</p><p><em>7.InnerClasses属性</em></p><p>InnerClasses属性用于记录内部类与宿主类之间的关联。如果一个类中定义了内部类，那编译器将会为它以及它所包含的内部类生成InnerClasses属性。</p><p><em>8.Deprecated及Synthetic属性</em></p><p>Deprecated及Synthetic两个属性都属于标志类型的布尔属性，只存在有和没有的区别，没有属性值的概念。</p><p>Deprecated属性用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用，它可以通过在代码中使用@ deprecated注释进行设置。</p><p>Synthetic属性代表此字段或者方法并不是由Java源码直接产生，而是由编译器自行添加的。</p><p><em>9.StackMapTable属性</em></p><p>StackMapTable属性在JDK1.6发布后增加到了Class文件规范中，他是一个复杂的变长属性，位于Code属性的属性表中。这个属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器（Type Checker）使用，目的在于代替以前比较消耗性能的基于数据流分析的类型推到验证器。</p><p>StackMapTable属性中包含零至多个栈映射帧（Stack Map Frames），每个栈映射帧都显式或隐式地代表了一个字节码偏移量，用于表示该执行到字节码时局部变量表和操作数栈的验证类型。类型检查验证器会通过检查目标方法的局部变量和操作数栈所需要的类型来确定一段字节码指令是否符合逻辑约束。</p><p>一个方法的Code属性最多只能有一个StackMapTable属性，否则将抛出ClassFormatError异常。</p><p><em>10.Signature属性</em></p><p>Signature属性在JDK1.5发布后增加到了Class文件规范中，它是一个可选的定长属性，可以出现于类、属性表和方法表结构中。在JDK1.5中大幅增强了Java语言的语法，在此之后，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variables）或参数化类型（Parameterized Types），则Signature属性会为它记录泛型签名信息。</p><p><em>11.BootstrapMethods属性</em></p><p>BootstrapMethods属性在JDK1.7发布后增加到了Class文件规范之中，它是一个复杂的变长属性，位于类文件的属性表中。这个属性用于保存invokedynamic指令引用的引导方法限定符。</p><h4 id="字节码指令简介"><a href="#字节码指令简介" class="headerlink" title="字节码指令简介"></a>字节码指令简介</h4><p>Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode）以及跟随其后的零至多个代表此操作所需参数（称为操作数，Operands）而构成。</p><p>字节码指令集是一种具有鲜明特点、优劣势都很突出的指令集架构，由于限制了Java虚拟机操作码的长度为一个字节，所以指令集的操作码总数不可能超过256条；又由于Class文件格式放弃了编译后代码的操作数长度对齐，这就意味着虚拟机处理那些超过一个字节数据的时候，不得不在运行时从字节中重建出具体数据的结构，这样做在某种程度上会导致解释执行字节码时损失一些性能。但这样做的优势也非常明显，放弃了操作数长度对齐，就意味着可以省略很多填充和间隔符号；用一个字节来代替操作码，也是尽可能获得短小精干的编译代码。这种追求尽可能小的数据量、高传输效率的设计是由Java语言设计之初面向网络、智能家电的技术背景所决定的，并一直沿用至今。</p><p><strong>字节码与数据类型</strong></p><p>在Java虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。</p><p>指令集将会故意被设计成非完全独立的（Java虚拟机规范中把这种特性称为“Not Orthogonal”，即并非每种数据类型和每一种操作都有对应的指令）。</p><p><strong>加载和存储指令</strong></p><p>加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输。</p><p><strong>运算指令</strong></p><p>运算或算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。大体上算术指令可以分为两种：对整型数据进行运算的指令与对浮点型数据进行运算的指令。</p><p>Java虚拟机要求在进行浮点数运算时，所有的运算结果都必须舍入到适当的精度，非精确的的结果必须舍入为可被表示的最接近的精确值，如果有两种可表示的形式与该值一样接近，将优先选择最低有效位为零的。这种舍入模式也是IEEE 754规范中默认舍入模式，称为向最接近数舍入模式。</p><p>在把浮点数转换为整数时，Java虚拟机使用IEEE 754标准中的向零舍入模式，这种模式的舍入结果会导致数字被截断，所有小数部分的有效字节都会被丢弃掉。向零舍入模式将在目标数值类型中选择一个最接近但是不大于原值的数字来作为最精确的舍入结果。</p><p>Java虚拟机在处理浮点数运算时，不会抛出任何运行时异常，当一个操作产生溢出时，将会使用有符号的无穷大来表示，如果某个操作没有明确的数学定义的话，将会使用NaN来表示。所有使用NaN值作为操作数的算术操作，结果都会返回NaN。</p><p><strong>类型转换指令</strong></p><p>类型转换指令可以将两种不同的数值类型进行相互转换，这些转换操作一般用于实现用户代码中的显式类型转换操作，或者用来处理字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。</p><p>Java虚拟机直接支持（即转换时无需显式的转换指令）int、long和float的宽化类型转换（Widening Numberic Conversions，即小范围类型向大范围类型的安全转换），相对的，处理窄化类型转换（Narrowing Numberic Conversions）时，必须显式地使用转换指令来完成。窄化类型转换可能会导致转换结果产生不同的正负号、不同的数量级的情况，转换过程很可能会导致数值的精度丢失。</p><p>Java虚拟机规范中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常。</p><p><strong>对象创建与访问指令</strong></p><p>虽然类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令。对象创建后，就可以通过对象访问指令获取对象实例或数组实例中的字段或者数组元素。</p><p><strong>操作数栈管理指令</strong></p><p>出栈、复制栈顶元素重新压入栈顶、将栈顶的两个数值互换。</p><p><strong>控制转移指令</strong></p><p>控制转移指令可以让Java虚拟机有条件或无条件地从指定的位置指令而不是控制转移指令的下一条指令继续执行程序，从概念模型上理解，可以认为控制转移指令就是在有条件或无条件地修改PC寄存器的值。</p><p><strong>方法调用和返回指令</strong></p><p>方法调用指令与数据类型无关，而方法返回指令是根据返回值的类型区分的，包括ireturn、lreturn、freturn、dreturn和areturn，另外还有一条return指令供声明为void的方法、实例初始化方法以及类和接口类初始化方法的使用。</p><p><strong>异常处理指令</strong></p><p>在Java程序中显式抛出异常的操作（throw语句）都是由athrow指令来实现的，而处理异常（catch语句）不是由字节码指令来实现的，而是采用异常表来完成的。</p><p><strong>同步指令</strong></p><p>Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor）来支持的。</p><p>方法级的同步是隐式的，即无须通过字节码指令来控制，它实现在方法调用和返回操作之中。在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那么这个同步方法所持有的管程将在异常抛到同步方法之外时自动释放。</p><h4 id="公有设计和私有实现"><a href="#公有设计和私有实现" class="headerlink" title="公有设计和私有实现"></a>公有设计和私有实现</h4><p>一个优秀的虚拟机实现，在满足虚拟机规范的约束下对具体实现作出修改和优化是完全可行的，并且虚拟机规范中明确鼓励实现者这样做。</p><p>精确定义的虚拟机和目标文件格式不应当对虚拟机实现者的创造性产生太多的限制，Java虚拟机应被设计成可以允许有众多不同的实现，并且各种实现可以在保持兼容性的同时提供不同的、新的、有趣的解决方案。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>Java</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《深入理解Java虚拟机：JVM高级特性与最佳实践》笔记(三)</title>
    <link href="/2019/04/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E3%80%8B%E7%AC%94%E8%AE%B0-%E4%B8%89/"/>
    <url>/2019/04/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E3%80%8B%E7%AC%94%E8%AE%B0-%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<h3 id="虚拟机性能监控与故障处理工具"><a href="#虚拟机性能监控与故障处理工具" class="headerlink" title="虚拟机性能监控与故障处理工具"></a>虚拟机性能监控与故障处理工具</h3><ul><li>命令行工具<ul><li><code>jps</code>：虚拟机进程状况工具</li><li><code>jstat</code>：虚拟机统计信息监视工具</li><li><code>jinfo</code>：Java配置信息工具</li><li><code>jmap</code>：Java内存映像工具</li><li><code>jstack</code>：Java堆栈跟踪工具</li><li><code>HSDIS</code>：JIT生成代码反汇编</li></ul></li><li>可视化工具<ul><li><code>jconsole</code>：Java监视与管理控制台</li><li><code>jvisualvm</code>：多合一故障处理工具</li></ul></li></ul><span id="more"></span><h3 id="调优案例分析与实战"><a href="#调优案例分析与实战" class="headerlink" title="调优案例分析与实战"></a>调优案例分析与实战</h3><h4 id="高性能硬件上的程序部署策略"><a href="#高性能硬件上的程序部署策略" class="headerlink" title="高性能硬件上的程序部署策略"></a>高性能硬件上的程序部署策略</h4><p>目前主要有两种方式：</p><ul><li>通过64位JDK来使用大内存。</li><li>使用若干个32位虚拟机建立逻辑集群来利用硬件资源。</li></ul><p>64位JDK管理大内存需要考虑的问题：</p><ol><li>内存回收导致的长时间停顿。</li><li>64位JDK的性能测试结果低于32位JDK。</li><li>需要保证程序足够稳定，因为这种应用要是产生堆溢出几乎就无法产生堆转储快照，哪怕产生了快照也几乎无法分析。</li><li>相同程序在64位的JDK消耗的内存一般也比32位JDK大，这是由于指针膨胀，以及数据类型对齐补白等因素导致的。</li></ol><p>使用逻辑集群来部署程序，可能会遇到以下问题：</p><ol><li>尽量避免节点竞争全局的资源，最典型的就是磁盘竞争，各个节点如果同时访问磁盘文件的话（尤其是并发写操作容易出现问题），很容易导致IO异常。</li><li>很难最高效地利用某些资源池，譬如连接池，一般都是在各个节点建立自己独立的连接池，这样可能导致一些节点池满了而另外一些节点仍有较多空余。尽管使用集中式的JNDI，但这个有一定复杂性并且可能带来额外的性能开销。</li><li>各个节点仍然不可避免地受到32位的内存限制，在32位Windows平台中每个进程只能使用2GB的内存，考虑到堆以外的内存开销，堆一般最多只能开到1.5GB。在某些Linux或者UNIX系统中，可以提升到3GB乃至接近4GB的内存，但32位中仍然受最高4GB内存的限制。</li><li>大量使用本地缓存的应用，在逻辑集群中会造成较大的内存浪费，因为每个逻辑节点上都有一份缓存，这时候可以考虑把本地缓存改为集中式缓存。</li></ol><h4 id="集群间同步导致的内存溢出"><a href="#集群间同步导致的内存溢出" class="headerlink" title="集群间同步导致的内存溢出"></a>集群间同步导致的内存溢出</h4><p>集群同步数据，网络传输带宽不足，重发数据在内存堆积，导致内存溢出。</p><h4 id="堆外内存导致的溢出错误"><a href="#堆外内存导致的溢出错误" class="headerlink" title="堆外内存导致的溢出错误"></a>堆外内存导致的溢出错误</h4><p>除了Java堆和永久代之外，以下区域还会占用较多的内存，这里所有的内存总和受到操作系统进程最大内存的限制。</p><ul><li>Direct Memory：可通过<code>-XX:MaxDirectMemorySize</code>调整大小，内存不足时抛出OutOfMemoryError或者OutOfMemoryError：Direct buffer memory。</li><li>线程堆栈：可通过<code>-Xss</code>调整大小，内存不足时抛出StackOverflowError（纵向无法分配，即无法分配新的栈帧）或者OutOfMemoryError：unable to create new native thread（横向无法分配，即无法建立新的线程）。</li><li>Socket缓存区：每个Socket连接都有Receive和Send两个缓冲区，分别占大约37KB和25KB内存，连接多的话这块内存占用也比较客观。如果无法分配，则可能会抛出IOException：Too many open files异常。</li><li>JNI代码：如果代码中使用JNI调用本地库，那本地库使用的内存也不在堆中。</li><li>虚拟机和GC：虚拟机、GC的代码执行也要消耗一定的内存。</li></ul><h4 id="外部命令导致系统缓慢"><a href="#外部命令导致系统缓慢" class="headerlink" title="外部命令导致系统缓慢"></a>外部命令导致系统缓慢</h4><p>Java执行<code>Runtime.getRuntime().exec()</code>的过程是：首先克隆一个和当前虚拟机拥有一样环境变量的进程，再用这个新的进程去执行外部命令，最后再退出这个进程。如果频繁执行这个操作，系统的消耗会很大。</p><h4 id="服务器JVM进程崩溃"><a href="#服务器JVM进程崩溃" class="headerlink" title="服务器JVM进程崩溃"></a>服务器JVM进程崩溃</h4><p>等待的线程和Socket连接数量超过了虚拟机的承受能力。解决办法：生产者-消费者模式。</p><h4 id="不恰当的数据结构导致内存占用过大"><a href="#不恰当的数据结构导致内存占用过大" class="headerlink" title="不恰当的数据结构导致内存占用过大"></a>不恰当的数据结构导致内存占用过大</h4><p>在HashMap&lt;Long, Long&gt;结构中，只有Key和Value所存放的两个长整型数据是有效数据，共16B（2x8B）。这两个长整型数据包装成java.lang.Long对象之后，就分别具有8B的MarkWord、8B的Klass指针，在加8B存储数据的long值。在这两个Long对象组成Map.Entry之后，又多了16B的对象头，然后一个8B的next字段和4B的int型hash字段，为了对齐，还必须添加4B的空白填充，最后还有HashMap中对这个Entry的8B的引用，这样增加了两个长整型数字，实际耗费内存为(Long(24B)x2)+Entry(32B)+HashMap Ref(8B) = 88B，空间效率为16/88=18%，实在是太低了。</p><h4 id="由Windows虚拟内存导致的长时间停顿"><a href="#由Windows虚拟内存导致的长时间停顿" class="headerlink" title="由Windows虚拟内存导致的长时间停顿"></a>由Windows虚拟内存导致的长时间停顿</h4><p>Java的GUI程序，当它最小化时，资源管理器中显示的占用内存大幅度减小，但是虚拟内存则没有变化，可能是程序最小化时它的工作内存被自动交换到磁盘的页面文件中了，这样发生GC时就可能因为恢复页面文件的操作而导致不正常的GC停顿。可以加入参数<code>-Dsun.awt.keepWorkingSetOnMinimize=true</code>解决。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>Java</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《深入理解Java虚拟机：JVM高级特性与最佳实践》笔记(二)</title>
    <link href="/2019/04/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E3%80%8B%E7%AC%94%E8%AE%B0-%E4%BA%8C/"/>
    <url>/2019/04/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E3%80%8B%E7%AC%94%E8%AE%B0-%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h3><ul><li>哪些内存需要回收？</li><li>什么时候回收？</li><li>如何回收？</li></ul><h4 id="引用计数算法（Reference-Counting）"><a href="#引用计数算法（Reference-Counting）" class="headerlink" title="引用计数算法（Reference Counting）"></a>引用计数算法（Reference Counting）</h4><p>实现简单，判定效率高，但主流的Java虚拟机里面都没有选用引用计数算法进行内存管理，主要原因就是很难解决对象之间相互循环引用的问题。</p><h4 id="可达性分析算法（Reachability-Analysis）"><a href="#可达性分析算法（Reachability-Analysis）" class="headerlink" title="可达性分析算法（Reachability Analysis）"></a>可达性分析算法（Reachability Analysis）</h4><p>基本思路：通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始自顶向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</p><p>Java中，可作为GC Roots的对象包括：虚拟机栈（栈帧中的本地变量表）中引用的对象、方法区中类静态属性引用的对象、方法区中常量引用的对象、本地方法栈中JNI（即一般说的Native方法）引用的对象。</p><span id="more"></span><h4 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h4><p>JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这四种引用强度依次减弱。</p><ul><li>强引用类似<code>Object obj = new Objecg()</code>这类，只要有就不会被回收。</li><li>软引用用来描述一些还有用但并非必需的对象。在内存溢出之际，会把这些对象列进回收范围进行第二次回收。如果回收后还不够，才会抛出内存溢出异常。</li><li>弱引用也是描述非必须对象的，但比软引用更弱。垃圾收集器工作时即使内存够用也会回收。</li><li>虚引用是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。被虚引用关联的对象呗收集器回收时会收到一个系统通知</li></ul><h4 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h4><p>可达性分析算法中不可达的对象，被第一次标记且进行一次筛选，筛选出有必要执行finalize()方法的对象。当对象没覆盖finalize()方法或者finalize()方法已经被虚拟机调用过，则<strong>不再执行</strong>。</p><p>如果需要执行finalize()方法，对象将会放置在F-Queue队列中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。但并不承诺会等待它运行结束。</p><p>如果对象在finalize()方法中重新与引用链上的对象建立关联，则在第二次标记时被移出“即将回收”的集合。</p><p>finalize()方法运行代价高昂，不确定性打且无法保证各个对象的调用顺序，非常不建议使用。</p><h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4><p>常量池中字面量的回收：没有任何对象引用常量池中的字面量</p><p>类的回收：该类所有实例都已经被回收，加载该类的CLassLoader已经被回收，该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方反射访问该类方法。</p><h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><ul><li>标记-清除（Mark-Sweep）算法：效率不高，产生大量不连续的内存碎片</li><li>复制（Copying）算法：效率高，但内存可用量减少。用来回收新生代。复制时Survivor空间不够时需要依赖老年代进行分配担保（Handler Promotion）</li><li>标记-整理（Mark-Compact）算法：标记后不直接清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</li><li>分代收集算法：分新生代和老年代，根据各年代特点采用合适的收集算法</li></ul><h4 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h4><p>枚举根节点时必须要停顿所有Java执行线程（Sun将这件事情称为“Stop The World”）。</p><p>安全点（Safepoint）的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的。“长时间执行”的最明显特征就是指令序列复用。另一个需要考虑的是如何在GC发生时让所有的线程（这里不包括执行JNI调用的线程）都run到最近的安全点再停顿下来。</p><p><em>抢先式中断（Preemptive Suspension）</em></p><p>不需要线程的主动配合，GC时首先把所有线程全部中断，如果有线程中断的地方不在安全点上，就恢复线程让它run到安全点上。目前几乎没有虚拟机实现这种方式来响应GC。</p><p><em>主动式中断（Voluntary Suspension）</em></p><p>不直接对线程操作，而是设置一个标志，各个线程执行时会主动轮询这个标志，发现标志为true时就自己中断挂起。轮询标志的地方和安全点是重合的，另外加上创建对象需要分配内存的时候。</p><p>如果线程处于Sleep或者Blocked状态，这时候线程无法响应JVM的中断请求，此时需要安全区域（Safe Region）来解决</p><p>安全区域是指在一段代码中，引用关系不会发生变化。在这个区域任意地方开始GC都是安全的。线程执行到安全区域时，JVM发起GC时就不用管标志自己为安全区域的线程了。在线程要离开安全区域时，需要检查系统是否完成了根节点枚举，若没完成就必须等待直到收到可以安全离开Safe Region的信号为止。</p><h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><p>以下基于JDK1.7 Update 14之后的Hotspot虚拟机</p><p><strong>Serial收集器</strong></p><p>单线程，进行垃圾收集时必须暂停其他所有的工作线程直到收集结束。虚拟机运行在Client模式下默认的新生代收集器，因为简单而高效（相比其他收集器的单线程）。</p><p><strong>ParNew收集器</strong></p><p>Serial收集器的多线程版本，众多运行在Server模式下的虚拟机中首选的新生代收集器，一个与性能无关但是很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。</p><p><strong>Parallel Scavenge</strong></p><p>新生代收集器，使用复制算法，多线程并行收集器。目标是达到一个可控制的吞吐量（Throughput）。也经常称为“吞吐量优先”收集器。</p><p>提供两个参数，分别是控制最大垃圾收集停顿时间的<code>-XX:MAxGCPauseMillis</code>参数以及直接设置吞吐量大小的<code>-XX:GCTimeRatio</code>参数。</p><p>MAxGCPauseMillis设定的停顿时间缩短是牺牲吞吐量和新生代空间为代价的。</p><p>GCTimeRatio是垃圾收集时间占总时间的比率，相当于吞吐量的倒数。默认值99，就是允许最大1%（即1/(1+99)）的垃圾收集时间。</p><p>除上述两个参数外，还有一个<code>-XX:+UseAdaptiveSizePolicy</code>值得关注。这是一个开关参数，打开后就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeTreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics）。也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。</p><p><strong>Serial Old收集器</strong></p><p>Serial收集器的老年代版本，单线程收集器，使用“标记-整理”算法。主要意义也是在于给Client模式下的虚拟机使用。</p><p>如果在Server模式下，那么它主要还有两大用途：一用途是在JDK1.5以及之前的版本中与Parallel Scavenge收集器搭配使用，另一种用途就是作为CMS收集器的后备预案，在并发收集器发生Concurrent Mode Failure时使用。</p><p><strong>Parallel Old收集器</strong></p><p>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。在JDK1.6中才开始提供，在此之前，新生代的Parallel Scavenge收集器一直处于比较尴尬的状态。因为如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old（PS MarkSweep）收集器外别无选择。由于单线程的老年代手机中无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有ParNew加CMS的组合给力。</p><p>直到Parallel Old收集器出现后，在注重吞吐量以及CPU资源敏感的场合，都可以考虑Parallel Scavenge加Parallel Old收集器。</p><p><strong>CMS收集器</strong></p><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网或者B/S系统的服务端上，这类应用尤其重视服务器的响应速度，希望系统停顿时间最短，以给用户带来较好的体验，CMS收集器就非常符合这类应用的需求。</p><p>基于“标记-清除”算法，运作过程相对更复杂，分4个步骤：</p><ul><li>初始标记（CMS initial mark）</li><li>并发标记（CMS concurrent mark）</li><li>冲洗标记（CMS remark）</li><li>并发清除（CMS concurrent sweep）</li></ul><p>其中初始标记、重新标记这两步仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会必初始标记阶段稍长一些，但远比并发标记的时间短。</p><p>由于整个过程中耗时最长的并发标记和并发清楚过程收集器线程都可以与用户线程一起工作，所以从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。Sun公司的一些官方文档中也称之为并发低停顿收集器（Concurrent Low Pause Collector）。但仍有以下3个明显缺点：</p><ul><li>CMS收集器对CPU资源非常敏感。在并发阶段，虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。CMS默认启动的回收线程数是(CPU数量+3)/4，也就是4个以上CPU时，并发回收时垃圾收集线程不少于25%的CPU资源，并随着CPU数量增加而下降。但当CPU不足4个时，CMS对用户程序的影响就可能变得很大。为了应付这种情况，虚拟机提供了一种称为“增量式并发收集器”（Incremental Concurrent Mark Sweep/i-CMS）的CMS收集器的变种，所做的事情和单CPU年代PC机操作系统使用抢占式来模拟多任务机制的思想一样，就是在并发标记、清理的时候让GC线程、用户线程交替运行，尽量减少GC线程独占资源的时间，这样整个垃圾收集的过程会更长，但对用户程序的影响就会显得少一些。实践证明，增量式的CMS收集器效果很一般，目前版本i-CMS已经被声明为“deprecated”。</li><li>CMS收集器无法处理浮动垃圾（Floating Garbage），可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行着，同事也在不断产生新的垃圾，只好留待下一次GC时再清理掉。也是由于垃圾收集阶段用户线程还需要运行，所以需要预留足够的内存空间给用户线程使用。在JDK1.5的默认设置下，CMS收集器在老年代使用了68%的空间后就会被激活，在JDK1.6中，启动阈值已经提升至92%。要是在CMS运行期间无法满足程序的需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数<code>-XX:CMSInitiatingOccupancyFraction</code>设置太高反而降低了性能。</li><li>CMS是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，老年代还有很大空间剩余，但无法找到足够大的连续空间，不得不提前触发一次Full GC。为了解决这个问题，CMS收集器提供了一个<code>-XX:+UseCMSCompactAtFullCollection</code>开关参数（默认开启），用于在CMS收集器定不住要进行Full GC时开启内存碎片的合并整理过程，该过程无法并发，所以停顿时间不得不变长。CMS还提供另一个参数<code>-XX:CMSFullGCsBeforeCompaction</code>，这个参数是用于设置多少次不压缩的Full GC后，跟着带来一次带压缩的（默认为0，表示每次进入Full GC时都进行碎片整理）。</li></ul><p><strong>G1收集器</strong></p><p>G1（Garbage-First）收集器是一款面向服务端应用的垃圾收集器。具备如下特点：</p><ul><li>并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU或者CPU核心来缩短Stop-The-World停顿时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。</li><li>分代收集：G1从整体来看是基于“标记-整理”算法实现的的收集器，从局部（两个Region）上来看是基于“复制”算法实现的，两种算法都意味着G1运作期间不会产生内存空间碎片。该特性利于程序长时间运行。</li><li>可预测的停顿：让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</li></ul><p>使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。</p><p>G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</p><p>在G1收集器中，Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用都是使用Remembered Set来避免全堆扫描。</p><p>如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为以下几个步骤：</p><ul><li>初始标记（Initial Marking）</li><li>并发标记（Concurrent Marking）</li><li>最终标记（Final Marking）</li><li>筛选回收（Live Data Counting and Evacuation）</li></ul><p>初始标记阶段仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TSMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。并发标记阶段是从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序兵法执行。而最终标记阶段则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。最后在筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，从Sun公司透露出来的信息来看，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高手机效率。</p><p><strong>理解GC日志</strong></p><p>每个收集器的日志格式都可以不一样，但虚拟机的设计者为了方便用户阅读，将各个收集器的日志都维持一定的共性。</p><p>最前面的数字代表了GC发生的时间，这个数字的含义是从Java虚拟机启动以来经过的秒数。</p><p>开头的“[GC”和“[Full GC”说明了这次垃圾收集的停顿类型，而不是用来区分新生代GC还是老年代GC的。如果有“[Full GC”说明这次GC是发生了Stop-The-World的。如果是调用<code>System.gc()</code>方法所触发的手机，那么这里将显示“[Full GC(System)”。</p><p>接下来的“[DefNew”、“[Tenured”、“[Perm”表示GC发生的区域，这里显示的区域名称与使用的GC收集器是密切相关的。</p><p>后面方括号内部的“3324K-&gt;152K(3712K)”含义是“GC前该内存区域已使用容量-&gt;GC后该内存区域已使用容量（该内存区域总容量）”。而方括号之外的“3324K-&gt;152K(11904K)”表示“GC前Java堆已使用容量-&gt;GC后Java堆已使用容量（Java堆总容量）”。</p><p>再往后，“0.0025925secs”表示该内存区域GC所占用的时间，单位是秒。有的收集器会给出更具体的时间数据，如user、sys和real等，与Linux的time命令所输出的时间含义一致。</p><h4 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h4><p>几条在使用Client模式虚拟机的内存分配规则：</p><ul><li>对象优先在Eden分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC（新生代GC）。Major GC（老年代GC）的速度一般会比Minor GC慢10倍以上。</li><li>大对象直接进入老年代。 典型的大对象就是那种很长的字符串以及数组。写程序时应当避免出现一群“朝生夕灭”的“短命大对象”，否则导致内存还有不少空间时就要提前触发垃圾收集。</li><li>长期存活的对象将进入老年代。虚拟机给每个对象定义了一个对象年龄（Age）计数器。对象在Survivor区每经历一次Minor GC，年龄就增加1岁，当年龄增加到一定程度（默认15岁），就会被晋升到老年代。</li><li>动态对象年龄判断。如果Survivor空间中相同年龄所有对象大小的综合大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</li><li>空间分配担保。在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立则会查看设置是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者设置不允许冒险，那这时也要改为进行一次Full GC。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>Java</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《深入理解Java虚拟机：JVM高级特性与最佳实践》笔记(一)</title>
    <link href="/2019/04/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E3%80%8B%E7%AC%94%E8%AE%B0-%E4%B8%80/"/>
    <url>/2019/04/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJVM%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E3%80%8B%E7%AC%94%E8%AE%B0-%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h3 id="Java-内存区域与内存溢出异常"><a href="#Java-内存区域与内存溢出异常" class="headerlink" title="Java 内存区域与内存溢出异常"></a>Java 内存区域与内存溢出异常</h3><ul><li>运行时数据区<ul><li>所有线程共享的数据区<ul><li>方法区(Method Area)</li><li>堆(Heap)</li><li>执行引擎</li><li>本地库接口</li></ul></li><li>线程隔离的数据区<ul><li>程序计数器(Program Counter Register)</li><li>本地方法栈(Native Method Stack)</li><li>虚拟机栈(VM Stack)</li></ul></li></ul></li></ul><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>当前线程所执行的字节码的行号指示器。如果执行Java方法，记录正在执行的虚拟机字节码指令的地址；如果执行Native方法，值为Undefined。唯一一个在Java虚拟机规范中没有规定任何OOM情况的区域。</p><span id="more"></span><h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>每个Java方法执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。局部变量表所需内存在编译期间完成分配，运行期间不会改其大小。</p><p>StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度时</p><p>OutOfMemoryError：虚拟机栈可以动态扩展，扩展时无法申请到足够的内存时</p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>类似虚拟机栈，区别是执行虚拟机用到的Native方法。方法使用的语言、使用方式与数据结构没有强制规定，可自由实现。</p><h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>存放对象实例，虚拟机启动时创建。随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术使得有些对象不会分配到堆上。</p><p>垃圾收集器管理的主要区域，也称“GC堆”（Garbage Collected Heap）。</p><p>可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。如果没有内存完成实例分配也无法扩展时将抛出OutOfMemoryError。</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>用于存储已被虚拟机加载的类信息、常量、静态变量、即使编译器编译后的代码数据。内存回收目标主要是针对常量池的回收和对类型的卸载。</p><p>当内存无法满足分配需求时将抛出OutOfMemoryError。</p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>方法区的一部分，用于存放编译期生成的各种字面量和符号引用。</p><p>无法再申请到内存的时候会抛出OutOfMemoryError。</p><h4 id="直接内存（Direct-Memory）"><a href="#直接内存（Direct-Memory）" class="headerlink" title="直接内存（Direct Memory）"></a>直接内存（Direct Memory）</h4><p>JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，避免在Java堆和Native堆中来回复制数据。</p><p>受机器总内存大小以及处理器寻址空间、操作系统的限制，超出时将导致动态扩展出现OutOfMemoryError。</p><h3 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h3><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><ol><li>遇到new指令</li><li>检查是否能在常量池中定位到一个类的符号引用</li><li>检查类是否已被加载、解析和初始化过</li><li>分配内存，内存大小在类加载完成后便完全确定</li><li>设置对象头（Object Header）</li><li>由字节码中是否跟随Invokeespecial指令决定，执行new指令之后会接着执行<init>方法。</li></ol><p>分配堆内存，如果Java堆中内存是绝对规整的，使用“指针碰撞（Bump the Pointer）”分配方式；否则使用“空闲列表（Free List）”方式。</p><p>并发分配两种方案，一种对分配内存空间的动作进行同步处理——实际采用CAS配上失败重试的方式保证更新操作的原子性；另一种是本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）。TLAB用完并分配新的TLAB时才需要同步锁定。</p><h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p>三块区域：对象头（Object Header）、实例数据（Instance Data）和对齐填充（Padding）。</p><p>对象头包括两部分，第一部分存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，官方称它为“Mark Word”。另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><p>实例数据部分是对象真正存储的有效信息。</p><p>对齐填充并不是必要的，只是占位符，使对象的大小必是8字节的整数倍。</p><h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p>主流的访问方式有两种，使用句柄和直接指针。</p><ol><li>使用句柄则Java堆专门划分一块内存作为句柄池，reference中存储对象的句柄地址，句柄中包含对象实例数据与类型数据各自的具体地址信息。好处：对象移动时，reference不需要修改。</li><li>直接指针则Java堆对象的布局就需要放置访问对象类型数据的指针。优点：访问速度快。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>Java</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>停更一段时间</title>
    <link href="/2018/04/%E5%81%9C%E6%9B%B4%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4/"/>
    <url>/2018/04/%E5%81%9C%E6%9B%B4%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<p>主要是因为对自己生产的内容的深度不满意，然而目前又处于技术转向期，还需要更多的时间去沉淀，厚积而薄发，期待自己的蜕变。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2017 Milestones</title>
    <link href="/2017/12/2017-Milestones/"/>
    <url>/2017/12/2017-Milestones/</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th align="left">时间</th><th align="left">事件</th><th align="left">收获及心得</th></tr></thead><tbody><tr><td align="left">1月末</td><td align="left"><a href="https://liubin92.github.io/material-ui-demo/">Material-UI Demo</a></td><td align="left">熟悉 ES6&amp;React&amp;Webpack，理解了单页面应用的开发模式</td></tr><tr><td align="left">3月初</td><td align="left">使用 Dva.js 实现 new-cross-reach 前端</td><td align="left">新技术提升了生产力，但生产力还是得靠人</td></tr><tr><td align="left">4月中</td><td align="left">初步完成，<a href="https://liubin92.github.io/2017/04/redux-saga%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%E5%8F%8A%E5%85%B6%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD%E5%9C%A8dvajs%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/">进一步了解 saga</a></td><td align="left">异步编程很神奇，Generator很强大</td></tr><tr><td align="left">5月初</td><td align="left">JWT+Apache Thrift 跑通单点登录远程调用</td><td align="left">实际产品的场景中，写RPC还不如直接写Json API</td></tr><tr><td align="left">6月中旬</td><td align="left"><a href="https://liubin92.github.io/2017/04/Docker%E5%9C%A8PHP%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/">使用 Docker 搭建项目环境</a></td><td align="left">适用于机器数量弹性伸缩的场景，应结合容器编排工具，实际产品场景不解决问题，还会添加新问题</td></tr><tr><td align="left">7月</td><td align="left"><a href="https://liubin92.github.io/2017/07/Mysql-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/">MySQL的主从搭建和配置文件详解</a></td><td align="left">结合2016下半年打下的MySQL基础，进一步了解InnoDB，也从跑数的过程中实践了学习成果</td></tr><tr><td align="left">4月底至8月初</td><td align="left">补习线性代数和概率统计</td><td align="left">对机器学习的认识加深，技术终究还是要回归用户场景，目前唯一可能用上的就是 CTR预估，努力方向有两个，一个是设计数学模型的研究员，另一个是调神经网络参数的工程师，前一个酷炫可是对我不现实，后一个现实但不酷炫。NLP现在有许多现成的使用方便的轮子，没做太多功课</td></tr><tr><td align="left">8月初</td><td align="left">学完<a href="http://nikic.github.io/2012/12/22/Cooperative-multitasking-using-coroutines-in-PHP.html">使用协程实现协作式多任务调度</a></td><td align="left">造轮子就是酷，语言、框架、存储引擎都只是工具</td></tr><tr><td align="left">9月初</td><td align="left"><a href="https://liubin92.github.io/2017/09/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0IP%E5%BA%93%E7%9A%84%E6%95%B4%E5%90%88/">C语言实现IP库的整合</a></td><td align="left">熟悉C语言</td></tr><tr><td align="left">10月中旬</td><td align="left">通读<a href="https://github.com/liubin92/linux-server-demo">Linux高性能服务器编程</a></td><td align="left">熟悉Linux网络编程</td></tr><tr><td align="left">11月初</td><td align="left">NodeJS重构取数脚本</td><td align="left">异步非阻塞是把双刃剑，控制并发是关键</td></tr><tr><td align="left">11月中旬</td><td align="left">PHP爬虫 &amp; 源码学习</td><td align="left">学习 Symfony 风格 &amp; PHP source code</td></tr><tr><td align="left">12月</td><td align="left">Pig编程</td><td align="left">了解Hadoop，开启大数据之旅</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言实现IP库的整合</title>
    <link href="/2017/09/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0IP%E5%BA%93%E7%9A%84%E6%95%B4%E5%90%88/"/>
    <url>/2017/09/C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0IP%E5%BA%93%E7%9A%84%E6%95%B4%E5%90%88/</url>
    
    <content type="html"><![CDATA[<p>在上一篇文章<a href="/2017/08/C%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8sscanf-%E8%A7%A3%E6%9E%90%E5%AD%97%E7%AC%A6%E4%B8%B2/">《C语言使用sscanf()解析字符串》</a>中提到过，前段时间在底层同学那接了个作业，用 C 写一个 IP库匹配的程序，以巩固我的C 语言学习成果。最近终于完成了地域IP 与设备IP 的整合，过程也算几经波折，前文写的就是小波折的其中之一，而如今作业就先阶段性的做到这儿吧，我先阶段性的总结一下。毕竟这只是生产环境中用到的其中一环，而我要去做更酷的事情了，具体是什么事情，敬请期待。</p><span id="more"></span><h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><p>已知 IP库 如下</p><p><strong>base_ip.csv</strong></p><table><thead><tr><th align="left">start ip</th><th align="left">end ip</th><th align="left">code</th></tr></thead><tbody><tr><td align="left">0.0.0.0</td><td align="left">1.0.0.255</td><td align="left">1000000000</td></tr><tr><td align="left">1.0.1.0</td><td align="left">1.0.3.255</td><td align="left">1156350100</td></tr><tr><td align="left">0.0.0.0</td><td align="left">1.0.0.255</td><td align="left">1000000000</td></tr><tr><td align="left">…</td><td align="left">…</td><td align="left">…</td></tr><tr><td align="left">224.0.0.0</td><td align="left">255.255.255.255</td><td align="left">1000000000</td></tr></tbody></table><p><strong>mobile_ip.csv</strong></p><table><thead><tr><th align="left">start ip</th><th align="left">end ip</th><th align="left">code</th></tr></thead><tbody><tr><td align="left">1.0.1.0</td><td align="left">1.0.3.255</td><td align="left">WIFI</td></tr><tr><td align="left">1.0.8.0</td><td align="left">1.0.15.255</td><td align="left">WIFI</td></tr><tr><td align="left">1.0.32.0</td><td align="left">1.0.63.255</td><td align="left">WIFI</td></tr><tr><td align="left">…</td><td align="left">…</td><td align="left">…</td></tr><tr><td align="left">223.255.252.0</td><td align="left">223.255.253.255</td><td align="left">WIFI</td></tr></tbody></table><p>要求结果格式:</p><table><thead><tr><th align="left">start_ip</th><th align="left">end_ip</th><th align="left">base_code</th><th align="left">mobile_code</th></tr></thead><tbody><tr><td align="left">…</td><td align="left">…</td><td align="left">…</td><td align="left">…</td></tr></tbody></table><p>附加题：考虑原始IP库文件为海量数据的情况。</p><h3 id="几经波折"><a href="#几经波折" class="headerlink" title="几经波折"></a>几经波折</h3><p>为什么选择整合地域IP库与设备IP库呢，其实还有个大学IP库，原因很简单：</p><p>那货已经给这俩排好序了。</p><p>经过程序测试证实，地域IP库是升序且所有网段都是连续的，设备IP库是升序的，但网段不连续。</p><h4 id="IP的数据格式"><a href="#IP的数据格式" class="headerlink" title="IP的数据格式"></a>IP的数据格式</h4><p>说三个事情</p><ul><li>2^32 = 4294967296</li><li>32位操作系统中，unsigned int 的范围：0~4294967295</li><li>255^4 = 4228250625</li></ul><p>嗯。然后呢。</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">in_addr_t</span> <span class="hljs-title">inet_addr</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *)</span></span>;<br></code></pre></td></tr></table></figure><p>在linux 网络编程基础api 中，<code>inet_addr</code>函数将用点分十进制字符串表示的IPv4 地址转化为用网络字节序整数表示的IPv4 地址。失败时返回INADDR_NONE。</p><h4 id="字节序的问题"><a href="#字节序的问题" class="headerlink" title="字节序的问题"></a>字节序的问题</h4><p>字节序分为大端字节序(big endian)和小端字节序(little endian)</p><p>现代CPU 的累加器一次都能装载至少4字节，即一个整数。那么这4字节在内存中排列的顺序将影响它被累加器装载成的整数的值。不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，这个叫做主机序。通常有两种：</p><ul><li>little endian：地址低位存储值的低位，地址高位存储值的高位</li><li>big endian：地址低位存储值的高位，地址高位存储值的低位</li></ul><p>网络字节顺序是TCP/IP中规定好的一种数据表示格式，它与具体的CPU类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。网络字节顺序采用big endian排序方式。</p><p>下面代码可用于检查机器的字节序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-keyword">short</span> value;<br>        <span class="hljs-keyword">char</span> union_bytes[<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword">short</span>)];<br>    &#125; test;<br>    test.value = <span class="hljs-number">0x0102</span>;<br>    <span class="hljs-keyword">if</span> ((test.union_bytes[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) &amp;&amp; (test.union_bytes[<span class="hljs-number">1</span>] == <span class="hljs-number">2</span>)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;big endian\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((test.union_bytes[<span class="hljs-number">0</span>] == <span class="hljs-number">2</span>) &amp;&amp; (test.union_bytes[<span class="hljs-number">1</span>] == <span class="hljs-number">1</span>)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;little endian\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;unkonwn...\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>经检测，我现在写这篇文章用的mac是little endian的。</p><p>所以 I need this：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> <span class="hljs-title">htonl</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> hostlong)</span></span>; <span class="hljs-comment">//Host to Network Long</span><br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> <span class="hljs-title">htons</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> hostshort)</span></span>; <span class="hljs-comment">//Host to Network Short</span><br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ntohl</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> netlong)</span></span>; <span class="hljs-comment">//Network to Host Long</span><br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ntohs</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> netshort)</span></span>; <span class="hljs-comment">//Network to Host Short</span><br></code></pre></td></tr></table></figure><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>为了尽快的完成作业，就先不管它什么性能空间之类的了，先解决问题，然后再优化，结果写了个*<em>O(m</em>n)<strong>，然后里面只有一行<code>if (condition1 &gt; condition2)</code>就运行了24秒，还是算了，好好想想</strong>O(n)**怎么实现吧。</p><p><strong>毕竟俩库的IP都在0.0.0.0~255.255.255.255之间，好了，剩下的就是if else了。</strong></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>以下为源代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;stdio.h&gt;<br>#<span class="hljs-keyword">include</span> &lt;stdlib.h&gt;<br>#<span class="hljs-keyword">include</span> &lt;arpa/inet.h&gt;<br><br>#define MAXLIMIT <span class="hljs-number">64</span><br>#define IPCOUNT <span class="hljs-number">165158</span><br>#define MOBILECOUNT <span class="hljs-number">49664</span><br><br><span class="hljs-keyword">struct</span> row &#123;<br>    in_addr_t start_ip;<br>    in_addr_t end_ip;<br>    <span class="hljs-built_in">char</span> code<span class="hljs-literal">[<span class="hljs-number">16</span>]</span>;<br>&#125;;<br><br>void resolve<span class="hljs-constructor">_file(FILE <span class="hljs-operator">*</span><span class="hljs-params">fp</span>, <span class="hljs-params">struct</span> <span class="hljs-params">row</span> <span class="hljs-params">all_data</span>[])</span>;<br>in_addr_t addr<span class="hljs-constructor">_str_to_int(<span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">cp</span>)</span>;<br>void <span class="hljs-built_in">int</span><span class="hljs-constructor">_to_addr_str(<span class="hljs-params">in_addr_t</span> <span class="hljs-params">start</span>, <span class="hljs-params">in_addr_t</span> <span class="hljs-params">end</span>, <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">base_code</span>, <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">mobile_code</span>)</span>;<br><br><span class="hljs-built_in">int</span> main(<span class="hljs-built_in">int</span> argc, <span class="hljs-built_in">char</span> *argv<span class="hljs-literal">[]</span>) &#123;<br>    FILE *fp;<br>    <span class="hljs-built_in">char</span> *base_ip = <span class="hljs-string">&quot;../base_ip.csv&quot;</span>;<br>    <span class="hljs-built_in">char</span> *mobile_ip = <span class="hljs-string">&quot;../mobile_ip.csv&quot;</span>;<br>    <span class="hljs-keyword">struct</span> row struct_base_ip<span class="hljs-literal">[IPCOUNT]</span>;<br>    <span class="hljs-keyword">struct</span> row struct_mobile_ip<span class="hljs-literal">[MOBILECOUNT]</span>;<br><br>    <span class="hljs-keyword">if</span> ((fp = fopen(base_ip, <span class="hljs-string">&quot;r&quot;</span>))<span class="hljs-operator"> == </span>NULL) &#123;<br>        printf(<span class="hljs-string">&quot;cat: can&#x27;t open %s\n&quot;</span>, base_ip);<br>        exit(<span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        resolve<span class="hljs-constructor">_file(<span class="hljs-params">fp</span>, <span class="hljs-params">struct_base_ip</span>)</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ((fp = fopen(mobile_ip, <span class="hljs-string">&quot;r&quot;</span>))<span class="hljs-operator"> == </span>NULL) &#123;<br>        printf(<span class="hljs-string">&quot;cat: can&#x27;t open %s\n&quot;</span>, mobile_ip);<br>        exit(<span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        resolve<span class="hljs-constructor">_file(<span class="hljs-params">fp</span>, <span class="hljs-params">struct_mobile_ip</span>)</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">char</span> *line = <span class="hljs-string">&quot;start_ip,end_ip,base_code,mobile_code&quot;</span>;<br>    printf(<span class="hljs-string">&quot;%s\n&quot;</span>, line);<br>    in_addr_t start = <span class="hljs-number">0</span>, <span class="hljs-keyword">end</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, is_mobile_out = <span class="hljs-number">0</span>;;<br>    <span class="hljs-keyword">while</span> (i &lt; IPCOUNT) &#123;<br>        <span class="hljs-keyword">if</span> (j &lt; MOBILECOUNT) &#123;<br>            <span class="hljs-keyword">if</span> (struct_mobile_ip<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>.start_ip &gt; struct_base_ip<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.start_ip) &#123;<br>                start = struct_base_ip<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.start_ip;<br>                <span class="hljs-keyword">if</span> (struct_mobile_ip<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>.start_ip &gt; struct_base_ip<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.end_ip) &#123;<br>                    <span class="hljs-keyword">end</span> = struct_base_ip<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.end_ip;<br>                    <span class="hljs-built_in">int</span><span class="hljs-constructor">_to_addr_str(<span class="hljs-params">start</span>, <span class="hljs-params">end</span>, <span class="hljs-params">struct_base_ip</span>[<span class="hljs-params">i</span>].<span class="hljs-params">code</span>, <span class="hljs-string">&quot;NONE&quot;</span>)</span>;<br>                    ++i;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (struct_mobile_ip<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>.end_ip &gt; struct_base_ip<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.end_ip) &#123;<br>                    <span class="hljs-keyword">end</span> = struct_mobile_ip<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>.start_ip - <span class="hljs-number">1</span>;<br>                    <span class="hljs-built_in">int</span><span class="hljs-constructor">_to_addr_str(<span class="hljs-params">start</span>, <span class="hljs-params">end</span>, <span class="hljs-params">struct_base_ip</span>[<span class="hljs-params">i</span>].<span class="hljs-params">code</span>, <span class="hljs-string">&quot;NONE&quot;</span>)</span>;<br>                    start = struct_mobile_ip<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>.start_ip;<br>                    <span class="hljs-keyword">end</span> = struct_base_ip<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.end_ip;<br>                    <span class="hljs-built_in">int</span><span class="hljs-constructor">_to_addr_str(<span class="hljs-params">start</span>, <span class="hljs-params">end</span>, <span class="hljs-params">struct_base_ip</span>[<span class="hljs-params">i</span>].<span class="hljs-params">code</span>, <span class="hljs-params">struct_mobile_ip</span>[<span class="hljs-params">j</span>].<span class="hljs-params">code</span>)</span>;<br>                    ++i;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (struct_mobile_ip<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>.end_ip &lt; struct_base_ip<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.end_ip)&#123;<br>                    <span class="hljs-keyword">end</span> = struct_mobile_ip<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>.start_ip - <span class="hljs-number">1</span>;<br>                    <span class="hljs-built_in">int</span><span class="hljs-constructor">_to_addr_str(<span class="hljs-params">start</span>, <span class="hljs-params">end</span>, <span class="hljs-params">struct_base_ip</span>[<span class="hljs-params">i</span>].<span class="hljs-params">code</span>, <span class="hljs-string">&quot;NONE&quot;</span>)</span>;<br>                    start = struct_mobile_ip<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>.start_ip;<br>                    <span class="hljs-keyword">end</span> = struct_mobile_ip<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>.end_ip;<br>                    <span class="hljs-built_in">int</span><span class="hljs-constructor">_to_addr_str(<span class="hljs-params">start</span>, <span class="hljs-params">end</span>, <span class="hljs-params">struct_base_ip</span>[<span class="hljs-params">i</span>].<span class="hljs-params">code</span>, <span class="hljs-params">struct_mobile_ip</span>[<span class="hljs-params">j</span>].<span class="hljs-params">code</span>)</span>;<br>                    struct_base_ip<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.start_ip = struct_mobile_ip<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>.end_ip + <span class="hljs-number">1</span>;<br>                    ++j;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (struct_mobile_ip<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>.end_ip &gt; struct_base_ip<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.end_ip) &#123;<br>                    <span class="hljs-keyword">end</span> = struct_mobile_ip<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>.start_ip - <span class="hljs-number">1</span>;<br>                    <span class="hljs-built_in">int</span><span class="hljs-constructor">_to_addr_str(<span class="hljs-params">start</span>, <span class="hljs-params">end</span>, <span class="hljs-params">struct_base_ip</span>[<span class="hljs-params">i</span>].<span class="hljs-params">code</span>, <span class="hljs-string">&quot;NONE&quot;</span>)</span>;<br>                    start = struct_mobile_ip<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>.start_ip;<br>                    <span class="hljs-keyword">end</span> = struct_base_ip<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.end_ip;<br>                    <span class="hljs-built_in">int</span><span class="hljs-constructor">_to_addr_str(<span class="hljs-params">start</span>, <span class="hljs-params">end</span>, <span class="hljs-params">struct_base_ip</span>[<span class="hljs-params">i</span>].<span class="hljs-params">code</span>, <span class="hljs-params">struct_mobile_ip</span>[<span class="hljs-params">j</span>].<span class="hljs-params">code</span>)</span>;<br>                    ++i;<br>                    ++j;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (struct_mobile_ip<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>.start_ip &lt; struct_base_ip<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.start_ip) &#123;<br>                <span class="hljs-keyword">if</span> (struct_base_ip<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.start_ip &gt; struct_mobile_ip<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>.end_ip) &#123;<br>                    start = struct_mobile_ip<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>.start_ip;<br>                    <span class="hljs-keyword">end</span> = struct_mobile_ip<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>.end_ip;<br>                    <span class="hljs-built_in">int</span><span class="hljs-constructor">_to_addr_str(<span class="hljs-params">start</span>, <span class="hljs-params">end</span>, <span class="hljs-string">&quot;XXX&quot;</span>, <span class="hljs-params">struct_mobile_ip</span>[<span class="hljs-params">j</span>].<span class="hljs-params">code</span>)</span>;<br>                    ++j;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (struct_base_ip<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.end_ip &gt; struct_mobile_ip<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>.end_ip) &#123;<br>                    start = struct_base_ip<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.start_ip;<br>                    <span class="hljs-keyword">end</span> = struct_mobile_ip<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>.end_ip;<br>                    <span class="hljs-built_in">int</span><span class="hljs-constructor">_to_addr_str(<span class="hljs-params">start</span>, <span class="hljs-params">end</span>, <span class="hljs-params">struct_base_ip</span>[<span class="hljs-params">i</span>].<span class="hljs-params">code</span>, <span class="hljs-params">struct_mobile_ip</span>[<span class="hljs-params">j</span>].<span class="hljs-params">code</span>)</span>;<br>                    struct_base_ip<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.start_ip = struct_mobile_ip<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>.end_ip + <span class="hljs-number">1</span>;<br>                    ++j;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (struct_base_ip<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.end_ip &lt; struct_mobile_ip<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>.end_ip) &#123;<br>                    start = struct_base_ip<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.start_ip;<br>                    <span class="hljs-keyword">end</span> = struct_base_ip<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.end_ip;<br>                    <span class="hljs-built_in">int</span><span class="hljs-constructor">_to_addr_str(<span class="hljs-params">start</span>, <span class="hljs-params">end</span>, <span class="hljs-params">struct_base_ip</span>[<span class="hljs-params">i</span>].<span class="hljs-params">code</span>, <span class="hljs-params">struct_mobile_ip</span>[<span class="hljs-params">j</span>].<span class="hljs-params">code</span>)</span>;<br>                    ++i;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (struct_base_ip<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.end_ip<span class="hljs-operator"> == </span>struct_mobile_ip<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>.end_ip) &#123;<br>                    start = struct_base_ip<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.start_ip;<br>                    <span class="hljs-keyword">end</span> = struct_mobile_ip<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>.end_ip;<br>                    <span class="hljs-built_in">int</span><span class="hljs-constructor">_to_addr_str(<span class="hljs-params">start</span>, <span class="hljs-params">end</span>, <span class="hljs-params">struct_base_ip</span>[<span class="hljs-params">i</span>].<span class="hljs-params">code</span>, <span class="hljs-params">struct_mobile_ip</span>[<span class="hljs-params">j</span>].<span class="hljs-params">code</span>)</span>;<br>                    struct_base_ip<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.start_ip = struct_mobile_ip<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>.end_ip + <span class="hljs-number">1</span>;<br>                    ++j;<br>                    ++i;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                start = struct_base_ip<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.start_ip;<br>                <span class="hljs-keyword">if</span> (struct_base_ip<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.end_ip &gt; struct_mobile_ip<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>.end_ip) &#123;<br>                    <span class="hljs-keyword">end</span> = struct_mobile_ip<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>.end_ip;<br>                    <span class="hljs-built_in">int</span><span class="hljs-constructor">_to_addr_str(<span class="hljs-params">start</span>, <span class="hljs-params">end</span>, <span class="hljs-params">struct_base_ip</span>[<span class="hljs-params">i</span>].<span class="hljs-params">code</span>, <span class="hljs-params">struct_mobile_ip</span>[<span class="hljs-params">j</span>].<span class="hljs-params">code</span>)</span>;<br>                    struct_base_ip<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.start_ip = struct_mobile_ip<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>.end_ip + <span class="hljs-number">1</span>;<br>                    ++j;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (struct_base_ip<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.end_ip &lt; struct_mobile_ip<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>.end_ip) &#123;<br>                    <span class="hljs-keyword">end</span> = struct_base_ip<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.end_ip;<br>                    <span class="hljs-built_in">int</span><span class="hljs-constructor">_to_addr_str(<span class="hljs-params">start</span>, <span class="hljs-params">end</span>, <span class="hljs-params">struct_base_ip</span>[<span class="hljs-params">i</span>].<span class="hljs-params">code</span>, <span class="hljs-params">struct_mobile_ip</span>[<span class="hljs-params">j</span>].<span class="hljs-params">code</span>)</span>;<br>                    ++i;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">end</span> = struct_base_ip<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.end_ip;<br>                    <span class="hljs-built_in">int</span><span class="hljs-constructor">_to_addr_str(<span class="hljs-params">start</span>, <span class="hljs-params">end</span>, <span class="hljs-params">struct_base_ip</span>[<span class="hljs-params">i</span>].<span class="hljs-params">code</span>, <span class="hljs-params">struct_mobile_ip</span>[<span class="hljs-params">j</span>].<span class="hljs-params">code</span>)</span>;<br>                    ++i;<br>                    ++j;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (!is_mobile_out) &#123;<br>                start = struct_mobile_ip<span class="hljs-literal">[MOBILECOUNT - <span class="hljs-number">1</span>]</span>.end_ip + <span class="hljs-number">1</span>;<br>                is_mobile_out = <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                start = struct_base_ip<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.start_ip;<br>            &#125;<br>            <span class="hljs-keyword">end</span> = struct_base_ip<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.end_ip;<br>            <span class="hljs-built_in">int</span><span class="hljs-constructor">_to_addr_str(<span class="hljs-params">start</span>, <span class="hljs-params">end</span>, <span class="hljs-params">struct_base_ip</span>[<span class="hljs-params">i</span>].<span class="hljs-params">code</span>, <span class="hljs-string">&quot;NONE&quot;</span>)</span>;<br>            ++i;<br>        &#125;<br>    &#125;<br><br>    exit(<span class="hljs-number">0</span>);<br>&#125;<br><br>void resolve<span class="hljs-constructor">_file(FILE <span class="hljs-operator">*</span><span class="hljs-params">fp</span>, <span class="hljs-params">struct</span> <span class="hljs-params">row</span> <span class="hljs-params">all_data</span>[])</span> &#123;<br>    <span class="hljs-built_in">char</span> line<span class="hljs-literal">[MAXLIMIT]</span>, s_start_ip<span class="hljs-literal">[<span class="hljs-number">16</span>]</span>, s_end_ip<span class="hljs-literal">[<span class="hljs-number">16</span>]</span>;<br>    <span class="hljs-built_in">char</span> *lp;<br>    <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> ((lp = fgets(line, MAXLIMIT, fp)) != NULL) &#123;<br>        sscanf(lp, <span class="hljs-string">&quot;%[^,],%[^,],%s&quot;</span>,<br>               s_start_ip,<br>               s_end_ip,<br>               (&amp;all_data<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>)-&gt;code);<br>        (&amp;all_data<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>)-&gt;start_ip = addr<span class="hljs-constructor">_str_to_int(<span class="hljs-params">s_start_ip</span>)</span>;<br>        (&amp;all_data<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>)-&gt;end_ip = addr<span class="hljs-constructor">_str_to_int(<span class="hljs-params">s_end_ip</span>)</span>;<br>        i++;<br>    &#125;<br>    fclose(fp);<br>&#125;<br><br>in_addr_t addr<span class="hljs-constructor">_str_to_int(<span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">cp</span>)</span> &#123;<br>    return ntohl(inet<span class="hljs-constructor">_addr(<span class="hljs-params">cp</span>)</span>);<br>&#125;<br><br>void <span class="hljs-built_in">int</span><span class="hljs-constructor">_to_addr_str(<span class="hljs-params">in_addr_t</span> <span class="hljs-params">start</span>, <span class="hljs-params">in_addr_t</span> <span class="hljs-params">end</span>, <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">base_code</span>, <span class="hljs-params">char</span> <span class="hljs-operator">*</span><span class="hljs-params">mobile_code</span>)</span> &#123;<br>    start = htonl(start);<br>    <span class="hljs-keyword">end</span> = htonl(<span class="hljs-keyword">end</span>);<br>    <span class="hljs-built_in">char</span> start_str<span class="hljs-literal">[<span class="hljs-number">16</span>]</span>, end_str<span class="hljs-literal">[<span class="hljs-number">16</span>]</span>;<br>    unsigned <span class="hljs-built_in">char</span> *start_bytes = (unsigned <span class="hljs-built_in">char</span> *) &amp;start;<br>    unsigned <span class="hljs-built_in">char</span> *end_bytes = (unsigned <span class="hljs-built_in">char</span> *) &amp;<span class="hljs-keyword">end</span>;<br>    snprintf (start_str, sizeof (start_str), <span class="hljs-string">&quot;%d.%d.%d.%d&quot;</span>,<br>              start_bytes<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>, start_bytes<span class="hljs-literal">[<span class="hljs-number">1</span>]</span>, start_bytes<span class="hljs-literal">[<span class="hljs-number">2</span>]</span>, start_bytes<span class="hljs-literal">[<span class="hljs-number">3</span>]</span>);<br>    snprintf (end_str, sizeof (start_str), <span class="hljs-string">&quot;%d.%d.%d.%d&quot;</span>,<br>              end_bytes<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>, end_bytes<span class="hljs-literal">[<span class="hljs-number">1</span>]</span>, end_bytes<span class="hljs-literal">[<span class="hljs-number">2</span>]</span>, end_bytes<span class="hljs-literal">[<span class="hljs-number">3</span>]</span>);<br>    printf(<span class="hljs-string">&quot;%s,%s,%s,%s\n&quot;</span>, start_str, end_str, base_code, mobile_code);<br>&#125;<br></code></pre></td></tr></table></figure><p>至于附加题，就交给看到这儿的你吧：）</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>写完这篇博文以后，终于我也可以幽幽地对别人说：</p><blockquote><p>不管你懂多少闭包、异常处理，只要你不能解释为什么<code>while(*s++ = *t++)</code>，那你就像一个医生看病的依据完全是因为医药销售代表说这种药有用。</p></blockquote><p>完。</p>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>C</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言使用sscanf()解析字符串</title>
    <link href="/2017/08/C%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8sscanf-%E8%A7%A3%E6%9E%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2017/08/C%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8sscanf-%E8%A7%A3%E6%9E%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<p>最近刚看完<a href="https://book.douban.com/subject/1139336/">《The C Programming Language》</a>，果然是一本“小而美”的好书，最好能带着实际的目标去读，而不是走马观花地看个语法，相信每一个例子与习题都会带给你收获和提高。而我带着的目标，就是同事布置给我的“作业”：重构一个基于 C++ 实现的 IP Mapping 程序。</p><p>在查阅<a href="https://book.douban.com/subject/1134988/">《C: A Reference Manual》</a>后，感觉C语言库中可能没有解析CSV格式的原生函数，所以任务的第一步，就是造个解析CSV的轮子。（PHP是世界上最好的语言 :p ）</p><span id="more"></span><p>而之前学习C的时候，在<em>7.4格式化输入</em>章节有这样一段介绍：</p><blockquote><p>另外还有一个输入函数 sscanf，它用于从一个字符串(而不是标准输入)中读取字符序 列:</p></blockquote><blockquote><p>int sscanf(char *string, char *format, arg1, arg2, …)</p></blockquote><blockquote><p>它按照格式参数 format 中规定的格式扫描字符串 string，并把结果分别保存到 arg1、<br>arg2、…这些参数中。这些参数必须是指针。</p></blockquote><p>于是我造了这么个木头轮子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">resolve_line</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *lp)</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> start_ip[<span class="hljs-number">15</span>], end_ip[<span class="hljs-number">15</span>], base_code[<span class="hljs-number">10</span>];<br>    <span class="hljs-built_in">sscanf</span>(lp, <span class="hljs-string">&quot;%s,%s,%s&quot;</span>, start_ip, end_ip, base_code);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, base_code);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>果然不能跑：）</strong></p><p>于是乎继续往后看，后面有这样一段：</p><blockquote><p>假设我们要读取包含下列日期格式的输入行:</p></blockquote><blockquote><p>25 Dec 1988</p></blockquote><blockquote><p>相应的 scanf 语句可以这样编写:</p></blockquote><blockquote><p>int day, year;</p></blockquote><blockquote><p>char monthname[20];</p></blockquote><blockquote><p>scanf(“%d %s %d”, &amp;day, monthname, &amp;year);</p></blockquote><blockquote><p>因为数组名本身就是指针，所以，monthname 的前面没有取地址运算符&amp;。</p></blockquote><p>看完后更觉得没毛病了。去网上看看<a href="http://blog.csdn.net/gzshun/article/details/7081736/">别人咋写的</a>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*****************************************************</span><br><span class="hljs-comment">** Name         : sscanf.c </span><br><span class="hljs-comment">** Author       : gzshun</span><br><span class="hljs-comment">** Version      : 1.0</span><br><span class="hljs-comment">** Date         : 2011-12</span><br><span class="hljs-comment">** Description  : sscanf function</span><br><span class="hljs-comment">******************************************************/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sscanf_test</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sscanf_test</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> ret;<br><span class="hljs-keyword">char</span> *string;<br><span class="hljs-keyword">int</span>  digit;<br><span class="hljs-keyword">char</span> buf1[<span class="hljs-number">255</span>];<br><span class="hljs-keyword">char</span> buf2[<span class="hljs-number">255</span>];<br><span class="hljs-keyword">char</span> buf3[<span class="hljs-number">255</span>];<br><span class="hljs-keyword">char</span> buf4[<span class="hljs-number">255</span>];<br><br><span class="hljs-comment">/*1.最简单的用法*/</span><br>string = <span class="hljs-string">&quot;china beijing 123&quot;</span>;<br>ret = <span class="hljs-built_in">sscanf</span>(string, <span class="hljs-string">&quot;%s %s %d&quot;</span>, buf1, buf2, &amp;digit);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1.string=%s\n&quot;</span>, string);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1.ret=%d, buf1=%s, buf2=%s, digit=%d\n\n&quot;</span>, ret, buf1, buf2, digit);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">**执行结果:</span><br><span class="hljs-comment">**1.ret=3, buf1=china, buf2=beijing, digit=123</span><br><span class="hljs-comment">**可以看出,sscanf的返回值是读取的参数个数</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*2.取指定长度的字符串*/</span><br>string = <span class="hljs-string">&quot;123456789&quot;</span>;<br><span class="hljs-built_in">sscanf</span>(string, <span class="hljs-string">&quot;%5s&quot;</span>, buf1);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2.string=%s\n&quot;</span>, string);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2.buf1=%s\n\n&quot;</span>, buf1);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">**执行结果:</span><br><span class="hljs-comment">**2.buf1=12345</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*3.取到指定字符为止的字符串*/</span><br>string = <span class="hljs-string">&quot;123/456&quot;</span>;<br><span class="hljs-built_in">sscanf</span>(string, <span class="hljs-string">&quot;%[^/]&quot;</span>, buf1);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;3.string=%s\n&quot;</span>, string);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;3.buf1=%s\n\n&quot;</span>, buf1);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">**执行结果:</span><br><span class="hljs-comment">**3.buf1=123</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*4.取到指定字符集为止的字符串*/</span><br>string = <span class="hljs-string">&quot;123abcABC&quot;</span>;<br><span class="hljs-built_in">sscanf</span>(string, <span class="hljs-string">&quot;%[^A-Z]&quot;</span>, buf1);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;4.string=%s\n&quot;</span>, string);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;4.buf1=%s\n\n&quot;</span>, buf1);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">**执行结果:</span><br><span class="hljs-comment">**4.buf1=123abc</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*5.取仅包含指定字符集的字符串*/</span><br>string = <span class="hljs-string">&quot;0123abcABC&quot;</span>;<br><span class="hljs-built_in">sscanf</span>(string, <span class="hljs-string">&quot;%[0-9]%[a-z]%[A-Z]&quot;</span>, buf1, buf2, buf3);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;5.string=%s\n&quot;</span>, string);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;5.buf1=%s, buf2=%s, buf3=%s\n\n&quot;</span>, buf1, buf2, buf3);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">**执行结果:</span><br><span class="hljs-comment">**5.buf1=123, buf2=abc, buf3=ABC</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*6.获取指定字符中间的字符串*/</span><br>string = <span class="hljs-string">&quot;ios&lt;android&gt;wp7&quot;</span>;<br><span class="hljs-built_in">sscanf</span>(string, <span class="hljs-string">&quot;%*[^&lt;]&lt;%[^&gt;]&quot;</span>, buf1);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;6.string=%s\n&quot;</span>, string);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;6.buf1=%s\n\n&quot;</span>, buf1);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">**执行结果:</span><br><span class="hljs-comment">**6.buf1=android</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*7.指定要跳过的字符串*/</span><br>string = <span class="hljs-string">&quot;iosVSandroid&quot;</span>;<br><span class="hljs-built_in">sscanf</span>(string, <span class="hljs-string">&quot;%[a-z]VS%[a-z]&quot;</span>, buf1, buf2);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;7.string=%s\n&quot;</span>, string);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;7.buf1=%s, buf2=%s\n\n&quot;</span>, buf1, buf2);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">**执行结果:</span><br><span class="hljs-comment">**7.buf1=ios, buf2=android</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*8.分割以某字符隔开的字符串*/</span><br>string = <span class="hljs-string">&quot;android-iphone-wp7&quot;</span>;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">**字符串取道&#x27;-&#x27;为止,后面还需要跟着分隔符&#x27;-&#x27;,</span><br><span class="hljs-comment">**起到过滤作用,有点类似于第7点</span><br><span class="hljs-comment">*/</span><br><span class="hljs-built_in">sscanf</span>(string, <span class="hljs-string">&quot;%[^-]-%[^-]-%[^-]&quot;</span>, buf1, buf2, buf3);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;8.string=%s\n&quot;</span>, string);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;8.buf1=%s, buf2=%s, buf3=%s\n\n&quot;</span>, buf1, buf2, buf3);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">**执行结果:</span><br><span class="hljs-comment">**8.buf1=android, buf2=iphone, buf3=wp7</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*9.提取邮箱地址*/</span><br>string = <span class="hljs-string">&quot;Email:beijing@sina.com.cn&quot;</span>;<br><span class="hljs-built_in">sscanf</span>(string, <span class="hljs-string">&quot;%[^:]:%[^@]@%[^.].%s&quot;</span>, buf1, buf2, buf3, buf4);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;9.string=%s\n&quot;</span>, string);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;9.buf1=%s, buf2=%s, buf3=%s, buf4=%s\n\n&quot;</span>, buf1, buf2, buf3, buf4);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">**执行结果:</span><br><span class="hljs-comment">**9.buf1=Email, buf2=beijing, buf3=sina, buf4=com.cn</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*10.过滤掉不想截取或不需要的字符串--补充,</span><br><span class="hljs-comment">**在%号后面加一*号,代表过滤这个字符串,不读取</span><br><span class="hljs-comment">*/</span><br>string = <span class="hljs-string">&quot;android iphone wp7&quot;</span>;<br><span class="hljs-built_in">sscanf</span>(string, <span class="hljs-string">&quot;%s %*s %s&quot;</span>, buf1, buf2);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;10.string=%s\n&quot;</span>, string);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;10.buf1=%s, buf2=%s\n\n&quot;</span>, buf1, buf2);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">**执行结果:</span><br><span class="hljs-comment">**10.android wp7</span><br><span class="hljs-comment">*/</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">sscanf_test</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">**测试程序</span><br><span class="hljs-comment">**环境:</span><br><span class="hljs-comment">**Linux ubuntu 2.6.32-24-generic-pae #39-Ubuntu SMP Wed Jul 28 07:39:26 UTC 2010 i686 GNU/Linux</span><br><span class="hljs-comment">**gcc version 4.4.3 (Ubuntu 4.4.3-4ubuntu5)</span><br><span class="hljs-comment">**</span><br><span class="hljs-comment">gzshun@ubuntu:~/c/sscanf$ gcc sscanf.c -o sscanf</span><br><span class="hljs-comment">gzshun@ubuntu:~/c/sscanf$ ./sscanf</span><br><span class="hljs-comment">1.string=china beijing 123</span><br><span class="hljs-comment">1.ret=3, buf1=china, buf2=beijing, digit=123</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">2.string=123456789</span><br><span class="hljs-comment">2.buf1=12345</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">3.string=123/456</span><br><span class="hljs-comment">3.buf1=123</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">4.string=123abcABC</span><br><span class="hljs-comment">4.buf1=123abc</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">5.string=0123abcABC</span><br><span class="hljs-comment">5.buf1=0123, buf2=abc, buf3=ABC</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">6.string=ios&lt;android&gt;wp7</span><br><span class="hljs-comment">6.buf1=android</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">7.string=iosVSandroid</span><br><span class="hljs-comment">7.buf1=ios, buf2=android</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">8.string=android-iphone-wp7</span><br><span class="hljs-comment">8.buf1=android, buf2=iphone, buf3=wp7</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">9.string=Email:beijing@sina.com.cn</span><br><span class="hljs-comment">9.buf1=Email, buf2=beijing, buf3=sina, buf4=com.cn</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">10.string=android iphone wp7</span><br><span class="hljs-comment">10.buf1=android, buf2=wp7</span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure><p>好像看出了点什么，还是 RTFM 吧：</p><p><a href="https://msdn.microsoft.com/en-us/library/xdb9w69d.aspx#Anchor_2">scanf Width Specification</a></p><blockquote><p><strong>Reading Undelimited strings</strong></p></blockquote><blockquote><p>To read strings not delimited by whitespace characters, a set of characters in brackets ([ ]) can be substituted for the s (string) type character. The set of characters in brackets is referred to as a control string. The corresponding input field is read up to the first character that does not appear in the control string. If the first character in the set is a caret (^), the effect is reversed: The input field is read up to the first character that does appear in the rest of the character set.</p></blockquote><p>然后我把轮子改成了这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">resolve_line</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *lp)</span> </span>&#123;<br>    <span class="hljs-keyword">char</span> start_ip[<span class="hljs-number">15</span>], end_ip[<span class="hljs-number">15</span>], base_code[<span class="hljs-number">10</span>];<br>    <span class="hljs-built_in">sscanf</span>(lp, <span class="hljs-string">&quot;%[^,],%[^,],%s&quot;</span>, start_ip, end_ip, base_code);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, base_code);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>run到飞起：）</strong></p>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在PHP中使用协程实现多任务调度</title>
    <link href="/2017/08/%E5%9C%A8PHP%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/"/>
    <url>/2017/08/%E5%9C%A8PHP%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文是我花了五天时间，一点一点看完的，里面的代码自己也跟着文章一行行写完，调试，精读，压测，项目最终放在了<a href="https://github.com/liubin92/cooperative-multitasking">这里</a>。整个学习过程充斥着疑惑、兴奋和震撼，就连下班路上我都在感叹“php居然还可以这样写”，期间还经历了严重的肠胃炎，所以，这篇伟大的文章对我意义非凡，故此记录。</p></blockquote><p>PHP5.5一个比较好的新功能是加入了对迭代生成器和协程的支持.对于生成器,PHP的文档和各种其他的博客文章已经有了非常详细的讲解.协程相对受到的关注就少了,因为协程虽然有很强大的功能但相对比较复杂, 也比较难被理解,解释起来也比较困难.</p><p>这篇文章将尝试通过介绍如何使用协程来实施任务调度, 来解释在PHP中的协程.</p><p>我将在前三节做一个简单的背景介绍.如果你已经有了比较好的基础,可以直接跳到“协同多任务处理”一节.</p><span id="more"></span><h2 id="迭代生成器"><a href="#迭代生成器" class="headerlink" title="迭代生成器"></a>迭代生成器</h2><p>(迭代)生成器也是一个函数,不同的是这个函数的返回值是依次返回,而不是只返回一个单独的值.或者,换句话说,生成器使你能更方便的实现了迭代器接口.下面通过实现一个xrange函数来简单说明：</p><figure class="highlight php"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">xrange</span>(<span class="hljs-params"><span class="hljs-variable">$start</span>, <span class="hljs-variable">$end</span>, <span class="hljs-variable">$step</span> = <span class="hljs-number">1</span></span>) </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span> = <span class="hljs-variable">$start</span>; <span class="hljs-variable">$i</span> &lt;= <span class="hljs-variable">$end</span>; <span class="hljs-variable">$i</span> += <span class="hljs-variable">$step</span>) &#123;<br>        <span class="hljs-keyword">yield</span> <span class="hljs-variable">$i</span>;<br>    &#125;<br>&#125;<br> <br><span class="hljs-keyword">foreach</span> (xrange(<span class="hljs-number">1</span>, <span class="hljs-number">1000000</span>) <span class="hljs-keyword">as</span> <span class="hljs-variable">$num</span>) &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-variable">$num</span>, <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个xrange()函数提供了和PHP的内建函数range()一样的功能.但是不同的是range()函数返回的是一个包含值从1到100万0的数组(注：请查看手册). 而xrange()函数返回的是依次输出这些值的一个迭代器, 而不会真正以数组形式返回.</p><p>这种方法的优点是显而易见的.它可以让你在处理大数据集合的时候不用一次性的加载到内存中.甚至你可以处理无限大的数据流.</p><p>当然,也可以不同通过生成器来实现这个功能,而是可以通过继承Iterator接口实现.但通过使用生成器实现起来会更方便,不用再去实现iterator接口中的5个方法了.</p><h2 id="生成器为可中断的函数"><a href="#生成器为可中断的函数" class="headerlink" title="生成器为可中断的函数"></a>生成器为可中断的函数</h2><p>要从生成器认识协程, 理解它内部是如何工作是非常重要的: 生成器是一种可中断的函数, 在它里面的yield构成了中断点.</p><p>还是看上面的例子, 调用xrange(1,1000000)的时候, xrange()函数里代码其实并没有真正地运行. 它只是返回了一个迭代器：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$range</span> = xrange(<span class="hljs-number">1</span>, <span class="hljs-number">1000000</span>);<br>var_dump(<span class="hljs-variable">$range</span>); <span class="hljs-comment">// object(Generator)#1</span><br>var_dump(<span class="hljs-variable">$range</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Iterator</span>); <span class="hljs-comment">// bool(true)</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>这也解释了为什么xrange叫做迭代生成器, 因为它返回一个迭代器, 而这个迭代器实现了Iterator接口.</p><p>调用迭代器的方法一次, 其中的代码运行一次.例如, 如果你调用$range-&gt;rewind(), 那么xrange()里的代码就会运行到控制流第一次出现yield的地方. 而函数内传递给yield语句的返回值可以通过$range-&gt;current()获取.</p><p>为了继续执行生成器中yield后的代码, 你就需要调用$range-&gt;next()方法. 这将再次启动生成器, 直到下一次yield语句出现. 因此,连续调用next()和current()方法, 你就能从生成器里获得所有的值, 直到再没有yield语句出现.</p><p>对xrange()来说, 这种情形出现在$i超过$end时. 在这中情况下, 控制流将到达函数的终点,因此将不执行任何代码.一旦这种情况发生,vaild()方法将返回假, 这时迭代结束.</p><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协程的支持是在迭代生成器的基础上, 增加了可以回送数据给生成器的功能(调用者发送数据给被调用的生成器函数). 这就把生成器到调用者的单向通信转变为两者之间的双向通信.</p><p>传递数据的功能是通过迭代器的send()方法实现的. 下面的logger()协程是这种通信如何运行的例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logger</span>(<span class="hljs-params"><span class="hljs-variable">$fileName</span></span>) </span>&#123;<br>    <span class="hljs-variable">$fileHandle</span> = fopen(<span class="hljs-variable">$fileName</span>, <span class="hljs-string">&#x27;a&#x27;</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        fwrite(<span class="hljs-variable">$fileHandle</span>, <span class="hljs-keyword">yield</span> . <span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>&#125;<br> <br><span class="hljs-variable">$logger</span> = logger(<span class="hljs-keyword">__DIR__</span> . <span class="hljs-string">&#x27;/log&#x27;</span>);<br><span class="hljs-variable">$logger</span>-&gt;send(<span class="hljs-string">&#x27;Foo&#x27;</span>);<br><span class="hljs-variable">$logger</span>-&gt;send(<span class="hljs-string">&#x27;Bar&#x27;</span>)<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>正如你能看到,这儿yield没有作为一个语句来使用, 而是用作一个表达式, 即它能被演化成一个值. 这个值就是调用者传递给send()方法的值. 在这个例子里, yield表达式将首先被”Foo”替代写入Log, 然后被”Bar”替代写入Log.</p><p>上面的例子里演示了yield作为接受者, 接下来我们看如何同时进行接收和发送的例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">gen</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-variable">$ret</span> = (<span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;yield1&#x27;</span>);<br>    var_dump(<span class="hljs-variable">$ret</span>);<br>    <span class="hljs-variable">$ret</span> = (<span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;yield2&#x27;</span>);<br>    var_dump(<span class="hljs-variable">$ret</span>);<br>&#125;<br> <br><span class="hljs-variable">$gen</span> = gen();<br>var_dump(<span class="hljs-variable">$gen</span>-&gt;current());    <span class="hljs-comment">// string(6) &quot;yield1&quot;</span><br>var_dump(<span class="hljs-variable">$gen</span>-&gt;send(<span class="hljs-string">&#x27;ret1&#x27;</span>)); <span class="hljs-comment">// string(4) &quot;ret1&quot;   (the first var_dump in gen)</span><br>                              <span class="hljs-comment">// string(6) &quot;yield2&quot; (the var_dump of the -&gt;send() return value)</span><br>var_dump(<span class="hljs-variable">$gen</span>-&gt;send(<span class="hljs-string">&#x27;ret2&#x27;</span>)); <span class="hljs-comment">// string(4) &quot;ret2&quot;   (again from within gen)</span><br>                              <span class="hljs-comment">// NULL               (the return value of -&gt;send())</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>要很快的理解输出的精确顺序可能稍微有点困难, 但你确定要搞清楚为什按照这种方式输出. 以便后续继续阅读.</p><p>另外, 我要特别指出的有两点：</p><p>第一点,yield表达式两边的括号在PHP7以前不是可选的, 也就是说在PHP5.5和PHP5.6中圆括号是必须的.</p><p>第二点,你可能已经注意到调用current()之前没有调用rewind().这是因为生成迭代对象的时候已经隐含地执行了rewind操作.</p><h2 id="多任务协作"><a href="#多任务协作" class="headerlink" title="多任务协作"></a>多任务协作</h2><p>如果阅读了上面的logger()例子, 你也许会疑惑“为了双向通信我为什么要使用协程呢？我完全可以使用其他非协程方法实现同样的功能啊?”, 是的, 你是对的, 但上面的例子只是为了演示了基本用法, 这个例子其实并没有真正的展示出使用协程的优点.</p><p>正如上面介绍里提到的,协程是非常强大的概念,不过却应用的很稀少而且常常十分复杂.要给出一些简单而真实的例子很难.</p><p>在这篇文章里,我决定去做的是使用协程实现多任务协作.我们要解决的问题是你想并发地运行多任务(或者“程序”）.不过我们都知道CPU在一个时刻只能运行一个任务（不考虑多核的情况）.因此处理器需要在不同的任务之间进行切换,而且总是让每个任务运行 “一小会儿”.</p><p>多任务协作这个术语中的“协作”很好的说明了如何进行这种切换的：它要求当前正在运行的任务自动把控制传回给调度器,这样就可以运行其他任务了. 这与“抢占”多任务相反, 抢占多任务是这样的：调度器可以中断运行了一段时间的任务, 不管它喜欢还是不喜欢. 协作多任务在Windows的早期版本(windows95)和Mac OS中有使用, 不过它们后来都切换到使用抢先多任务了. 理由相当明确：如果你依靠程序自动交出控制的话, 那么一些恶意的程序将很容易占用整个CPU, 不与其他任务共享.</p><p>现在你应当明白协程和任务调度之间的关系：yield指令提供了任务中断自身的一种方法, 然后把控制交回给任务调度器. 因此协程可以运行多个其他任务. 更进一步来说, yield还可以用来在任务和调度器之间进行通信.</p><p>为了实现我们的多任务调度, 首先实现“任务” — 一个用轻量级的包装的协程函数:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$taskId</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$coroutine</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$sendValue</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$beforeFirstYield</span> = <span class="hljs-literal">true</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$taskId</span>, <span class="hljs-built_in">Generator</span> <span class="hljs-variable">$coroutine</span></span>) </span>&#123;<br>        <span class="hljs-keyword">$this</span>-&gt;taskId = <span class="hljs-variable">$taskId</span>;<br>        <span class="hljs-keyword">$this</span>-&gt;coroutine = <span class="hljs-variable">$coroutine</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTaskId</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">$this</span>-&gt;taskId;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setSendValue</span>(<span class="hljs-params"><span class="hljs-variable">$sendValue</span></span>) </span>&#123;<br>        <span class="hljs-keyword">$this</span>-&gt;sendValue = <span class="hljs-variable">$sendValue</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">$this</span>-&gt;beforeFirstYield) &#123;<br>            <span class="hljs-keyword">$this</span>-&gt;beforeFirstYield = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">$this</span>-&gt;coroutine-&gt;current();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-variable">$retval</span> = <span class="hljs-keyword">$this</span>-&gt;coroutine-&gt;send(<span class="hljs-keyword">$this</span>-&gt;sendValue);<br>            <span class="hljs-keyword">$this</span>-&gt;sendValue = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable">$retval</span>;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFinished</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> !<span class="hljs-keyword">$this</span>-&gt;coroutine-&gt;valid();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如代码, 一个任务就是用任务ID标记的一个协程(函数). 使用setSendValue()方法, 你可以指定哪些值将被发送到下次的恢复(在之后你会了解到我们需要这个), run()函数确实没有做什么, 除了调用send()方法的协同程序, 要理解为什么添加了一个 beforeFirstYieldflag变量, 需要考虑下面的代码片段：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">gen</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;foo&#x27;</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;bar&#x27;</span>;<br>&#125;<br> <br><span class="hljs-variable">$gen</span> = gen();<br>var_dump(<span class="hljs-variable">$gen</span>-&gt;send(<span class="hljs-string">&#x27;something&#x27;</span>));<br> <br><span class="hljs-comment">// 如之前提到的在send之前, 当$gen迭代器被创建的时候一个renwind()方法已经被隐式调用</span><br><span class="hljs-comment">// 所以实际上发生的应该类似:</span><br><span class="hljs-comment">//$gen-&gt;rewind();</span><br><span class="hljs-comment">//var_dump($gen-&gt;send(&#x27;something&#x27;));</span><br> <br><span class="hljs-comment">//这样renwind的执行将会导致第一个yield被执行, 并且忽略了他的返回值.</span><br><span class="hljs-comment">//真正当我们调用yield的时候, 我们得到的是第二个yield的值! 导致第一个yield的值被忽略.</span><br><span class="hljs-comment">//string(3) &quot;bar&quot;</span><br></code></pre></td></tr></table></figure><p>通过添加 beforeFirstYieldcondition 我们可以确定第一个yield的值能被正确返回.</p><p>调度器现在不得不比多任务循环要做稍微多点了, 然后才运行多任务：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Scheduler</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$maxTaskId</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$taskMap</span> = []; <span class="hljs-comment">// taskId =&gt; task</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$taskQueue</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">$this</span>-&gt;taskQueue = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SplQueue</span>();<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">newTask</span>(<span class="hljs-params"><span class="hljs-built_in">Generator</span> <span class="hljs-variable">$coroutine</span></span>) </span>&#123;<br>        <span class="hljs-variable">$tid</span> = ++<span class="hljs-keyword">$this</span>-&gt;maxTaskId;<br>        <span class="hljs-variable">$task</span> = <span class="hljs-keyword">new</span> Task(<span class="hljs-variable">$tid</span>, <span class="hljs-variable">$coroutine</span>);<br>        <span class="hljs-keyword">$this</span>-&gt;taskMap[<span class="hljs-variable">$tid</span>] = <span class="hljs-variable">$task</span>;<br>        <span class="hljs-keyword">$this</span>-&gt;schedule(<span class="hljs-variable">$task</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">$tid</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">schedule</span>(<span class="hljs-params">Task <span class="hljs-variable">$task</span></span>) </span>&#123;<br>        <span class="hljs-keyword">$this</span>-&gt;taskQueue-&gt;enqueue(<span class="hljs-variable">$task</span>);<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">while</span> (!<span class="hljs-keyword">$this</span>-&gt;taskQueue-&gt;isEmpty()) &#123;<br>            <span class="hljs-variable">$task</span> = <span class="hljs-keyword">$this</span>-&gt;taskQueue-&gt;dequeue();<br>            <span class="hljs-variable">$task</span>-&gt;run();<br> <br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable">$task</span>-&gt;isFinished()) &#123;<br>                <span class="hljs-keyword">unset</span>(<span class="hljs-keyword">$this</span>-&gt;taskMap[<span class="hljs-variable">$task</span>-&gt;getTaskId()]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">$this</span>-&gt;schedule(<span class="hljs-variable">$task</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>newTask()方法（使用下一个空闲的任务id）创建一个新任务,然后把这个任务放入任务map数组里. 接着它通过把任务放入任务队列里来实现对任务的调度. 接着run()方法扫描任务队列, 运行任务.如果一个任务结束了, 那么它将从队列里删除, 否则它将在队列的末尾再次被调度.</p><p>让我们看看下面具有两个简单（没有什么意义）任务的调度器：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">task1</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span> = <span class="hljs-number">1</span>; <span class="hljs-variable">$i</span> &lt;= <span class="hljs-number">10</span>; ++<span class="hljs-variable">$i</span>) &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;This is task 1 iteration <span class="hljs-subst">$i</span>.\n&quot;</span>;<br>        <span class="hljs-keyword">yield</span>;<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">task2</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span> = <span class="hljs-number">1</span>; <span class="hljs-variable">$i</span> &lt;= <span class="hljs-number">5</span>; ++<span class="hljs-variable">$i</span>) &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;This is task 2 iteration <span class="hljs-subst">$i</span>.\n&quot;</span>;<br>        <span class="hljs-keyword">yield</span>;<br>    &#125;<br>&#125;<br> <br><span class="hljs-variable">$scheduler</span> = <span class="hljs-keyword">new</span> Scheduler;<br> <br><span class="hljs-variable">$scheduler</span>-&gt;newTask(task1());<br><span class="hljs-variable">$scheduler</span>-&gt;newTask(task2());<br> <br><span class="hljs-variable">$scheduler</span>-&gt;run();<br></code></pre></td></tr></table></figure><p>两个任务都仅仅回显一条信息,然后使用yield把控制回传给调度器.输出结果如下：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ada">This <span class="hljs-keyword">is</span> <span class="hljs-keyword">task</span> <span class="hljs-number">1</span> iteration <span class="hljs-number">1</span>.<br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">task</span> <span class="hljs-number">2</span> iteration <span class="hljs-number">1</span>.<br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">task</span> <span class="hljs-number">1</span> iteration <span class="hljs-number">2</span>.<br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">task</span> <span class="hljs-number">2</span> iteration <span class="hljs-number">2</span>.<br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">task</span> <span class="hljs-number">1</span> iteration <span class="hljs-number">3</span>.<br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">task</span> <span class="hljs-number">2</span> iteration <span class="hljs-number">3</span>.<br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">task</span> <span class="hljs-number">1</span> iteration <span class="hljs-number">4</span>.<br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">task</span> <span class="hljs-number">2</span> iteration <span class="hljs-number">4</span>.<br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">task</span> <span class="hljs-number">1</span> iteration <span class="hljs-number">5</span>.<br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">task</span> <span class="hljs-number">2</span> iteration <span class="hljs-number">5</span>.<br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">task</span> <span class="hljs-number">1</span> iteration <span class="hljs-number">6</span>.<br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">task</span> <span class="hljs-number">1</span> iteration <span class="hljs-number">7</span>.<br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">task</span> <span class="hljs-number">1</span> iteration <span class="hljs-number">8</span>.<br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">task</span> <span class="hljs-number">1</span> iteration <span class="hljs-number">9</span>.<br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">task</span> <span class="hljs-number">1</span> iteration <span class="hljs-number">10</span>.<br></code></pre></td></tr></table></figure><p>输出确实如我们所期望的：对前五个迭代来说,两个任务是交替运行的, 而在第二个任务结束后, 只有第一个任务继续运行.</p><h2 id="与调度器之间通信"><a href="#与调度器之间通信" class="headerlink" title="与调度器之间通信"></a>与调度器之间通信</h2><p>既然调度器已经运行了, 那么我们来看下一个问题：任务和调度器之间的通信.</p><p>我们将使用进程用来和操作系统会话的同样的方式来通信：系统调用.</p><p>我们需要系统调用的理由是操作系统与进程相比它处在不同的权限级别上. 因此为了执行特权级别的操作（如杀死另一个进程), 就不得不以某种方式把控制传回给内核, 这样内核就可以执行所说的操作了. 再说一遍, 这种行为在内部是通过使用中断指令来实现的. 过去使用的是通用的int指令, 如今使用的是更特殊并且更快速的syscall/sysenter指令.</p><p>我们的任务调度系统将反映这种设计：不是简单地把调度器传递给任务（这样就允许它做它想做的任何事), 我们将通过给yield表达式传递信息来与系统调用通信. 这儿yield即是中断, 也是传递信息给调度器（和从调度器传递出信息）的方法.</p><p>为了说明系统调用, 我们对可调用的系统调用做一个小小的封装：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SystemCall</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$callback</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-keyword">callable</span> <span class="hljs-variable">$callback</span></span>) </span>&#123;<br>        <span class="hljs-keyword">$this</span>-&gt;callback = <span class="hljs-variable">$callback</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__invoke</span>(<span class="hljs-params">Task <span class="hljs-variable">$task</span>, Scheduler <span class="hljs-variable">$scheduler</span></span>) </span>&#123;<br>        <span class="hljs-variable">$callback</span> = <span class="hljs-keyword">$this</span>-&gt;callback;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">$callback</span>(<span class="hljs-variable">$task</span>, <span class="hljs-variable">$scheduler</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>它和其他任何可调用的对象(使用_invoke)一样的运行, 不过它要求调度器把正在调用的任务和自身传递给这个函数.</p><p>为了解决这个问题我们不得不微微的修改调度器的run方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-keyword">$this</span>-&gt;taskQueue-&gt;isEmpty()) &#123;<br>        <span class="hljs-variable">$task</span> = <span class="hljs-keyword">$this</span>-&gt;taskQueue-&gt;dequeue();<br>        <span class="hljs-variable">$retval</span> = <span class="hljs-variable">$task</span>-&gt;run();<br> <br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">$retval</span> <span class="hljs-keyword">instanceof</span> SystemCall) &#123;<br>            <span class="hljs-variable">$retval</span>(<span class="hljs-variable">$task</span>, <span class="hljs-keyword">$this</span>);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br> <br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">$task</span>-&gt;isFinished()) &#123;<br>            <span class="hljs-keyword">unset</span>(<span class="hljs-keyword">$this</span>-&gt;taskMap[<span class="hljs-variable">$task</span>-&gt;getTaskId()]);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">$this</span>-&gt;schedule(<span class="hljs-variable">$task</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一个系统调用除了返回任务ID外什么都没有做：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTaskId</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SystemCall(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Task <span class="hljs-variable">$task</span>, Scheduler <span class="hljs-variable">$scheduler</span></span>) </span>&#123;<br>        <span class="hljs-variable">$task</span>-&gt;setSendValue(<span class="hljs-variable">$task</span>-&gt;getTaskId());<br>        <span class="hljs-variable">$scheduler</span>-&gt;schedule(<span class="hljs-variable">$task</span>);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数设置任务id为下一次发送的值, 并再次调度了这个任务 .由于使用了系统调用, 所以调度器不能自动调用任务, 我们需要手工调度任务（稍后你将明白为什么这么做). 要使用这个新的系统调用的话, 我们要重新编写以前的例子：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">task</span>(<span class="hljs-params"><span class="hljs-variable">$max</span></span>) </span>&#123;<br>    <span class="hljs-variable">$tid</span> = (<span class="hljs-keyword">yield</span> getTaskId()); <span class="hljs-comment">// &lt;-- here&#x27;s the syscall!</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span> = <span class="hljs-number">1</span>; <span class="hljs-variable">$i</span> &lt;= <span class="hljs-variable">$max</span>; ++<span class="hljs-variable">$i</span>) &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;This is task <span class="hljs-subst">$tid</span> iteration <span class="hljs-subst">$i</span>.\n&quot;</span>;<br>        <span class="hljs-keyword">yield</span>;<br>    &#125;<br>&#125;<br> <br><span class="hljs-variable">$scheduler</span> = <span class="hljs-keyword">new</span> Scheduler;<br> <br><span class="hljs-variable">$scheduler</span>-&gt;newTask(task(<span class="hljs-number">10</span>));<br><span class="hljs-variable">$scheduler</span>-&gt;newTask(task(<span class="hljs-number">5</span>));<br> <br><span class="hljs-variable">$scheduler</span>-&gt;run();<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>这段代码将给出与前一个例子相同的输出. 请注意系统调用如何同其他任何调用一样正常地运行, 只不过预先增加了yield.</p><p>要创建新的任务, 然后再杀死它们的话, 需要两个以上的系统调用：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">newTask</span>(<span class="hljs-params"><span class="hljs-built_in">Generator</span> <span class="hljs-variable">$coroutine</span></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SystemCall(<br>        <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Task <span class="hljs-variable">$task</span>, Scheduler <span class="hljs-variable">$scheduler</span></span>) <span class="hljs-keyword">use</span> (<span class="hljs-params"><span class="hljs-variable">$coroutine</span></span>) </span>&#123;<br>            <span class="hljs-variable">$task</span>-&gt;setSendValue(<span class="hljs-variable">$scheduler</span>-&gt;newTask(<span class="hljs-variable">$coroutine</span>));<br>            <span class="hljs-variable">$scheduler</span>-&gt;schedule(<span class="hljs-variable">$task</span>);<br>        &#125;<br>    );<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">killTask</span>(<span class="hljs-params"><span class="hljs-variable">$tid</span></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SystemCall(<br>        <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Task <span class="hljs-variable">$task</span>, Scheduler <span class="hljs-variable">$scheduler</span></span>) <span class="hljs-keyword">use</span> (<span class="hljs-params"><span class="hljs-variable">$tid</span></span>) </span>&#123;<br>            <span class="hljs-variable">$task</span>-&gt;setSendValue(<span class="hljs-variable">$scheduler</span>-&gt;killTask(<span class="hljs-variable">$tid</span>));<br>            <span class="hljs-variable">$scheduler</span>-&gt;schedule(<span class="hljs-variable">$task</span>);<br>        &#125;<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>killTask函数需要在调度器里增加一个方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">killTask</span>(<span class="hljs-params"><span class="hljs-variable">$tid</span></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">isset</span>(<span class="hljs-keyword">$this</span>-&gt;taskMap[<span class="hljs-variable">$tid</span>])) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">unset</span>(<span class="hljs-keyword">$this</span>-&gt;taskMap[<span class="hljs-variable">$tid</span>]);<br> <br>    <span class="hljs-comment">// This is a bit ugly and could be optimized so it does not have to walk the queue,</span><br>    <span class="hljs-comment">// but assuming that killing tasks is rather rare I won&#x27;t bother with it now</span><br>    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">$this</span>-&gt;taskQueue <span class="hljs-keyword">as</span> <span class="hljs-variable">$i</span> =&gt; <span class="hljs-variable">$task</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">$task</span>-&gt;getTaskId() === <span class="hljs-variable">$tid</span>) &#123;<br>            <span class="hljs-keyword">unset</span>(<span class="hljs-keyword">$this</span>-&gt;taskQueue[<span class="hljs-variable">$i</span>]);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>用来测试新功能的微脚本：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">childTask</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-variable">$tid</span> = (<span class="hljs-keyword">yield</span> getTaskId());<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Child task <span class="hljs-subst">$tid</span> still alive!\n&quot;</span>;<br>        <span class="hljs-keyword">yield</span>;<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">task</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-variable">$tid</span> = (<span class="hljs-keyword">yield</span> getTaskId());<br>    <span class="hljs-variable">$childTid</span> = (<span class="hljs-keyword">yield</span> newTask(childTask()));<br> <br>    <span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span> = <span class="hljs-number">1</span>; <span class="hljs-variable">$i</span> &lt;= <span class="hljs-number">6</span>; ++<span class="hljs-variable">$i</span>) &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Parent task <span class="hljs-subst">$tid</span> iteration <span class="hljs-subst">$i</span>.\n&quot;</span>;<br>        <span class="hljs-keyword">yield</span>;<br> <br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">$i</span> == <span class="hljs-number">3</span>) <span class="hljs-keyword">yield</span> killTask(<span class="hljs-variable">$childTid</span>);<br>    &#125;<br>&#125;<br> <br><span class="hljs-variable">$scheduler</span> = <span class="hljs-keyword">new</span> Scheduler;<br><span class="hljs-variable">$scheduler</span>-&gt;newTask(task());<br><span class="hljs-variable">$scheduler</span>-&gt;run();<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>这段代码将打印以下信息：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Parent</span> task <span class="hljs-number">1</span> iteration <span class="hljs-number">1</span>.<br><span class="hljs-attribute">Child</span> task <span class="hljs-number">2</span> still alive!<br><span class="hljs-attribute">Parent</span> task <span class="hljs-number">1</span> iteration <span class="hljs-number">2</span>.<br><span class="hljs-attribute">Child</span> task <span class="hljs-number">2</span> still alive!<br><span class="hljs-attribute">Parent</span> task <span class="hljs-number">1</span> iteration <span class="hljs-number">3</span>.<br><span class="hljs-attribute">Child</span> task <span class="hljs-number">2</span> still alive!<br><span class="hljs-attribute">Parent</span> task <span class="hljs-number">1</span> iteration <span class="hljs-number">4</span>.<br><span class="hljs-attribute">Parent</span> task <span class="hljs-number">1</span> iteration <span class="hljs-number">5</span>.<br><span class="hljs-attribute">Parent</span> task <span class="hljs-number">1</span> iteration <span class="hljs-number">6</span>.<br></code></pre></td></tr></table></figure><p>经过三次迭代以后子任务将被杀死, 因此这就是”Child is still alive”消息结束的时候. 不过你要明白这还不是真正的父子关系. 因为在父任务结束后子任务仍然可以运行, 子任务甚至可以杀死父任务. 可以修改调度器使它具有更层级化的任务结构, 不过这个不是我们这个文章要继续讨论的范围了.</p><p>现在你可以实现许多进程管理调用. 例如 wait（它一直等待到任务结束运行时), exec（它替代当前任务)和fork（它创建一个当前任务的克隆). fork非常酷,而 且你可以使用PHP的协程真正地实现它, 因为它们都支持克隆.</p><p>让我们把这些留给有兴趣的读者吧,我们来看下一个议题.</p><h2 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h2><p>很明显, 我们的任务管理系统的真正很酷的应用应该是web服务器. 它有一个任务是在套接字上侦听是否有新连接, 当有新连接要建立的时候, 它创建一个新任务来处理新连接.</p><p>Web服务器最难的部分通常是像读数据这样的套接字操作是阻塞的. 例如PHP将等待到客户端完成发送为止. 对一个Web服务器来说, 这有点不太高效. 因为服务器在一个时间点上只能处理一个连接.</p><p>解决方案是确保在真正对套接字读写之前该套接字已经“准备就绪”. 为了查找哪个套接字已经准备好读或者写了, 可以使用 流选择函数.</p><p>首先,让我们添加两个新的 syscall, 它们将等待直到指定socket 准备好：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">waitForRead</span>(<span class="hljs-params"><span class="hljs-variable">$socket</span></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SystemCall(<br>        <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Task <span class="hljs-variable">$task</span>, Scheduler <span class="hljs-variable">$scheduler</span></span>) <span class="hljs-keyword">use</span> (<span class="hljs-params"><span class="hljs-variable">$socket</span></span>) </span>&#123;<br>            <span class="hljs-variable">$scheduler</span>-&gt;waitForRead(<span class="hljs-variable">$socket</span>, <span class="hljs-variable">$task</span>);<br>        &#125;<br>    );<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">waitForWrite</span>(<span class="hljs-params"><span class="hljs-variable">$socket</span></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SystemCall(<br>        <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Task <span class="hljs-variable">$task</span>, Scheduler <span class="hljs-variable">$scheduler</span></span>) <span class="hljs-keyword">use</span> (<span class="hljs-params"><span class="hljs-variable">$socket</span></span>) </span>&#123;<br>            <span class="hljs-variable">$scheduler</span>-&gt;waitForWrite(<span class="hljs-variable">$socket</span>, <span class="hljs-variable">$task</span>);<br>        &#125;<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>这些 syscall 只是在调度器中代理其各自的方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br> <br><span class="hljs-comment">// resourceID =&gt; [socket, tasks]</span><br><span class="hljs-keyword">protected</span> <span class="hljs-variable">$waitingForRead</span> = [];<br><span class="hljs-keyword">protected</span> <span class="hljs-variable">$waitingForWrite</span> = [];<br> <br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">waitForRead</span>(<span class="hljs-params"><span class="hljs-variable">$socket</span>, Task <span class="hljs-variable">$task</span></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-keyword">$this</span>-&gt;waitingForRead[(<span class="hljs-keyword">int</span>) <span class="hljs-variable">$socket</span>])) &#123;<br>        <span class="hljs-keyword">$this</span>-&gt;waitingForRead[(<span class="hljs-keyword">int</span>) <span class="hljs-variable">$socket</span>][<span class="hljs-number">1</span>][] = <span class="hljs-variable">$task</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">$this</span>-&gt;waitingForRead[(<span class="hljs-keyword">int</span>) <span class="hljs-variable">$socket</span>] = [<span class="hljs-variable">$socket</span>, [<span class="hljs-variable">$task</span>]];<br>    &#125;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">waitForWrite</span>(<span class="hljs-params"><span class="hljs-variable">$socket</span>, Task <span class="hljs-variable">$task</span></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-keyword">$this</span>-&gt;waitingForWrite[(<span class="hljs-keyword">int</span>) <span class="hljs-variable">$socket</span>])) &#123;<br>        <span class="hljs-keyword">$this</span>-&gt;waitingForWrite[(<span class="hljs-keyword">int</span>) <span class="hljs-variable">$socket</span>][<span class="hljs-number">1</span>][] = <span class="hljs-variable">$task</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">$this</span>-&gt;waitingForWrite[(<span class="hljs-keyword">int</span>) <span class="hljs-variable">$socket</span>] = [<span class="hljs-variable">$socket</span>, [<span class="hljs-variable">$task</span>]];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>waitingForRead 及 waitingForWrite 属性是两个承载等待的socket 及等待它们的任务的数组. 有趣的部分在于下面的方法,它将检查 socket 是否可用, 并重新安排各自任务：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br> <br><span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ioPoll</span>(<span class="hljs-params"><span class="hljs-variable">$timeout</span></span>) </span>&#123;<br>    <span class="hljs-variable">$rSocks</span> = [];<br>    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">$this</span>-&gt;waitingForRead <span class="hljs-keyword">as</span> <span class="hljs-keyword">list</span>(<span class="hljs-variable">$socket</span>)) &#123;<br>        <span class="hljs-variable">$rSocks</span>[] = <span class="hljs-variable">$socket</span>;<br>    &#125;<br> <br>    <span class="hljs-variable">$wSocks</span> = [];<br>    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">$this</span>-&gt;waitingForWrite <span class="hljs-keyword">as</span> <span class="hljs-keyword">list</span>(<span class="hljs-variable">$socket</span>)) &#123;<br>        <span class="hljs-variable">$wSocks</span>[] = <span class="hljs-variable">$socket</span>;<br>    &#125;<br> <br>    <span class="hljs-variable">$eSocks</span> = []; <span class="hljs-comment">// dummy</span><br> <br>    <span class="hljs-keyword">if</span> (!stream_select(<span class="hljs-variable">$rSocks</span>, <span class="hljs-variable">$wSocks</span>, <span class="hljs-variable">$eSocks</span>, <span class="hljs-variable">$timeout</span>)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$rSocks</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$socket</span>) &#123;<br>        <span class="hljs-keyword">list</span>(, <span class="hljs-variable">$tasks</span>) = <span class="hljs-keyword">$this</span>-&gt;waitingForRead[(<span class="hljs-keyword">int</span>) <span class="hljs-variable">$socket</span>];<br>        <span class="hljs-keyword">unset</span>(<span class="hljs-keyword">$this</span>-&gt;waitingForRead[(<span class="hljs-keyword">int</span>) <span class="hljs-variable">$socket</span>]);<br> <br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$tasks</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$task</span>) &#123;<br>            <span class="hljs-keyword">$this</span>-&gt;schedule(<span class="hljs-variable">$task</span>);<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$wSocks</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$socket</span>) &#123;<br>        <span class="hljs-keyword">list</span>(, <span class="hljs-variable">$tasks</span>) = <span class="hljs-keyword">$this</span>-&gt;waitingForWrite[(<span class="hljs-keyword">int</span>) <span class="hljs-variable">$socket</span>];<br>        <span class="hljs-keyword">unset</span>(<span class="hljs-keyword">$this</span>-&gt;waitingForWrite[(<span class="hljs-keyword">int</span>) <span class="hljs-variable">$socket</span>]);<br> <br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$tasks</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$task</span>) &#123;<br>            <span class="hljs-keyword">$this</span>-&gt;schedule(<span class="hljs-variable">$task</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>stream_select 函数接受承载读取、写入以及待检查的socket的数组（我们无需考虑最后一类). 数组将按引用传递, 函数只会保留那些状态改变了的数组元素. 我们可以遍历这些数组, 并重新安排与之相关的任务.</p><p>为了正常地执行上面的轮询动作, 我们将在调度器里增加一个特殊的任务：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ioPollTask</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">$this</span>-&gt;taskQueue-&gt;isEmpty()) &#123;<br>            <span class="hljs-keyword">$this</span>-&gt;ioPoll(<span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">$this</span>-&gt;ioPoll(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">yield</span>;<br>    &#125;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>需要在某个地方注册这个任务, 例如, 你可以在run()方法的开始增加$this-&gt;newTask($this-&gt;ioPollTask()). 然后就像其他任务一样每执行完整任务循环一次就执行轮询操作一次（这么做一定不是最好的方法), ioPollTask将使用0秒的超时来调用ioPoll, 也就是stream_select将立即返回（而不是等待）.</p><p>只有任务队列为空时,我们才使用null超时,这意味着它一直等到某个套接口准备就绪.如果我们没有这么做,那么轮询任务将一而再, 再而三的循环运行, 直到有新的连接建立. 这将导致100%的CPU利用率. 相反, 让操作系统做这种等待会更有效.</p><p>现在编写服务器就相对容易了：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br> <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">server</span>(<span class="hljs-params"><span class="hljs-variable">$port</span></span>) </span>&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Starting server at port <span class="hljs-subst">$port</span>...\n&quot;</span>;<br> <br>    <span class="hljs-variable">$socket</span> = @stream_socket_server(<span class="hljs-string">&quot;tcp://localhost:<span class="hljs-subst">$port</span>&quot;</span>, <span class="hljs-variable">$errNo</span>, <span class="hljs-variable">$errStr</span>);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable">$socket</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Exception</span>(<span class="hljs-variable">$errStr</span>, <span class="hljs-variable">$errNo</span>);<br> <br>    stream_set_blocking(<span class="hljs-variable">$socket</span>, <span class="hljs-number">0</span>);<br> <br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">yield</span> waitForRead(<span class="hljs-variable">$socket</span>);<br>        <span class="hljs-variable">$clientSocket</span> = stream_socket_accept(<span class="hljs-variable">$socket</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">yield</span> newTask(handleClient(<span class="hljs-variable">$clientSocket</span>));<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleClient</span>(<span class="hljs-params"><span class="hljs-variable">$socket</span></span>) </span>&#123;<br>    <span class="hljs-keyword">yield</span> waitForRead(<span class="hljs-variable">$socket</span>);<br>    <span class="hljs-variable">$data</span> = fread(<span class="hljs-variable">$socket</span>, <span class="hljs-number">8192</span>);<br> <br>    <span class="hljs-variable">$msg</span> = <span class="hljs-string">&quot;Received following request:\n\n<span class="hljs-subst">$data</span>&quot;</span>;<br>    <span class="hljs-variable">$msgLength</span> = strlen(<span class="hljs-variable">$msg</span>);<br> <br>    <span class="hljs-variable">$response</span> = <span class="hljs-string">&lt;&lt;&lt;RES</span><br><span class="hljs-string">HTTP/1.1 200 OK\r</span><br><span class="hljs-string">Content-Type: text/plain\r</span><br><span class="hljs-string">Content-Length: <span class="hljs-subst">$msgLength</span>\r</span><br><span class="hljs-string">Connection: close\r</span><br><span class="hljs-string">\r</span><br><span class="hljs-string"><span class="hljs-subst">$msg</span></span><br><span class="hljs-string">RES</span>;<br> <br>    <span class="hljs-keyword">yield</span> waitForWrite(<span class="hljs-variable">$socket</span>);<br>    fwrite(<span class="hljs-variable">$socket</span>, <span class="hljs-variable">$response</span>);<br> <br>    fclose(<span class="hljs-variable">$socket</span>);<br>&#125;<br> <br><span class="hljs-variable">$scheduler</span> = <span class="hljs-keyword">new</span> Scheduler;<br><span class="hljs-variable">$scheduler</span>-&gt;newTask(server(<span class="hljs-number">8000</span>));<br><span class="hljs-variable">$scheduler</span>-&gt;run();<br></code></pre></td></tr></table></figure><p>这段代码实现了接收localhost:8000上的连接, 然后返回发送来的内容作为HTTP响应. 当然它还能处理真正的复杂HTTP请求, 上面的代码片段只是演示了一般性的概念.</p><p>你可以使用类似于ab -n 10000 -c 100 localhost:8000/这样命令来测试服务器. 这条命令将向服务器发送10000个请求, 并且其中100个请求将同时到达. 使用这样的数目, 我得到了处于中间的10毫秒的响应时间. 不过还有一个问题：有少数几个请求真正处理的很慢（如5秒), 这就是为什么总吞吐量只有2000请求/秒（如果是10毫秒的响应时间的话, 总的吞吐量应该更像是10000请求/秒)</p><h2 id="协程堆栈"><a href="#协程堆栈" class="headerlink" title="协程堆栈"></a>协程堆栈</h2><p>如果你试图用我们的调度系统建立更大的系统的话, 你将很快遇到问题：我们习惯了把代码分解为更小的函数, 然后调用它们. 然而, 如果使用了协程的话, 就不能这么做了. 例如,看下面代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">echoTimes</span>(<span class="hljs-params"><span class="hljs-variable">$msg</span>, <span class="hljs-variable">$max</span></span>) </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span> = <span class="hljs-number">1</span>; <span class="hljs-variable">$i</span> &lt;= <span class="hljs-variable">$max</span>; ++<span class="hljs-variable">$i</span>) &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;<span class="hljs-subst">$msg</span> iteration <span class="hljs-subst">$i</span>\n&quot;</span>;<br>        <span class="hljs-keyword">yield</span>;<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">task</span>(<span class="hljs-params"></span>) </span>&#123;<br>    echoTimes(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-number">10</span>); <span class="hljs-comment">// print foo ten times</span><br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;---\n&quot;</span>;<br>    echoTimes(<span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// print bar five times</span><br>    <span class="hljs-keyword">yield</span>; <span class="hljs-comment">// force it to be a coroutine</span><br>&#125;<br> <br><span class="hljs-variable">$scheduler</span> = <span class="hljs-keyword">new</span> Scheduler;<br><span class="hljs-variable">$scheduler</span>-&gt;newTask(task());<br><span class="hljs-variable">$scheduler</span>-&gt;run();<br></code></pre></td></tr></table></figure><p>这段代码试图把重复循环“输出n次“的代码嵌入到一个独立的协程里,然后从主任务里调用它. 然而它无法运行. 正如在这篇文章的开始所提到的, 调用生成器（或者协程）将没有真正地做任何事情, 它仅仅返回一个对象.这 也出现在上面的例子里:echoTimes调用除了放回一个（无用的）协程对象外不做任何事情.</p><p>为了仍然允许这么做,我们需要在这个裸协程上写一个小小的封装.我们将调用它：“协程堆栈”. 因为它将管理嵌套的协程调用堆栈. 这将是通过生成协程来调用子协程成为可能：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$retval</span> = (<span class="hljs-keyword">yield</span> someCoroutine(<span class="hljs-variable">$foo</span>, <span class="hljs-variable">$bar</span>));<br></code></pre></td></tr></table></figure><p>使用yield,子协程也能再次返回值：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function">yield <span class="hljs-title">retval</span><span class="hljs-params">(<span class="hljs-string">&quot;I&#x27;m a return value!&quot;</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>retval函数除了返回一个值的封装外没有做任何其他事情.这个封装将表示它是一个返回值.</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoroutineReturnValue</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$value</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$value</span></span>) </span>&#123;<br>        <span class="hljs-keyword">$this</span>-&gt;value = <span class="hljs-variable">$value</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getValue</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">$this</span>-&gt;value;<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">retval</span>(<span class="hljs-params"><span class="hljs-variable">$value</span></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CoroutineReturnValue(<span class="hljs-variable">$value</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>为了把协程转变为协程堆栈（它支持子调用）,我们将不得不编写另外一个函数（很明显,它是另一个协程）：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br> <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stackedCoroutine</span>(<span class="hljs-params"><span class="hljs-built_in">Generator</span> <span class="hljs-variable">$gen</span></span>) </span>&#123;<br>    <span class="hljs-variable">$stack</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SplStack</span>;<br> <br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-variable">$value</span> = <span class="hljs-variable">$gen</span>-&gt;current();<br> <br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">$value</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Generator</span>) &#123;<br>            <span class="hljs-variable">$stack</span>-&gt;push(<span class="hljs-variable">$gen</span>);<br>            <span class="hljs-variable">$gen</span> = <span class="hljs-variable">$value</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br> <br>        <span class="hljs-variable">$isReturnValue</span> = <span class="hljs-variable">$value</span> <span class="hljs-keyword">instanceof</span> CoroutineReturnValue;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-variable">$gen</span>-&gt;valid() || <span class="hljs-variable">$isReturnValue</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable">$stack</span>-&gt;isEmpty()) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br> <br>            <span class="hljs-variable">$gen</span> = <span class="hljs-variable">$stack</span>-&gt;pop();<br>            <span class="hljs-variable">$gen</span>-&gt;send(<span class="hljs-variable">$isReturnValue</span> ? <span class="hljs-variable">$value</span>-&gt;getValue() : <span class="hljs-literal">NULL</span>);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br> <br>        <span class="hljs-variable">$gen</span>-&gt;send(<span class="hljs-keyword">yield</span> <span class="hljs-variable">$gen</span>-&gt;key() =&gt; <span class="hljs-variable">$value</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数在调用者和当前正在运行的子协程之间扮演着简单代理的角色.在$gen-&gt;send(yield $gen-&gt;key()=&gt;$value)；这行完成了代理功能.另外它检查返回值是否是生成器,万一是生成器的话,它将开始运行这个生成器,并把前一个协程压入堆栈里.一旦它获得了CoroutineReturnValue的话,它将再次请求堆栈弹出,然后继续执行前一个协程.</p><p>为了使协程堆栈在任务里可用,任务构造器里的$this-coroutine =$coroutine;这行需要替代为$this-&gt;coroutine = StackedCoroutine($coroutine);.</p><p>现在我们可以稍微改进上面web服务器例子：把wait+read(和wait+write和warit+accept)这样的动作分组为函数.为了分组相关的 功能,我将使用下面类：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoSocket</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$socket</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$socket</span></span>) </span>&#123;<br>        <span class="hljs-keyword">$this</span>-&gt;socket = <span class="hljs-variable">$socket</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">accept</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">yield</span> waitForRead(<span class="hljs-keyword">$this</span>-&gt;socket);<br>        <span class="hljs-keyword">yield</span> retval(<span class="hljs-keyword">new</span> CoSocket(stream_socket_accept(<span class="hljs-keyword">$this</span>-&gt;socket, <span class="hljs-number">0</span>)));<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">read</span>(<span class="hljs-params"><span class="hljs-variable">$size</span></span>) </span>&#123;<br>        <span class="hljs-keyword">yield</span> waitForRead(<span class="hljs-keyword">$this</span>-&gt;socket);<br>        <span class="hljs-keyword">yield</span> retval(fread(<span class="hljs-keyword">$this</span>-&gt;socket, <span class="hljs-variable">$size</span>));<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">write</span>(<span class="hljs-params"><span class="hljs-variable">$string</span></span>) </span>&#123;<br>        <span class="hljs-keyword">yield</span> waitForWrite(<span class="hljs-keyword">$this</span>-&gt;socket);<br>        fwrite(<span class="hljs-keyword">$this</span>-&gt;socket, <span class="hljs-variable">$string</span>);<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">close</span>(<span class="hljs-params"></span>) </span>&#123;<br>        @fclose(<span class="hljs-keyword">$this</span>-&gt;socket);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在服务器可以编写的稍微简洁点了：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br> <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">server</span>(<span class="hljs-params"><span class="hljs-variable">$port</span></span>) </span>&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Starting server at port <span class="hljs-subst">$port</span>...\n&quot;</span>;<br> <br>    <span class="hljs-variable">$socket</span> = @stream_socket_server(<span class="hljs-string">&quot;tcp://localhost:<span class="hljs-subst">$port</span>&quot;</span>, <span class="hljs-variable">$errNo</span>, <span class="hljs-variable">$errStr</span>);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable">$socket</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Exception</span>(<span class="hljs-variable">$errStr</span>, <span class="hljs-variable">$errNo</span>);<br> <br>    stream_set_blocking(<span class="hljs-variable">$socket</span>, <span class="hljs-number">0</span>);<br> <br>    <span class="hljs-variable">$socket</span> = <span class="hljs-keyword">new</span> CoSocket(<span class="hljs-variable">$socket</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">yield</span> newTask(<br>            handleClient(<span class="hljs-keyword">yield</span> <span class="hljs-variable">$socket</span>-&gt;accept())<br>        );<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleClient</span>(<span class="hljs-params"><span class="hljs-variable">$socket</span></span>) </span>&#123;<br>    <span class="hljs-variable">$data</span> = (<span class="hljs-keyword">yield</span> <span class="hljs-variable">$socket</span>-&gt;read(<span class="hljs-number">8192</span>));<br> <br>    <span class="hljs-variable">$msg</span> = <span class="hljs-string">&quot;Received following request:\n\n<span class="hljs-subst">$data</span>&quot;</span>;<br>    <span class="hljs-variable">$msgLength</span> = strlen(<span class="hljs-variable">$msg</span>);<br> <br>    <span class="hljs-variable">$response</span> = <span class="hljs-string">&lt;&lt;&lt;RES</span><br><span class="hljs-string">HTTP/1.1 200 OK\r</span><br><span class="hljs-string">Content-Type: text/plain\r</span><br><span class="hljs-string">Content-Length: <span class="hljs-subst">$msgLength</span>\r</span><br><span class="hljs-string">Connection: close\r</span><br><span class="hljs-string">\r</span><br><span class="hljs-string"><span class="hljs-subst">$msg</span></span><br><span class="hljs-string">RES</span>;<br> <br>    <span class="hljs-keyword">yield</span> <span class="hljs-variable">$socket</span>-&gt;write(<span class="hljs-variable">$response</span>);<br>    <span class="hljs-keyword">yield</span> <span class="hljs-variable">$socket</span>-&gt;close();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>作为一个优秀的程序员, 相信你已经察觉到上面的例子缺少错误处理. 几乎所有的 socket 都是易出错的. 我没有这样做的原因一方面固然是因为错误处理的乏味（特别是 socket), 另一方面也在于它很容易使代码体积膨胀.</p><p>不过, 我仍然想讲下常见的协程错误处理：协程允许使用 throw() 方法在其内部抛出一个错误.</p><p>throw() 方法接受一个 Exception, 并将其抛出到协程的当前悬挂点, 看看下面代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">gen</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Foo\n&quot;</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">yield</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-built_in">Exception</span> <span class="hljs-variable">$e</span>) &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Exception: <span class="hljs-subst">&#123;$e-&gt;getMessage()&#125;</span>\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Bar\n&quot;</span>;<br>&#125;<br> <br><span class="hljs-variable">$gen</span> = gen();<br><span class="hljs-variable">$gen</span>-&gt;rewind();                     <span class="hljs-comment">// echos &quot;Foo&quot;</span><br><span class="hljs-variable">$gen</span>-&gt;throw(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Exception</span>(<span class="hljs-string">&#x27;Test&#x27;</span>)); <span class="hljs-comment">// echos &quot;Exception: Test&quot;</span><br>                                    <span class="hljs-comment">// and &quot;Bar&quot;</span><br></code></pre></td></tr></table></figure><p>这非常好, 有没有? 因为我们现在可以使用系统调用以及子协程调用异常抛出了.</p><p>不过我们要对系统调用Scheduler::run() 方法做一些小调整：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$retval</span> <span class="hljs-keyword">instanceof</span> SystemCall) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-variable">$retval</span>(<span class="hljs-variable">$task</span>, <span class="hljs-keyword">$this</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-built_in">Exception</span> <span class="hljs-variable">$e</span>) &#123;<br>        <span class="hljs-variable">$task</span>-&gt;setException(<span class="hljs-variable">$e</span>);<br>        <span class="hljs-keyword">$this</span>-&gt;schedule(<span class="hljs-variable">$task</span>);<br>    &#125;<br>    <span class="hljs-keyword">continue</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Task 类也要添加 throw 调用处理：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$exception</span> = <span class="hljs-literal">null</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setException</span>(<span class="hljs-params"><span class="hljs-variable">$exception</span></span>) </span>&#123;<br>        <span class="hljs-keyword">$this</span>-&gt;exception = <span class="hljs-variable">$exception</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">$this</span>-&gt;beforeFirstYield) &#123;<br>            <span class="hljs-keyword">$this</span>-&gt;beforeFirstYield = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">$this</span>-&gt;coroutine-&gt;current();<br>        &#125; <span class="hljs-keyword">elseif</span> (<span class="hljs-keyword">$this</span>-&gt;exception) &#123;<br>            <span class="hljs-variable">$retval</span> = <span class="hljs-keyword">$this</span>-&gt;coroutine-&gt;throw(<span class="hljs-keyword">$this</span>-&gt;exception);<br>            <span class="hljs-keyword">$this</span>-&gt;exception = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable">$retval</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-variable">$retval</span> = <span class="hljs-keyword">$this</span>-&gt;coroutine-&gt;send(<span class="hljs-keyword">$this</span>-&gt;sendValue);<br>            <span class="hljs-keyword">$this</span>-&gt;sendValue = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable">$retval</span>;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>现在, 我们已经可以在系统调用中使用异常抛出了！例如,要调用 killTask,让我们在传递 ID 不可用时抛出一个异常：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">killTask</span>(<span class="hljs-params"><span class="hljs-variable">$tid</span></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SystemCall(<br>        <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Task <span class="hljs-variable">$task</span>, Scheduler <span class="hljs-variable">$scheduler</span></span>) <span class="hljs-keyword">use</span> (<span class="hljs-params"><span class="hljs-variable">$tid</span></span>) </span>&#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable">$scheduler</span>-&gt;killTask(<span class="hljs-variable">$tid</span>)) &#123;<br>                <span class="hljs-variable">$scheduler</span>-&gt;schedule(<span class="hljs-variable">$task</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">InvalidArgumentException</span>(<span class="hljs-string">&#x27;Invalid task ID!&#x27;</span>);<br>            &#125;<br>        &#125;<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>试试看：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">task</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">yield</span> killTask(<span class="hljs-number">500</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-built_in">Exception</span> <span class="hljs-variable">$e</span>) &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;Tried to kill task 500 but failed: &#x27;</span>, <span class="hljs-variable">$e</span>-&gt;getMessage(), <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这些代码现在尚不能正常运作,因为 stackedCoroutine 函数无法正确处理异常.要修复需要做些调整：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stackedCoroutine</span>(<span class="hljs-params"><span class="hljs-built_in">Generator</span> <span class="hljs-variable">$gen</span></span>) </span>&#123;<br>    <span class="hljs-variable">$stack</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SplStack</span>;<br>    <span class="hljs-variable">$exception</span> = <span class="hljs-literal">null</span>;<br> <br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable">$exception</span>) &#123;<br>                <span class="hljs-variable">$gen</span>-&gt;throw(<span class="hljs-variable">$exception</span>);<br>                <span class="hljs-variable">$exception</span> = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br> <br>            <span class="hljs-variable">$value</span> = <span class="hljs-variable">$gen</span>-&gt;current();<br> <br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable">$value</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Generator</span>) &#123;<br>                <span class="hljs-variable">$stack</span>-&gt;push(<span class="hljs-variable">$gen</span>);<br>                <span class="hljs-variable">$gen</span> = <span class="hljs-variable">$value</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br> <br>            <span class="hljs-variable">$isReturnValue</span> = <span class="hljs-variable">$value</span> <span class="hljs-keyword">instanceof</span> CoroutineReturnValue;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-variable">$gen</span>-&gt;valid() || <span class="hljs-variable">$isReturnValue</span>) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-variable">$stack</span>-&gt;isEmpty()) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br> <br>                <span class="hljs-variable">$gen</span> = <span class="hljs-variable">$stack</span>-&gt;pop();<br>                <span class="hljs-variable">$gen</span>-&gt;send(<span class="hljs-variable">$isReturnValue</span> ? <span class="hljs-variable">$value</span>-&gt;getValue() : <span class="hljs-literal">NULL</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br> <br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-variable">$sendValue</span> = (<span class="hljs-keyword">yield</span> <span class="hljs-variable">$gen</span>-&gt;key() =&gt; <span class="hljs-variable">$value</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-built_in">Exception</span> <span class="hljs-variable">$e</span>) &#123;<br>                <span class="hljs-variable">$gen</span>-&gt;throw(<span class="hljs-variable">$e</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br> <br>            <span class="hljs-variable">$gen</span>-&gt;send(<span class="hljs-variable">$sendValue</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-built_in">Exception</span> <span class="hljs-variable">$e</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable">$stack</span>-&gt;isEmpty()) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-variable">$e</span>;<br>            &#125;<br> <br>            <span class="hljs-variable">$gen</span> = <span class="hljs-variable">$stack</span>-&gt;pop();<br>            <span class="hljs-variable">$exception</span> = <span class="hljs-variable">$e</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>在这篇文章里,我使用多任务协作构建了一个任务调度器, 其中包括执行“系统调用”, 做非阻塞操作和处理错误. 所有这些里真正很酷的事情是任务的结果代码看起来完全同步, 甚至任务正在执行大量的异步操作的时候也是这样.</p><p>如果你打算从套接口读取数据的话, 你将不需要传递某个回调函数或者注册一个事件侦听器. 相反, 你只要书写yield $socket-&gt;read(). 这儿大部分都是你常常也要编写的,只 在它的前面增加yield.</p><p>当我第一次听到协程的时候, 我发现这个概念完全令人折服, 正是因为这个激励我在PHP中实现了它. 同时我发现协程真正非常的令人惊叹:在令人敬畏的代码和一大堆乱代码之间只有一线之隔, 我认为协程恰好处在这条线上, 不多不少. 不过, 要说使用上面所述的方法书写异步代码是否真的有益, 这个就见仁见智了.</p><p>但, 不管咋样, 我认为这是一个有趣的话题, 而且我希望你也能找到它的乐趣. 欢迎评论:)</p><ul><li><em>原文地址：<a href="http://www.laruence.com/2015/05/28/3038.html">风雪之隅 —— 28 May 15 在PHP中使用协程实现多任务调度</a></em></li><li><em>英文原文地址：<a href="http://nikic.github.io/2012/12/22/Cooperative-multitasking-using-coroutines-in-PHP.html">Cooperative multitasking using coroutines (in PHP!)</a></em></li></ul>]]></content>
    
    
    <categories>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 用户与授权</title>
    <link href="/2017/07/MySQL-%E7%94%A8%E6%88%B7%E4%B8%8E%E6%8E%88%E6%9D%83/"/>
    <url>/2017/07/MySQL-%E7%94%A8%E6%88%B7%E4%B8%8E%E6%8E%88%E6%9D%83/</url>
    
    <content type="html"><![CDATA[<p>随着机器和使用机器的人员增多，再也不能像从前一样一个 root 走天下了，这就需要经常使用到 mysql 的用户和授权了。在此记录整理，方便今后查找。</p><h3 id="1-查看用户权限"><a href="#1-查看用户权限" class="headerlink" title="1.查看用户权限"></a>1.查看用户权限</h3><figure class="highlight nginx"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">SHOW</span> GRANTS FOR <span class="hljs-string">&#x27;username&#x27;</span>@<span class="hljs-string">&#x27;host&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="2-创建用户"><a href="#2-创建用户" class="headerlink" title="2.创建用户"></a>2.创建用户</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;username&#x27;</span>@<span class="hljs-string">&#x27;host&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;password&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>Usage</strong></p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;liubin&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;liubin&#x27;</span>@<span class="hljs-string">&#x27;127.0.0.1&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;liubin&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span>;<br></code></pre></td></tr></table></figure><span id="more"></span><h3 id="3-授权"><a href="#3-授权" class="headerlink" title="3.授权"></a>3.授权</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">privileges</span> <span class="hljs-keyword">ON</span> databasename.tablename <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;username&#x27;</span>@<span class="hljs-string">&#x27;host&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>Usage</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span>, <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">ON</span> test.<span class="hljs-keyword">user</span> <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;liubin&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span>;<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">ON</span> *.* <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;liubin&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span>;<br></code></pre></td></tr></table></figure><p>privileges 是一个用逗号分隔的你想要赋予的 mysql 用户权限的列表。你可以指定的权限可以分为三种类型：</p><ul><li><p>数据库/数据表/数据列权限</p><ul><li><code>ALTER</code>: 修改已存在的数据表(例如增加/删除列和索引)。</li><li><code>CREATE</code>: 建立新的数据库或数据表。</li><li><code>DELETE</code>: 删除表的记录。</li><li><code>DROP</code>: 删除数据表或数据库。</li><li><code>INDEX</code>: 建立或删除索引。</li><li><code>INSERT</code>: 增加表的记录。</li><li><code>SELECT</code>: 显示/搜索表的记录。</li><li><code>UPDATE</code>: 修改表中已存在的记录。</li></ul></li><li><p>全局管理MySQL用户权限：</p><ul><li><code>FILE</code>: 在MySQL服务器上读写文件。</li><li><code>PROCESS</code>: 显示或杀死属于其它用户的服务线程。</li><li><code>RELOAD</code>: 重载访问控制表，刷新日志等。</li><li><code>SHUTDOWN</code>: 关闭MySQL服务。</li></ul></li><li><p>特别的权限：</p><ul><li><code>ALL</code>: 允许做任何事(和root一样)。</li><li><code>USAGE</code>: 只允许登录(其它什么也不允许做)。</li></ul></li></ul><h3 id="4-设置与更改用户密码"><a href="#4-设置与更改用户密码" class="headerlink" title="4.设置与更改用户密码"></a>4.设置与更改用户密码</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">PASSWORD</span> <span class="hljs-keyword">FOR</span> <span class="hljs-string">&#x27;username&#x27;</span>@<span class="hljs-string">&#x27;host&#x27;</span> = <span class="hljs-keyword">PASSWORD</span>(&quot;newpassword&quot;);<br><br><span class="hljs-keyword">SET</span> <span class="hljs-keyword">PASSWORD</span> = <span class="hljs-keyword">PASSWORD</span>(&quot;newpassword&quot;);<span class="hljs-comment">/* 修改当前登陆用户 */</span> <br></code></pre></td></tr></table></figure><p><strong>Note：</strong></p><p>mysql 新设置用户或更改密码后需用</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">FLUSH PRIVILEGES<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>刷新 mysql 的系统权限相关表，否则会出现拒绝访问；还有一种方法，就是重新启动 mysql 服务器，来使新设置生效。</p><h3 id="5-撤销用户权限"><a href="#5-撤销用户权限" class="headerlink" title="5.撤销用户权限"></a>5.撤销用户权限</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">REVOKE</span> privilege <span class="hljs-keyword">ON</span> databasename.tablename <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;username&#x27;</span>@<span class="hljs-string">&#x27;host&#x27;</span>;<br></code></pre></td></tr></table></figure><p>privilege, databasename, tablename：同授权部分</p><p><strong>Note：</strong></p><p>假如你在给用户<code>&#39;liubin&#39;@&#39;%&#39;</code>授权的时候是这样的(或类似的)：<code>GRANT SELECT ON test.user TO &#39;liubin&#39;@&#39;%;&#39;</code>，则在使用<code>REVOKE SELECT ON *.* FROM &#39;liubin&#39;@&#39;%&#39;;</code>命令并不能撤销该用户对test数据库中user表的SELECT 操作。相反，如果授权使用的是<code>GRANT SELECT ON *.* TO &#39;liubin&#39;@&#39;%&#39;;</code>则<code>REVOKE SELECT ON test.user FROM &#39;liubin&#39;@&#39;%&#39;;</code>命令也不能撤销该用户对test数据库中user表的Select权限。</p><p>具体信息可以用命令<code>SHOW GRANTS FOR &#39;liubin&#39;@&#39;%&#39;;</code>查看。</p><h3 id="6-删除用户"><a href="#6-删除用户" class="headerlink" title="6.删除用户"></a>6.删除用户</h3><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;username&#x27;</span>@<span class="hljs-string">&#x27;host&#x27;</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 配置文件详解</title>
    <link href="/2017/07/MySQL-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <url>/2017/07/MySQL-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>近几个月 team 里就剩我一个工程师，前端后端运维杂活儿一大堆，各种开会 &amp; 面试，一直没来得及写 blog，近期小组内部一起研究 mysql，所以先分享我的 mysql 配置(附带部分配置项说明)以供参考，之后更新也当做个记录。</p><h4 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h4><ul><li>MacBook Pro (Retina, 13-inch, Early 2015)</li><li>macOS 10.12.5</li><li>slave version 5.7.18</li><li>master version 5.5.33</li></ul><span id="more"></span><h4 id="my-cnf"><a href="#my-cnf" class="headerlink" title="my.cnf"></a>my.cnf</h4><figure class="highlight nix"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></div></td><td class="code"><pre><code class="hljs nix"><br>[client]<br><span class="hljs-attr">port</span> = <span class="hljs-number">3306</span><br><span class="hljs-attr">socket</span> = /tmp/mysql.sock<br><span class="hljs-comment"># 低版本未指定时不同终端可能会出现不同字符集</span><br><span class="hljs-attr">default-character-set</span> = utf8mb4<br><br>[mysqld]<br><span class="hljs-comment"># basic settings #</span><br><span class="hljs-attr">user</span> = mysql<br><span class="hljs-attr">port</span> = <span class="hljs-number">3306</span><br><span class="hljs-attr">socket</span> = /tmp/mysql.sock<br><span class="hljs-attr">server_id</span> = <span class="hljs-number">2</span><br><span class="hljs-attr">character-set-server</span> = utf8mb4<br><span class="hljs-attr">default-storage-engine</span> = INNODB<br><span class="hljs-attr">sql_mode</span> = <span class="hljs-string">&quot;STRICT_TRANS_TABLES,NO_ENGINE_SUBSTITUTION,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER&quot;</span><br><span class="hljs-attr">autocommit</span> = <span class="hljs-number">1</span><br><span class="hljs-comment"># 将事务隔离级别设置为READ-COMMITTED</span><br><span class="hljs-attr">transaction_isolation</span> = READ-COMMITTED<br><span class="hljs-comment"># 设置处理TIMESTAMP列的方式，详见官方文档说明</span><br><span class="hljs-attr">explicit_defaults_for_timestamp</span> = <span class="hljs-number">1</span><br><span class="hljs-comment"># 接受的数据包大小，有时大的插入和更新会失败，将max_allowed_packet设置适当避免该问题</span><br><span class="hljs-attr">max_allowed_packet</span> = <span class="hljs-number">128</span>M<br><span class="hljs-attr">event_scheduler</span> = <span class="hljs-number">1</span><br><span class="hljs-comment"># 关闭鸡肋的query_cache</span><br><span class="hljs-attr">query_cache_type</span> = <span class="hljs-number">0</span><br><span class="hljs-attr">query_cache_size</span> = <span class="hljs-number">0</span><br><span class="hljs-comment"># os file system config #</span><br><span class="hljs-attr">lower_case_table_names</span> = <span class="hljs-number">2</span><br><br><span class="hljs-comment"># connection #</span><br><span class="hljs-comment"># 使用MySQL客户端连接超时时间设为3分钟</span><br><span class="hljs-attr">interactive_timeout</span> = <span class="hljs-number">1800</span><br><span class="hljs-comment"># 使用JDBC连接超时时间设为3分钟</span><br><span class="hljs-attr">wait_timeout</span> = <span class="hljs-number">1800</span><br><span class="hljs-comment"># 锁等待时间</span><br><span class="hljs-attr">lock_wait_timeout</span> = <span class="hljs-number">1800</span><br><span class="hljs-comment"># 该参数目的是不再进行反解析，可以加快数据库的反应时间</span><br><span class="hljs-attr">skip_name_resolve</span> = <span class="hljs-number">1</span><br><span class="hljs-comment"># 允许的最大连接数</span><br><span class="hljs-attr">max_connections</span> = <span class="hljs-number">512</span><br><span class="hljs-comment"># 允许的最大错误连接数，超过该值客户端将被屏蔽，默认为100，一般将该值设的较大避免客户端被屏蔽引发难以预料的问题</span><br><span class="hljs-attr">max_connect_errors</span> = <span class="hljs-number">1000000</span><br><br><span class="hljs-comment"># table cache performance settings</span><br><span class="hljs-attr">table_open_cache</span> = <span class="hljs-number">4096</span><br><span class="hljs-attr">table_definition_cache</span> = <span class="hljs-number">4096</span><br><span class="hljs-attr">table_open_cache_instances</span> = <span class="hljs-number">32</span><br><br><span class="hljs-comment"># session memory settings #</span><br><span class="hljs-comment"># MySQL读入缓冲区大小</span><br><span class="hljs-attr">read_buffer_size</span> = <span class="hljs-number">16</span>M<br><span class="hljs-comment"># MySQL随机读缓冲区大小</span><br><span class="hljs-attr">read_rnd_buffer_size</span> = <span class="hljs-number">32</span>M<br><span class="hljs-comment"># 排序缓存大小，在排序大量数据时该值将影响order by子句的执行效率</span><br><span class="hljs-attr">sort_buffer_size</span> = <span class="hljs-number">32</span>M<br><span class="hljs-comment"># 临时表大小，在排序和连接较多时，适当</span><br><span class="hljs-attr">tmp_table_size</span> = <span class="hljs-number">64</span>M<br><span class="hljs-comment"># 连接缓存大小，在连接大表时，该值将影响连接查询的效率</span><br><span class="hljs-attr">join_buffer_size</span> = <span class="hljs-number">128</span>M<br><span class="hljs-attr">thread_cache_size</span> = <span class="hljs-number">64</span><br><span class="hljs-attr">thread_stack</span> = <span class="hljs-number">512</span>K<br><br><span class="hljs-comment"># log settings #</span><br><span class="hljs-attr">log_error</span> = error.log<br><span class="hljs-comment"># 开启慢查询日志</span><br><span class="hljs-attr">slow_query_log</span> = <span class="hljs-number">1</span><br><span class="hljs-comment"># 慢查询日志存放位置</span><br><span class="hljs-attr">slow_query_log_file</span> = /usr/local/var/mysql/liubindeMBP-slow.log<br><span class="hljs-attr">log_queries_not_using_indexes</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">log_slow_admin_statements</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">log_slow_slave_statements</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">log_throttle_queries_not_using_indexes</span> = <span class="hljs-number">10</span><br><span class="hljs-comment"># 二进制日志过期时间</span><br><span class="hljs-attr">expire_logs_days</span> = <span class="hljs-number">90</span><br><span class="hljs-comment"># 超过多少秒的查询，被视为慢查询</span><br><span class="hljs-attr">long_query_time</span> = <span class="hljs-number">2</span>  <br><span class="hljs-attr">min_examined_row_limit</span> = <span class="hljs-number">100</span>  <br><span class="hljs-attr">binlog-rows-query-log-events</span> = <span class="hljs-number">1</span>  <br><span class="hljs-attr">log-bin-trust-function-creators</span> = <span class="hljs-number">1</span>  <br><span class="hljs-attr">expire-logs-days</span> = <span class="hljs-number">90</span>  <br><span class="hljs-comment">#log-slave-updates = 1</span><br><br><span class="hljs-comment"># innodb settings #</span><br><span class="hljs-attr">innodb_page_size</span> = <span class="hljs-number">16384</span>  <br><span class="hljs-comment"># InnoDB缓存池大小</span><br><span class="hljs-attr">innodb_buffer_pool_size</span> = <span class="hljs-number">4</span>G<br><span class="hljs-comment"># InnoDB缓存池实例数</span><br><span class="hljs-attr">innodb_buffer_pool_instances</span> = <span class="hljs-number">4</span><br><span class="hljs-comment"># 在启动时把热数据加载到内存</span><br><span class="hljs-attr">innodb_buffer_pool_load_at_startup</span> = <span class="hljs-number">1</span><br><span class="hljs-comment"># 数据库关闭时自动dump数据</span><br><span class="hljs-attr">innodb_buffer_pool_dump_at_shutdown</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">innodb_lru_scan_depth</span> = <span class="hljs-number">4096</span><br><span class="hljs-attr">innodb_lock_wait_timeout</span> = <span class="hljs-number">5</span><br><span class="hljs-attr">innodb_io_capacity</span> = <span class="hljs-number">10000</span><br><span class="hljs-attr">innodb_io_capacity_max</span> = <span class="hljs-number">20000</span><br><span class="hljs-attr">innodb_flush_method</span> = O_DIRECT<br><span class="hljs-attr">innodb_undo_logs</span> = <span class="hljs-number">128</span><br><span class="hljs-attr">innodb_undo_tablespaces</span> = <span class="hljs-number">0</span><br><span class="hljs-attr">innodb_flush_neighbors</span> = <span class="hljs-number">0</span><br><span class="hljs-attr">innodb_log_file_size</span> = <span class="hljs-number">8589934592</span><br><span class="hljs-attr">innodb_log_files_in_group</span> = <span class="hljs-number">2</span><br><span class="hljs-attr">innodb_log_buffer_size</span> = <span class="hljs-number">16777216</span><br><span class="hljs-attr">innodb_purge_threads</span> = <span class="hljs-number">4</span><br><span class="hljs-attr">innodb_large_prefix</span> = <span class="hljs-number">1</span><br><span class="hljs-comment"># 并发运行的线程数，设置为0表示不限制</span><br><span class="hljs-attr">innodb_thread_concurrency</span> = <span class="hljs-number">8</span><br><span class="hljs-attr">innodb_print_all_deadlocks</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">innodb_strict_mode</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">innodb_sort_buffer_size</span> = <span class="hljs-number">67108864</span><br><span class="hljs-attr">innodb_write_io_threads</span> = <span class="hljs-number">16</span><br><span class="hljs-attr">innodb_read_io_threads</span> = <span class="hljs-number">16</span><br><span class="hljs-attr">innodb_file_per_table</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">innodb_stats_persistent_sample_pages</span> = <span class="hljs-number">64</span><br><span class="hljs-attr">innodb_autoinc_lock_mode</span> = <span class="hljs-number">2</span><br><span class="hljs-attr">innodb_online_alter_log_max_size=1G</span><br><span class="hljs-attr">innodb_open_files=4096</span><br><br><span class="hljs-comment"># replication settings #</span><br><span class="hljs-attr">replicate-do-db</span> = panorama<br><span class="hljs-comment"># 测试机(v5.5) 没这个参数</span><br><span class="hljs-attr">binlog_checksum</span> = NONE<br><span class="hljs-comment"># master.info保存在表中</span><br><span class="hljs-comment">#master_info_repository = TABLE </span><br><span class="hljs-comment"># relay.info保存在表中</span><br><span class="hljs-attr">relay_log_info_repository</span> = TABLE<br><span class="hljs-comment"># 当每进行1次事务提交之后，MySQL将进行一次fsync磁盘同步，以此来保证无损复制</span><br><span class="hljs-attr">sync_binlog</span> = <span class="hljs-number">1</span><br><span class="hljs-comment"># 启动GTID模式</span><br><span class="hljs-comment">#gtid_mode = on</span><br><span class="hljs-comment"># 启动GTID模式</span><br><span class="hljs-comment">#enforce_gtid_consistency = 1</span><br><span class="hljs-comment"># 从服务器的更新写入二进制日志,便于主从切换时，从服务器已经开启二进制日志</span><br>log_slave_updates<br><span class="hljs-comment"># 以row格式记录binlog</span><br><span class="hljs-comment">#binlog_format = ROW</span><br><span class="hljs-attr">binlog_format</span> = STATEMENT<br><span class="hljs-comment">#binlog_rows_query_log_events = 1</span><br><span class="hljs-attr">relay_log</span> = relay.log<br><span class="hljs-attr">relay_log_index</span> = relay_log.index<br><span class="hljs-comment"># 允许从库宕机后，重新从master上获取日志，保证relay-log的完整性</span><br><span class="hljs-attr">relay_log_recovery</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">slave_skip_errors</span> = ddl_exist_errors<br><span class="hljs-comment">#slave-rows-search-algorithms = &#x27;INDEX_SCAN,HASH_SCAN&#x27;</span><br><br><span class="hljs-comment"># semi sync replication settings #</span><br><span class="hljs-comment">#plugin_load = &quot;validate_password.so;rpl_semi_sync_master=semisync_master.so;rpl_semi_sync_slave=semisync_slave.so&quot;</span><br><span class="hljs-attr">plugin_load</span> = <span class="hljs-string">&quot;validate_password.so&quot;</span><br><span class="hljs-comment">#rpl_semi_sync_master_enabled = 1</span><br><span class="hljs-comment">#rpl_semi_sync_master_timeout = 3000</span><br><span class="hljs-comment">#rpl_semi_sync_slave_enabled = 1</span><br><br><span class="hljs-comment"># password plugin #</span><br><span class="hljs-attr">validate_password_policy=MEDIUM</span><br><span class="hljs-attr">validate-password=FORCE_PLUS_PERMANENT</span><br><br><span class="hljs-comment"># new innodb settings #</span><br><span class="hljs-attr">innodb_buffer_pool_dump_pct</span> = <span class="hljs-number">40</span><br><span class="hljs-attr">innodb_page_cleaners</span> = <span class="hljs-number">4</span><br><span class="hljs-attr">innodb_undo_log_truncate</span> = <span class="hljs-number">1</span><br><span class="hljs-comment"># 当超过这个阀值（默认是1G），会触发truncate回收（收缩）动作，truncate后空间缩小到10M</span><br><span class="hljs-attr">innodb_max_undo_log_size</span> = <span class="hljs-number">2</span>G<br><span class="hljs-attr">innodb_purge_rseg_truncate_frequency</span> = <span class="hljs-number">128</span><br><span class="hljs-comment"># new replication settings #</span><br><span class="hljs-comment">#slave-parallel-type = LOGICAL_CLOCK</span><br><span class="hljs-comment">#slave-parallel-workers = 4</span><br><span class="hljs-comment">#slave_preserve_commit_order = 1</span><br><span class="hljs-comment">#slave_transaction_retries = 128</span><br><span class="hljs-comment"># other change settings #</span><br><span class="hljs-attr">binlog_gtid_simple_recovery</span> = <span class="hljs-number">1</span><br><span class="hljs-attr">log_timestamps</span> = system<br><span class="hljs-attr">show_compatibility_56</span> = on<br><br>[mysql]<br><span class="hljs-attr">prompt</span> = [\\u@\\h][\\d]&gt;\\_<br>no-auto-rehash<br><span class="hljs-attr">default-character-set</span> = utf8mb4<br><br>[mysqldump]<br>quick<br><br>[isamchk]<br><span class="hljs-comment"># 5.7版本部分系统表还在使用MyISAM，结合系统中引擎使用情况适当优化</span><br><span class="hljs-attr">key_buffer_size</span> = <span class="hljs-number">2</span>G<br><span class="hljs-attr">myisam_sort_buffer_size</span> = <span class="hljs-number">128</span>M<br><br></code></pre></td></tr></table></figure><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><blockquote><p><strong>Question: Mysql configuration file sections</strong></p></blockquote><blockquote><p>Description:<br>I am trying to understand the different sections inside the my.ini configuration file ([client], [mysqld], [mysql]) and so on, I am looking for a guide describing each of the optional sections for the my.ini file, Also i was wondering what is the difference between init_connect and init-connect and i mean between the underscore(_) and the hyphen(-), Thank you all and have a nice day.</p></blockquote><blockquote><p><strong>Answer:</strong></p></blockquote><blockquote><p><strong>[mysql]</strong> applies to the mysql command line client - <a href="https://dev.mysql.com/doc/refman/5.5/en/mysql-command-options.html">mysql and client options</a></p></blockquote><blockquote><p><strong>[client]</strong> applies to all connecting clients (including mysql cli) - <a href="https://dev.mysql.com/doc/refman/5.5/en/mysql-command-options.html">mysql and client options</a></p></blockquote><blockquote><p><strong>[mysqld]</strong> applies to the mysql server - <a href="http://dev.mysql.com/doc/refman/5.5/en/server-options.html">server options</a></p></blockquote><blockquote><p><strong>[mysqldump]</strong> applies to the utility of the same name - <a href="http://dev.mysql.com/doc/refman/5.5/en/mysqldump.html">mysqldump options</a></p></blockquote><blockquote><p>…etc</p></blockquote><blockquote><p>The difference between the (-) and the (_) is the context in which it is used.</p></blockquote><blockquote><p>(-) is used in command line parameters, where (_) is used in options file parameters.</p></blockquote><blockquote><p>You can see more in the docs: <a href="http://dev.mysql.com/doc/refman/5.5/en/option-files.html">http://dev.mysql.com/doc/refman/5.5/en/option-files.html</a></p></blockquote><h4 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h4><ul><li><a href="https://github.com/jdaaaaaavid/mysql_best_configuration">https://github.com/jdaaaaaavid/mysql_best_configuration</a></li><li><a href="http://fuxuri.com/2017/06/03/mysql-my-cnfpei-zhi/">http://fuxuri.com/2017/06/03/mysql-my-cnfpei-zhi/</a></li><li><a href="https://stackoverflow.com/questions/15453555/mysql-configuration-file-sections">https://stackoverflow.com/questions/15453555/mysql-configuration-file-sections</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker在PHP项目开发环境中的应用</title>
    <link href="/2017/04/Docker%E5%9C%A8PHP%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2017/04/Docker%E5%9C%A8PHP%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>环境部署是所有团队都必须面对的问题，随着系统越来越大，依赖的服务也越来越多，比如我们目前的一个项目就会用到：</p><ul><li>Web服务器：Nginx</li><li>Web程序：PHP + Node</li><li>数据库：MySQL</li><li>搜索引擎：ElasticSearch</li><li>队列服务：Gearman</li><li>缓存服务：Redis + Memcache</li><li>前端构建工具：npm + bower + gulp</li><li>PHP CLI工具：Composer + PHPUnit</li></ul><p>因此团队的开发环境部署随之暴露出若干问题：</p><ol><li>依赖服务很多，本地搭建一套环境成本越来越高，初级人员很难解决环境部署中的一些问题</li><li>服务的版本差异及OS的差异都可能导致线上环境BUG</li><li>项目引入新的服务时所有人的环境需要重新配置</li></ol><p>对于问题1，可以用<a href="https://www.vagrantup.com/">Vagrant</a>这样的基于虚拟机的项目来解决，团队成员共享一套开发环境镜像。对于问题2，可以引入类似<a href="https://github.com/phpbrew/phpbrew">PHPBrew</a>这样的多版本PHP管理工具来解决。但两者都不能很好地解决问题3，因为虚拟机镜像没有版本管理的概念，当多人维护一个镜像时，很容易出现配置遗漏或者冲突，一个很大的镜像传输起来也不方便。</p><p>Docker的出现让上面的问题有了更好的解决方案，虽然个人对于Docker大规模应用到生产环境还持谨慎态度，但如果仅仅考虑测试及开发，私以为Docker的容器化理念已经是能真正解决环境部署问题的银弹了。</p><p>下面介绍<a href="http://avnpc.com/pages/build-php-develop-env-by-docker">Docker构建PHP项目开发环境</a>过程中的演进，本文中假设你的操作系统为Linux，已经安装了Docker，并且已经了解<a href="https://www.docker.com/whatisdocker/">Docker是什么</a>，以及<a href="https://docs.docker.com/userguide/">Docker命令行的基础使用</a>，如果没有这些背景知识建议先自行了解。</p><span id="more"></span><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>首先还是从一个PHP在Docker容器下的Hello World实例开始。我们准备这样一个PHP文件<code>index.php</code>：</p><figure class="highlight php"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;PHP in Docker&quot;</span>;<br></code></pre></td></tr></table></figure><p>然后在同目录下创建文本文件并命名为<code>Dockerfile</code>，内容为：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># 从官方PHP镜像构建</span><br>FROM       php<br><br><span class="hljs-meta"># 将index.php复制到容器内的/var/www目录下</span><br>ADD        index.php /<span class="hljs-keyword">var</span>/www<br><br><span class="hljs-meta"># 对外暴露8080端口</span><br>EXPOSE     <span class="hljs-number">8080</span><br><br><span class="hljs-meta"># 设置容器默认工作目录为/var/www</span><br>WORKDIR    /<span class="hljs-keyword">var</span>/www<br><br><span class="hljs-meta"># 容器运行后默认执行的指令</span><br>ENTRYPOINT [<span class="hljs-string">&quot;php&quot;</span>, <span class="hljs-string">&quot;-S&quot;</span>, <span class="hljs-string">&quot;0.0.0.0:8080&quot;</span>]<br></code></pre></td></tr></table></figure><p>构建这个容器：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">docker build -t allovince/php-helloworld .<br></code></pre></td></tr></table></figure><p>运行这个容器</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d -p <span class="hljs-number">8080</span>:<span class="hljs-number">8080</span> allovince/php-helloworld<br></code></pre></td></tr></table></figure><p>查看结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">curl</span> localhost:<span class="hljs-number">8080</span><br><span class="hljs-attribute">PHP</span> in Docker<br></code></pre></td></tr></table></figure><p>这样我们就创建了一个用于演示PHP程序的Docker容器，任何安装过Docker的机器都可以运行这个容器获得同样的结果。而任何有上面的php文件和Dockerfile的人都可以构建出相同的容器，从而完全消除了不同环境，不同版本可能引起的各种问题。</p><p>想象一下程序进一步复杂，我们应该如何扩展呢，很直接的想法是继续在容器内安装其他用到的服务，并将所有服务运行起来，那么我们的Dockerfile很可能发展成这个样子：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">FROM</span>       php<br><span class="hljs-builtin-name">ADD</span>        index.php /var/www<br><br><span class="hljs-comment"># 安装更多服务</span><br><span class="hljs-builtin-name">RUN</span>           apt-<span class="hljs-builtin-name">get</span> install -y \<br>           mysql-server \<br>           nginx \<br>           php5-fpm \<br>           php5-mysql<br>           <br><span class="hljs-comment"># 编写一个启动脚本启动所有服务</span><br>ENTRYPOINT [<span class="hljs-string">&quot;/opt/bin/php-nginx-mysql-start.sh&quot;</span>]<br></code></pre></td></tr></table></figure><p>虽然我们通过Docker构建了一个开发环境，但觉不觉得有些似曾相识呢。没错，其实这种做法和制作一个虚拟机镜像是差不多的，这种方式存在几个问题：</p><ul><li>如果需要验证某个服务的不同版本，比如测试PHP5.3/5.4/5.5/5.6，就必须准备4个镜像，但其实每个镜像只有很小的差异。</li><li>如果开始新的项目，那么容器内安装的服务会不断膨胀，最终无法弄清楚哪个服务是属于哪个项目的。</li></ul><h2 id="使用单一进程容器"><a href="#使用单一进程容器" class="headerlink" title="使用单一进程容器"></a>使用单一进程容器</h2><p>上面这种将所有服务放在一个容器内的模式有个形象的非官方称呼：Fat Container。与之相对的是将服务分拆到容器的模式。从Docker的设计可以看到，构建镜像的过程中可以指定唯一一个容器启动的指令，因此Docker天然适合一个容器只运行一种服务，而这也是官方更推崇的。</p><p>分拆服务遇到的第一个问题就是，我们每一个服务的基础镜像从哪里来？这里有两个选项：</p><p><strong>选项一、 统一从标准的OS镜像扩展</strong>，比如下面分别是Nginx和MySQL镜像</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">FROM</span> ubuntu:14.04<br><span class="hljs-builtin-name">RUN</span>  apt-<span class="hljs-builtin-name">get</span> update -y &amp;&amp; apt-<span class="hljs-builtin-name">get</span> install -y nginx<br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">FROM</span> ubuntu:14.04<br><span class="hljs-builtin-name">RUN</span>  apt-<span class="hljs-builtin-name">get</span> update -y &amp;&amp; apt-<span class="hljs-builtin-name">get</span> install -y mysql<br></code></pre></td></tr></table></figure><p>这种方式的优点在于所有服务可以有一个统一的基础镜像，对镜像进行扩展和修改时可以使用同样的方式，比如选择了ubuntu，就可以使用<code>apt-get</code>指令安装服务。</p><p>问题在于大量的服务需要自己维护，特别是有时候需要某个服务的不同版本时，往往需要直接编译源码，调试维护成本都很高。</p><p><strong>选项二、 直接从Docker Hub继承官方镜像</strong>，下面同样是Nginx和MySQL镜像</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">FROM</span> nginx:<span class="hljs-number">1</span>.<span class="hljs-number">9</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">FROM</span> mysql:<span class="hljs-number">5</span>.<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><a href="https://registry.hub.docker.com/">Docker Hub</a>可以看做是Docker的Github，Docker官方已经准备好了大量<a href="https://registry.hub.docker.com/repos/library/?s=stars">常用服务的镜像</a>，同时也有非常多第三方提交的镜像。甚至可以基于<a href="https://github.com/docker/docker-registry">Docker-Registry</a>项目在短时间内自己搭建一个私有的Docker Hub。</p><p>基于某个服务的官方镜像去构建镜像，有非常丰富的选择，并且可以以很小的代价切换服务的版本。这种方式的问题在于官方镜像的构建方式多种多样，进行扩展时需要先了解原镜像的<code>Dockerfile</code>。</p><p>出于让服务搭建更灵活的考虑，我们选择后者构建镜像。</p><p>为了分拆服务，现在我们的目录变为如下所示结构：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs stylus">~/Dockerfiles<br>├── mysql<br>│   └── Dockerfile<br>├── nginx<br>│   ├── Dockerfile<br>│   ├── nginx<span class="hljs-selector-class">.conf</span><br>│   └── sites-enabled<br>│       ├── default<span class="hljs-selector-class">.conf</span><br>│       └── evaengine<span class="hljs-selector-class">.conf</span><br>├── php<br>│   ├── Dockerfile<br>│   ├── composer<span class="hljs-selector-class">.phar</span><br>│   ├── php-fpm<span class="hljs-selector-class">.conf</span><br>│   ├── php<span class="hljs-selector-class">.ini</span><br>│   ├── redis<span class="hljs-selector-class">.tgz</span><br>└── redis<br>    └── Dockerfile<br></code></pre></td></tr></table></figure><p>即为每个服务创建单独文件夹，并在每个服务文件夹下放一个Dockerfile。</p><h3 id="MySQL容器"><a href="#MySQL容器" class="headerlink" title="MySQL容器"></a>MySQL容器</h3><p>MySQL继承自官方的<a href="https://registry.hub.docker.com/_/mysql">MySQL5.6镜像</a>，Dockerfile仅有一行，无需做任何额外处理，因为普通需求官方都已经在镜像中实现了，因此Dockerfile的内容为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">FROM</span> mysql:<span class="hljs-number">5</span>.<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>在项目根目录下运行</p><div class="code-wrapper"><pre><code class="hljs">docker build -t eva/mysql ./mysql</code></pre></div><p>会自动下载并构建镜像，这里我们将其命名为<code>eva/mysql</code>。</p><p>由于容器运行结束时会丢弃所有数据库数据，为了不用每次都要导入数据，我们将采用挂载的方式持久化MySQL数据库，官方镜像默认将数据库存放在<code>/var/lib/mysql</code>，同时要求容器运行时必须通过环境变量设置一个管理员密码，因此可以使用以下指令运行容器：</p><div class="code-wrapper"><pre><code class="hljs">docker run -p 3306:3306 -v ~/opt/data/mysql:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -it eva/mysql</code></pre></div><p>通过上面的指令，我们将本地的3306端口绑定到容器的3306端口，将容器内的数据库持久化到本地的<code>~/opt/data/mysql</code>，并且为MySQL设置了一个root密码<code>123456</code></p><h3 id="Nginx容器"><a href="#Nginx容器" class="headerlink" title="Nginx容器"></a>Nginx容器</h3><p>Nginx目录下提前准备了Nginx配置文件<code>nginx.conf</code>以及项目的配置文件<code>default.conf</code>等。Dockerfile内容为：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">FROM nginx:<span class="hljs-number">1.9</span><br><br>ADD  nginx.conf      <span class="hljs-regexp">/etc/</span>nginx/nginx.conf<br>ADD  sites-enabled<span class="hljs-regexp">/*    /</span>etc<span class="hljs-regexp">/nginx/</span>conf.d/<br>RUN  mkdir <span class="hljs-regexp">/opt/</span>htdocs &amp;&amp; mkdir <span class="hljs-regexp">/opt/</span>log &amp;&amp; mkdir <span class="hljs-regexp">/opt/</span>log/nginx<br>RUN  chown -R www-data.www-data <span class="hljs-regexp">/opt/</span>htdocs <span class="hljs-regexp">/opt/</span>log<br><br>VOLUME [<span class="hljs-string">&quot;/opt&quot;</span>]<br></code></pre></td></tr></table></figure><p>由于官方的<a href="https://registry.hub.docker.com/_/nginx/">Nginx1.9</a>是基于Debian Jessie的，因此首先将准备好的配置文件复制到指定位置，替换镜像内的配置，这里按照个人习惯，约定<code>/opt/htdocs</code>目录为Web服务器根目录，<code>/opt/log/nginx</code>目录为Nginx的Log目录。</p><p>同样构建一下镜像</p><div class="code-wrapper"><pre><code class="hljs">docker build -t eva/nginx ./nginx</code></pre></div><p>并运行容器</p><div class="code-wrapper"><pre><code class="hljs">docker run -p 80:80 -v ~/opt:/opt -it eva/nginx</code></pre></div><p>注意我们将本地的80端口绑定到容器的80端口，并将本地的<code>~/opt</code>目录挂载到容器的<code>/opt</code>目录，这样就可以将项目源代码放在<code>~/opt</code>目录下并通过容器访问了。</p><h3 id="PHP容器"><a href="#PHP容器" class="headerlink" title="PHP容器"></a>PHP容器</h3><p>PHP容器是最复杂的一个，因为在实际项目中，我们很可能需要单独安装一些PHP扩展，并用到一些命令行工具，这里我们以Redis扩展以及Composer来举例。首先将项目需要的扩展等文件提前下载到php目录下，这样构建时就可以从本地复制而无需每次通过网络下载，大大加快镜像构建的速度：</p><div class="code-wrapper"><pre><code class="hljs">wget https://getcomposer.org/composer.phar -O php/composer.pharwget https://pecl.php.net/get/redis-2.2.7.tgz -O php/redis.tgz</code></pre></div><p>php目录下还准备好了php配置文件<code>php.ini</code>以及<code>php-fpm.conf</code>，基础镜像我们选择的是<a href="https://registry.hub.docker.com/_/php/">PHP 5.6-FPM</a>，这同样是一个Debian Jessie镜像。官方比较亲切的在镜像内部准备了一个<code>docker-php-ext-install</code>指令，可以快速安装如GD、PDO等常用扩展。所有支持的扩展名称可以通过在容器内运行<code>docker-php-ext-install</code>获得。</p><p>来看一下Dockerfile</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">FROM</span> php:<span class="hljs-number">5.6</span>-fpm<br><br>ADD php.ini    <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/etc/</span>php/php.ini<br>ADD php-fpm.conf    <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/etc/</span>php-fpm.conf<br><br><span class="hljs-keyword">COPY</span> redis.tgz <span class="hljs-regexp">/home/</span>redis.tgz<br>RUN docker-php-ext-install gd \<br>    &amp;&amp; docker-php-ext-install pdo_mysql \<br>    &amp;&amp; pecl install <span class="hljs-regexp">/home/</span>redis.tgz &amp;&amp; echo <span class="hljs-string">&quot;extension=redis.so&quot;</span> &gt; <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/etc/</span>php<span class="hljs-regexp">/conf.d/</span>redis.ini<br>ADD composer.phar <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>composer<br>RUN chmod <span class="hljs-number">755</span> <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>composer<br><br>WORKDIR /opt<br>RUN usermod -u <span class="hljs-number">1000</span> www-data<br><br>VOLUME [<span class="hljs-string">&quot;/opt&quot;</span>]<br></code></pre></td></tr></table></figure><p>在构建过程中做了这样一些事情：</p><ol><li>复制php和php-fpm配置文件到相应目录</li><li>复制redis扩展源代码到<code>/home</code></li><li>通过<code>docker-php-ext-install</code>安装GD和PDO扩展</li><li>通过<code>pecl</code>安装Redis扩展</li><li>复制composer到镜像作为全局指令</li></ol><p>按照个人习惯，仍然设置<code>/opt</code>目录作为工作目录。</p><p>这里有一个细节，在复制tar包文件时，使用的Docker指令是<code>COPY</code>而不是<code>ADD</code>，这是由于<code>ADD</code>指令会<a href="https://docs.docker.com/reference/builder/#add">自动解压<code>tar</code>文件</a>。</p><p>现在终于可以构建+运行了：</p><div class="code-wrapper"><pre><code class="hljs">docker build -t eva/php ./phpdocker run -p 9000:9000 -v ~/opt:/opt -it eva/php</code></pre></div><p>在大多数情况下，Nginx和PHP所读取的项目源代码都是同一份，因此这里同样挂载本地的<code>~/opt</code>目录，并且绑定9000端口。</p><h3 id="PHP-CLI的实现"><a href="#PHP-CLI的实现" class="headerlink" title="PHP-CLI的实现"></a>PHP-CLI的实现</h3><p>php容器除了运行php-fpm外，还应该作为项目的php cli使用，这样才能保证php版本、扩展以及配置文件保持一致。</p><p>例如在容器内运行Composer，可以通过下面的指令实现：</p><div class="code-wrapper"><pre><code class="hljs">docker run -v $(pwd -P):/opt -it eva/php composer install --dev -vvv</code></pre></div><p>这样在任意目录下运行这行指令，等于动态将当前目录挂载到容器的默认工作目录并运行，这也是PHP容器指定工作目录为<code>/opt</code>的原因。</p><p>同理还可以实现phpunit、npm、gulp等命令行工具在容器内运行。</p><h3 id="Redis容器"><a href="#Redis容器" class="headerlink" title="Redis容器"></a>Redis容器</h3><p>为了方便演示，Redis仅仅作为缓存使用，没有持久化需求，因此Dockerfile仅有一行</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">FROM</span> redis:<span class="hljs-number">3</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="容器的连接"><a href="#容器的连接" class="headerlink" title="容器的连接"></a>容器的连接</h2><p>上面已经将原本在一个容器中运行的服务分拆到多个容器，每个容器只运行单一服务。这样一来容器之间需要能互相通信。Docker容器间通讯的方法有两种，一种是像上文这样将容器端口绑定到一个本地端口，通过端口通讯。另一种则是通过Docker提供的<a href="https://docs.docker.com/userguide/dockerlinks/">Linking功能</a>，在开发环境下，通过Linking通信更加灵活，也能避免端口占用引起的一些问题，比如可以通过下面的方式将Nginx和PHP链接起来：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">docker</span> run -p <span class="hljs-number">9000</span>:<span class="hljs-number">9000</span> -v ~/<span class="hljs-meta">opt</span>:/<span class="hljs-meta">opt</span> --name php -<span class="hljs-keyword">it</span> eva/php<br><span class="hljs-symbol">docker</span> run -p <span class="hljs-number">80</span>:<span class="hljs-number">80</span> -v ~/<span class="hljs-meta">opt</span>:/<span class="hljs-meta">opt</span> -<span class="hljs-keyword">it</span> --link php:php eva/nginx<br></code></pre></td></tr></table></figure><p>在一般的PHP项目中，Nginx需要链接PHP，而PHP又需要链接MySQL，Redis等。为了让容器间互相链接更加容易管理，Docker官方推荐使用<a href="https://docs.docker.com/compose/">Docker-Compose</a>完成这些操作。</p><p>用一行指令完成安装</p><div class="code-wrapper"><pre><code class="hljs">pip install -U docker-compose</code></pre></div><p>然后在Docker项目的根目录下准备一个docker-compose.yml文件，内容为：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">nginx:</span><br><span class="hljs-symbol">    build:</span> ./nginx<br><span class="hljs-symbol">    ports:</span><br>      - <span class="hljs-string">&quot;80:80&quot;</span><br><span class="hljs-symbol">    links:</span><br>      - <span class="hljs-string">&quot;php&quot;</span><br><span class="hljs-symbol">    volumes:</span><br>      - ~/opt:/opt<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">php:</span><br><span class="hljs-symbol">    build:</span> ./php<br><span class="hljs-symbol">    ports:</span><br>      - <span class="hljs-string">&quot;9000:9000&quot;</span><br><span class="hljs-symbol">    links:</span><br>      - <span class="hljs-string">&quot;mysql&quot;</span><br>      - <span class="hljs-string">&quot;redis&quot;</span><br><span class="hljs-symbol">    volumes:</span><br>      - ~/opt:/opt<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">mysql:</span><br><span class="hljs-symbol">    build:</span> ./mysql<br><span class="hljs-symbol">    ports:</span><br>      - <span class="hljs-string">&quot;3306:3306&quot;</span><br><span class="hljs-symbol">    volumes:</span><br>      - ~<span class="hljs-meta-keyword">/opt/</span>data/mysql:<span class="hljs-meta-keyword">/var/</span>lib/mysql<br><span class="hljs-symbol">    environment:</span><br><span class="hljs-symbol">      MYSQL_ROOT_PASSWORD:</span> <span class="hljs-number">123456</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">redis:</span><br><span class="hljs-symbol">    build:</span> ./redis<br><span class="hljs-symbol">    ports:</span><br>      - <span class="hljs-string">&quot;6379:6379&quot;</span><br><br></code></pre></td></tr></table></figure><p>然后运行<code>docker-compose up</code>，就完成了所有的端口绑定、挂载、链接操作。</p><h2 id="更复杂的实例"><a href="#更复杂的实例" class="headerlink" title="更复杂的实例"></a>更复杂的实例</h2><p>上面是一个标准PHP项目在Docker环境下的演进过程，实际项目中一般会集成更多更复杂的服务，但上述基本步骤仍然可以通用。比如<a href="https://github.com/EvaEngine/Dockerfiles">EvaEngine/Dockerfiles</a>是为了运行我的开源项目<a href="http://avnpc.com/pages/eva-engine">EvaEngine</a>准备的基于Docker的开发环境，EvaEngine依赖了队列服务Gearman，缓存服务Memcache、Redis，前端构建工具Gulp、Bower，后端Cli工具Composer、PHPUnit等。具体实现方式可以自行阅读代码。</p><p>经过团队实践，原本大概需要1天时间的环境安装，切换到Docker后只需要运行10余条指令，时间也大幅缩短到3小时以内（大部分时间是在等待下载），最重要的是Docker所构建的环境都是100%一致的，不会有人为失误引起的问题。未来我们会进一步将Docker应用到CI以及生产环境中。</p><p><em>原文地址：<a href="http://avnpc.com/pages/build-php-develop-env-by-docker">Docker构建PHP项目开发环境</a></em></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>转载</tag>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux的du和df命令</title>
    <link href="/2017/04/linux%E7%9A%84du%E5%92%8Cdf%E5%91%BD%E4%BB%A4/"/>
    <url>/2017/04/linux%E7%9A%84du%E5%92%8Cdf%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="这是4月18号的流水账"><a href="#这是4月18号的流水账" class="headerlink" title="这是4月18号的流水账"></a>这是4月18号的流水账</h2><p>今天如往常一样完成一个功能后，把代码推到测试环境，结果 response 有点跟往常不一样：</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">liubin@localhost:~<span class="hljs-comment"># git push test branch</span><br>Counting objects: 18, <span class="hljs-keyword">done</span>.<br>Delta compression using up to 4 threads.<br>Compressing objects: 100% (16/16), <span class="hljs-keyword">done</span>.<br>Writing objects: 100% (18/18), 2.12 KiB | 0 bytes/s, <span class="hljs-keyword">done</span>.<br>Total 18 (delta 11), reused 0 (delta 0)<br>remote: error: file write error (No space left on device)<br>remote: fatal: unable to write sha1 file<br>error: unpack failed: unpack-objects abnormal <span class="hljs-built_in">exit</span><br>To csrtest:/var/gitlab/test.git<br> ! [remote rejected]   branch -&gt; branch (unpacker error)<br>error: failed to push some refs to <span class="hljs-string">&#x27;git@test:/var/gitlab/test.git&#x27;</span><br></code></pre></td></tr></table></figure><p>No space left on device. 意思是测试服务器上没空了呗，上去看一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">liubin@<span class="hljs-built_in">test</span>:~<span class="hljs-comment"># df -h</span><br>Filesystem      Size  Used Avail Use% Mounted on<br>/dev/vda2       289G  274G   16M 100% /<br>tmpfs           939M     0  939M   0% /dev/shm<br>/dev/vda1       985M   93M  842M  10% /boot<br>/dev/vda3       203G  188M  193G   1% /data<br></code></pre></td></tr></table></figure><span id="more"></span><p>果不其然，那应该是缓存文件太多了，去缓存目录看一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">liubin@<span class="hljs-built_in">test</span>:~<span class="hljs-comment"># du -sh</span><br>184G<br></code></pre></td></tr></table></figure><p>那清一清吧。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">liubin@<span class="hljs-built_in">test</span>:~<span class="hljs-comment"># rm -rf ./*</span><br>zsh: sure you want to delete all the files <span class="hljs-keyword">in</span> .../cache/. [yn]? y<br>liubin@<span class="hljs-built_in">test</span>:~<span class="hljs-comment"># ll</span><br>total 0<br></code></pre></td></tr></table></figure><p>清完然后就好使了。</p><p>可是清完后跟之前的数有点对不大上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">liubin@<span class="hljs-built_in">test</span>:~<span class="hljs-comment"># df -h</span><br>Filesystem      Size  Used Avail Use% Mounted on<br>/dev/vda2       289G  208G   66G  76% /<br>tmpfs           939M     0  939M   0% /dev/shm<br>/dev/vda1       985M   93M  842M  10% /boot<br>/dev/vda3       203G  188M  193G   1% /data<br></code></pre></td></tr></table></figure><p><del>我猜可能是虚拟机的存储管理机制的缘故，物理机出现这种情况的话那才奇了怪了，不过我也没兴趣继续深究这个问题。</del></p><p><del>就是记一次流水账，非科普。</del></p><p>需要科普可以去查 <a href="http://man.linuxde.net/">Linux命令大全</a>。</p><h2 id="以下是4月19号的补充"><a href="#以下是4月19号的补充" class="headerlink" title="以下是4月19号的补充"></a>以下是4月19号的补充</h2><p>本以为今天和往常一样，结果跟昨天一样。</p><p><em><strong>测试服务器磁盘又满了。</strong></em></p><p>隐约觉得应该是哪儿溢出了，<code>top</code> 一下果然 php 进程始终99%，又看了下php进程，有一个执行后台计算的脚本，从4月17号下午就已经存在了，<code>sudo kill -9</code> 了之后，结果 <code>df -h</code> 对上了！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">liubin@<span class="hljs-built_in">test</span>:~<span class="hljs-comment"># df -h</span><br>Filesystem      Size  Used Avail Use% Mounted on<br>/dev/vda2       289G   91G  184G  34% /<br>tmpfs           939M     0  939M   0% /dev/shm<br>/dev/vda1       985M   93M  842M  10% /boot<br>/dev/vda3       203G  188M  193G   1% /data<br></code></pre></td></tr></table></figure><p>然后把那个“溢出”的进程在本地复现了之后，想起了昨天的那句：</p><blockquote><p>物理机出现这种情况的话那才奇了怪了。</p></blockquote><p>所以说，还是看看怎么给虚拟机平反吧。毕竟，真相只有一个！</p><p>果不其然，一查就找到了真相，有以下三种情况：</p><blockquote><p><strong>1.预留空间</strong></p><p>为了预防紧急情况，linux ext文件系统会预留部分硬盘空间，具体预留的数值可以通过 <code>tune2fs -l [dev_name] | grep &quot;Reserved block count&quot;</code> 查看到（dev_name是设备名），这里预留的空间会被 <code>df</code> 计算到已用空间中，从而导致 <code>df</code> 和 <code>du</code> 统计不一致。如果需要调整预留空间大小，我们可以使用<code> tune2fs -m [size] [dev_name]</code> 来进行调整。</p></blockquote><blockquote><p><strong>2.幻影文件(phantom file)</strong></p><p><code>du</code>是统计被文件系统记录到的每个文件的大小，然后进行累加得到的大小，这是通过文件系统获取到的。而 <code>df</code> 主要是从超级块（superblock）中读入硬盘使用信息， <code>df</code> 获取到的是磁盘块被使用的情况。当一个文件被删除时，如果有别的进程正在使用它（占有句柄），<br> 这个文件将不会被 <code>du</code> 统计到，但是这个文件被占用的磁盘空间却依然会被 <code>df</code> 统计到。这些文件，以及正在使用这些文件的进程可以通过 <code>lsof | grep deleted</code> 查到。当进程停止或者被 kill 时，这些空间将被释放。</p></blockquote><blockquote><p><strong>3.未统计到的文件</strong></p><p>如果上面两种情况都排除了，但是数据还是不一致，那是怎么回事？这里隐藏着一种情况：当我们将一个目录挂在到一个新的设备（硬盘）上之前，如果这个目录里面已经有数据，那么这一部分数据不会被 <code>du</code> 感知，在文件系统中也看不到这些数据，但是这些数据又是确实占用了磁盘空间，是能够被 <code>df</code> 所统计到的。这时候通过 <code>du</code> / <code>df</code> 统计原设备的空间使用情况，就会发现 <code>df</code> 统计到的比 <code>du</code> 要多。遇到这样的情况时，使用 <code>fuser  -km [directory]</code> 杀死占用该目录的所有进程（小心操作！），然后使用 <code>umount [directory]</code> 将该目录挂载的设备卸载，这时，目录里面原来已有的数据就会出现，我们将其删除之后，再重新挂载设备（<code>mount -t [type] [dev] [directory]</code>）即可。</p></blockquote><p>而发生在我这里的就是第二种情况，文件被删除后，句柄还在被进程占用着，所以导致 <code>du</code> 和 <code>df</code> 意见不统一，kill 掉占用进程后，统计结果就一致了。</p><p>本想写篇流水账凑数，结果还是被强行 push 到探索真相的道路上。</p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>上面说那个“溢出”的进程加引号的原因是，表面上看起来像是溢出的进程，其实是产品经理那天添加了一个计算结果超过100亿行的计算任务，可能等了半天也没见出结果，就把那条记录给删掉了… 然后测试机就一两核 cpu &amp; 2G 内存的虚拟机，两天也没运行完，所以就造成了看似溢出的假象。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redux-saga实践总结及其高级功能在DvaJS中的应用</title>
    <link href="/2017/04/Redux-saga%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%E5%8F%8A%E5%85%B6%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD%E5%9C%A8DvaJS%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2017/04/Redux-saga%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%E5%8F%8A%E5%85%B6%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD%E5%9C%A8DvaJS%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="选择-dvajs"><a href="#选择-dvajs" class="headerlink" title="选择 dvajs"></a>选择 dvajs</h2><p>最近一直忙于公司产品的前端重构，因为之前学习和接触的东西一直以后端为主，使用的语言又是以 PHP 为主，所以对于前端开发使用的语言 ES6 的代码规范和编程风格不太熟悉，对于前端工程化的经验也是几乎为零。虽然 leader 给了充足的学习时间和强大的技术支持，但写代码的就我自己。于是乎我就选择了 <strong>antd+dvajs</strong>，一来框架作者提供的 Demo 可以让我去学习前端的设计思想和代码的编写规范，二来我不需要耗费过多的精力去搭建整个项目的生态。站在巨人的肩上，才能更好更快地拥抱 <strong>react/redux</strong> 全家桶。</p><h2 id="redux-saga"><a href="#redux-saga" class="headerlink" title="redux-saga"></a>redux-saga</h2><h3 id="什么是-saga"><a href="#什么是-saga" class="headerlink" title="什么是 saga"></a>什么是 saga</h3><p>Saga这个名词常被用在CQRS的讨论中，它是指一段在限定上下文（bounded contexts）和聚合（aggregates）之间起协作和路由（coordinates and routes）消息作用的代码。最早被定义在Hector Garcia-Molina和Kenneth Salem的论文”<a href="http://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf">Sagas</a>“中。这篇论文提出了一个saga机制来作为分布式事务的替代品以解决长时间运行的分布式事务（long-running process）的问题。这篇论文认为业务过程经常由很多步骤组成，每个步骤都涉及一个事务，如果将这些事务组成一个分布式事务，就可以实现总体一致（overall consistency）。</p><span id="more"></span><h3 id="redux-saga-中几个抽象的概念："><a href="#redux-saga-中几个抽象的概念：" class="headerlink" title="redux-saga 中几个抽象的概念："></a>redux-saga 中几个抽象的概念：</h3><h4 id="Effect"><a href="#Effect" class="headerlink" title="Effect"></a>Effect</h4><p>Effect 是一个 javascript 对象，通过使用 <code>redux-saga/effects</code> 包里提供的函数来创建，里面包含描述异步操作（Side Effect）的信息，通过 yield 传达给 sagaMiddleware 执行, 我们可以把每一个 Effect 看成一道发送给 middleware 的指令。</p><h4 id="Saga"><a href="#Saga" class="headerlink" title="Saga"></a>Saga</h4><p>所有的 Saga 都是由 Generator 函数实现，所做的实际上是通过组合 Effect，以实现所需的控制流。最简单的例子就是把 yield Effects 一个接一个地放置，就可以让 Effect 按顺序执行。</p><h4 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h4><p>一个 task 就像是一个在后台运行的进程。在基于 redux-saga 的应用程序中，可以同时运行多个 task。通过 <code>fork</code> 函数来创建 task，同时可以使用 <code>cancel</code> 函数来结束 task。</p><h3 id="原生-redux-saga-的使用"><a href="#原生-redux-saga-的使用" class="headerlink" title="原生 redux-saga 的使用"></a>原生 redux-saga 的使用</h3><p>鉴于文档中有详细的解释，这里只做介绍，查看文档建议阅读<a href="https://redux-saga.github.io/redux-saga/index.html">官方英文文档</a>，中文文档一是没有及时更新，导致一些内容在中文文档里没有，另外翻译的水平也不太行，有些地方甚至出现错误的翻译。</p><h4 id="Effect-创建器"><a href="#Effect-创建器" class="headerlink" title="Effect 创建器"></a>Effect 创建器</h4><h5 id="put"><a href="#put" class="headerlink" title="put"></a>put</h5><p>作用和 redux 中的 dispatch 相同。</p><p><code>yield put(&#123; type: &#39;CLICK_BTN&#39; &#125;);</code></p><h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><p>作用和 redux thunk 中的 getState 相同。</p><p><code>const id = yield select(state =&gt; state.id);</code></p><ul><li><em>Ps：saga 最好是自主独立的，不应依赖 Store 的 state。这使得很容易修改 state 实现部分而不影响 Saga 代码。</em></li></ul><h5 id="take"><a href="#take" class="headerlink" title="take"></a>take</h5><p>监听（pulling）一个能匹配指定 pattern 的 action。</p><figure class="highlight javascript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-keyword">yield</span> take(<span class="hljs-string">&#x27;CLICK_BUTTON&#x27;</span>);<br>  <span class="hljs-keyword">yield</span> put(&#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;SHOW_CONGRATULATION&#x27;</span>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>一个简单的日志记录器的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; select, take &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-saga/effects&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">watchAndLog</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">const</span> action = <span class="hljs-keyword">yield</span> take(<span class="hljs-string">&#x27;*&#x27;</span>)<br>    <span class="hljs-keyword">const</span> state = <span class="hljs-keyword">yield</span> select()<br><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;action&#x27;</span>, action)<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;state after&#x27;</span>, state)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="call"><a href="#call" class="headerlink" title="call"></a>call</h5><p>阻塞地调用 saga 或者返回 promise 的函数。</p><p><code>yield call(method, arg1, arg2, ...);</code></p><p>同样支持调用对象方法，可以用下面这种方式，为调用的函数提供一个 this 上下文：</p><p><code>yield call([obj, obj.method], arg1, arg2, ...) // 如同 obj.method(arg1, arg2 ...)</code></p><h5 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h5><p>无阻塞地调用 saga 或者返回 promise 的函数, 返回一个 <a href="https://redux-saga.github.io/redux-saga/docs/api/index.html#task">Task</a> 对象。</p><p><code>yield fork(authorize, username, password)</code></p><h5 id="cancel"><a href="#cancel" class="headerlink" title="cancel"></a>cancel</h5><p>取消之前 fork 的 task。</p><p>下面的例子实现了在登陆过程中，一旦收到<code>LOGOUT </code>，马上终止<code>authorize </code>，然后在任务内部捕获取消错误，并执行内部的清理逻辑。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; isCancelError &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-saga&#x27;</span><br><span class="hljs-keyword">import</span> &#123; take, put, call, fork, cancel &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-saga/effects&#x27;</span><br><span class="hljs-keyword">import</span> Api <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;...&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">authorize</span>(<span class="hljs-params">user, password</span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> token = <span class="hljs-keyword">yield</span> call(Api.authorize, user, password)<br>    <span class="hljs-keyword">yield</span> put(&#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;LOGIN_SUCCESS&#x27;</span>, token&#125;)<br>    <span class="hljs-keyword">return</span> token<br>  &#125; <span class="hljs-keyword">catch</span>(error) &#123;<br>    <span class="hljs-keyword">if</span>(!isCancelError(error))<br>      <span class="hljs-keyword">yield</span> put(&#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;LOGIN_ERROR&#x27;</span>, error&#125;)<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">loginFlow</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123;user, password&#125; = <span class="hljs-keyword">yield</span> take(<span class="hljs-string">&#x27;LOGIN_REQUEST&#x27;</span>)<br>    <span class="hljs-comment">// fork return a Task object</span><br>    <span class="hljs-keyword">const</span> task = <span class="hljs-keyword">yield</span> fork(authorize, user, password)<br>    <span class="hljs-keyword">const</span> action = <span class="hljs-keyword">yield</span> take([<span class="hljs-string">&#x27;LOGOUT&#x27;</span>, <span class="hljs-string">&#x27;LOGIN_ERROR&#x27;</span>])<br>    <span class="hljs-keyword">if</span>(action.type === <span class="hljs-string">&#x27;LOGOUT&#x27;</span>)<br>      <span class="hljs-keyword">yield</span> cancel(task)<br>    <span class="hljs-keyword">yield</span> call(Api.clearItem(<span class="hljs-string">&#x27;token&#x27;</span>))<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><em>Ps-1：在取消任务中出现嵌套的 saga 时，所有的 saga 都会被取消，即取消会向下传播，但未被捕获的错误不会向上冒泡。</em></p></li><li><p><em>Ps-2：取消任务时，saga 中的<code>try...finally</code> 代码块，<code>finally </code> 里的代码会照常执行。</em></p></li><li><p><em>Ps-3：<code>yield cancel(task)</code>是非阻塞的，因此任务一旦取消，就应当尽快完成其清理逻辑。</em></p></li></ul><h4 id="Effect-辅助函数"><a href="#Effect-辅助函数" class="headerlink" title="Effect 辅助函数"></a>Effect 辅助函数</h4><h5 id="takeEvery"><a href="#takeEvery" class="headerlink" title="takeEvery"></a>takeEvery</h5><p>监听（pulling）每个能匹配指定 pattern 的 action。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; takeEvery &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-saga&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">watchFetchData</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">yield</span>* takeEvery(<span class="hljs-string">&#x27;FETCH_REQUESTED&#x27;</span>, fetchData)<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="takeLatest"><a href="#takeLatest" class="headerlink" title="takeLatest"></a>takeLatest</h5><p>监听（pulling）最后一个能匹配指定 pattern 的 action，之前启动的任务如果正在执行中，则会被自动取消。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; takeLatest &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-saga&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">watchFetchData</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">yield</span>* takeLatest(<span class="hljs-string">&#x27;FETCH_REQUESTED&#x27;</span>, fetchData)<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a>throttle</h5><p>节流器。监听到一个匹配的 action 后，忽略一段时间内匹配到的其他 action，但是保留这段时间中最后一个匹配到的 action。<br><code>yield throttle(1000, &#39;FETCH_AUTOCOMPLETE&#39;, fetchAutocomplete)</code></p><h4 id="Effect-组合器（combinators）"><a href="#Effect-组合器（combinators）" class="headerlink" title="Effect 组合器（combinators）"></a>Effect 组合器（combinators）</h4><h5 id="race"><a href="#race" class="headerlink" title="race"></a>race</h5><p>在多个 Effect 之间执行一个 race（类似 <code>Promise.race([...])</code> 的行为）。</p><p>下面的示例演示了触发一个远程的获取请求，并且限制了 1 秒内响应，否则作超时处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; race, take, put &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-saga/effects&#x27;</span><br><span class="hljs-keyword">import</span> &#123; delay &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux-saga&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">fetchPostsWithTimeout</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> &#123;posts, timeout&#125; = <span class="hljs-keyword">yield</span> race(&#123;<br>    <span class="hljs-attr">posts</span>: call(fetchApi, <span class="hljs-string">&#x27;/posts&#x27;</span>),<br>    <span class="hljs-attr">timeout</span>: call(delay, <span class="hljs-number">1000</span>)<br>  &#125;)<br><br>  <span class="hljs-keyword">if</span> (posts)<br>    put(&#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;POSTS_RECEIVED&#x27;</span>, posts&#125;)<br>  <span class="hljs-keyword">else</span><br>    put(&#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;TIMEOUT_ERROR&#x27;</span>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="effects"><a href="#effects" class="headerlink" title="[...effects]"></a><code>[...effects]</code></h5><p>并行执行多个 Effect，然后等待所有 Effect 完成（类似 <code>Promise.all([...]</code>) 的行为）。</p><p>下面的实例并行执行了 2 个阻塞调用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; fetchCustomers, fetchProducts &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;...&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">mySaga</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [customers, products] = <span class="hljs-keyword">yield</span> [<br>    call(fetchCustomers),<br>    call(fetchProducts)<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="redux-saga-高级功能在-dvajs-中的应用"><a href="#redux-saga-高级功能在-dvajs-中的应用" class="headerlink" title="redux-saga 高级功能在 dvajs 中的应用"></a>redux-saga 高级功能在 dvajs 中的应用</h3><p>在 dvajs 中，作者选择了 redux-saga 处理异步操作。而对于异步处理的问题，目前比较流行的通用解决方案如下：</p><ul><li><a href="https://github.com/gaearon/redux-thunk">redux-thunk</a></li><li><a href="https://github.com/acdlite/redux-promise">redux-promise</a></li><li><a href="https://github.com/yelouafi/redux-saga">redux-saga</a></li></ul><p>前两个方案一个是支持函数形式的action，另一个是支持 promise 形式的 action，但是有一个共同的问题就是：都改变了action的含义，使得action的含义不那么纯粹了。</p><p>redux-saga则以优雅而强大的方式，把业务逻辑都放在saga中，通过监听 action 来执行有副作用的 task，并且引入了 <a href="http://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf">Sagas</a> 的机制和 generator 的特性，让 reducer, action 和 component 都很纯粹地干他们原本需要干的事情。</p><p>但是，在目前的 dvajs 中的 effects 默认是 <code>takeEvery </code>（<a href="mailto:&#x64;&#118;&#97;&#64;&#49;&#46;&#x32;&#46;&#x31;">&#x64;&#118;&#97;&#64;&#49;&#46;&#x32;&#46;&#x31;</a>），虽然文档中没有关于其他类型 effects 的说明，但在 <a href="https://github.com/dvajs/dva/blob/7f2575a/test/effects-test.js#L215-L222">源码</a> 中我们可以看到，作者其实是提供了使用方法的。</p><p>通过下面的方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> watcher = <span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> [fn, &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;watcher&#x27;</span> &#125;];<br><span class="hljs-keyword">const</span> takeLatest = <span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> [fn, &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;takeLatest&#x27;</span> &#125;];<br><span class="hljs-keyword">const</span> throttle = <span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> [fn, &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;throttle&#x27;</span> &#125;];<br><br>app.model(&#123;<br>  <span class="hljs-attr">effects</span>: &#123;<br>    <span class="hljs-attr">addRemote</span>: watcher(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params">action, &#123; take, put, call &#125;</span>) </span>&#123;<br>      <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">const</span> &#123; payload &#125; = <span class="hljs-keyword">yield</span> take(<span class="hljs-string">&#x27;add&#x27;</span>);<br>        <span class="hljs-keyword">yield</span> call(delay, <span class="hljs-number">100</span>);<br>        <span class="hljs-keyword">yield</span> put(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;add&#x27;</span>, payload &#125;);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>就可以使用所有原生 redux-saga 中的控制方式了。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redux</tag>
      
      <tag>DvaJS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>查看当前环境虚拟技术 &amp; .bash_profile立即生效方式</title>
    <link href="/2017/03/%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83%E8%99%9A%E6%8B%9F%E6%8A%80%E6%9C%AF-bash-profile%E7%AB%8B%E5%8D%B3%E7%94%9F%E6%95%88%E6%96%B9%E5%BC%8F/"/>
    <url>/2017/03/%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E7%8E%AF%E5%A2%83%E8%99%9A%E6%8B%9F%E6%8A%80%E6%9C%AF-bash-profile%E7%AB%8B%E5%8D%B3%E7%94%9F%E6%95%88%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="Easy-way-to-determine-virtualization-technology"><a href="#Easy-way-to-determine-virtualization-technology" class="headerlink" title="Easy way to determine virtualization technology"></a>Easy way to determine virtualization technology</h2><p><code>dmidecode -s system-product-name</code></p><h3 id="Virtualization-technolgies"><a href="#Virtualization-technolgies" class="headerlink" title="Virtualization technolgies"></a>Virtualization technolgies</h3><h4 id="VMware-Workstation"><a href="#VMware-Workstation" class="headerlink" title="VMware Workstation"></a>VMware Workstation</h4><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">root@localhost:~<span class="hljs-comment"># dmidecode -s system-product-name</span><br>VMware Virtual Platform<br></code></pre></td></tr></table></figure><h4 id="VirtualBox"><a href="#VirtualBox" class="headerlink" title="VirtualBox"></a>VirtualBox</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@localhost:~<span class="hljs-comment"># dmidecode -s system-product-name</span><br>VirtualBox<br></code></pre></td></tr></table></figure><span id="more"></span><h4 id="Qemu-with-KVM"><a href="#Qemu-with-KVM" class="headerlink" title="Qemu with KVM"></a>Qemu with KVM</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@localhost:~<span class="hljs-comment"># dmidecode -s system-product-name</span><br>KVM<br></code></pre></td></tr></table></figure><h4 id="Qemu-emulated"><a href="#Qemu-emulated" class="headerlink" title="Qemu (emulated)"></a>Qemu (emulated)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@localhost:~<span class="hljs-comment"># dmidecode -s system-product-name</span><br>Bochs<br></code></pre></td></tr></table></figure><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><p><a href="http://unix.stackexchange.com/questions/89714/easy-way-to-determine-virtualization-technology">linux - Easy way to determine virtualization technology - Unix &amp; Linux Stack Exchange</a></p><h2 id="修改-bash-profile立即生效的三种方法"><a href="#修改-bash-profile立即生效的三种方法" class="headerlink" title="修改.bash_profile立即生效的三种方法"></a>修改.bash_profile立即生效的三种方法</h2><ol><li><p><code>. .bash_profile</code></p></li><li><p><code>source .bash_profile</code></p></li><li><p><code>exec bash --login</code></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS 7 中静态 IP 以及 DNS 的配置</title>
    <link href="/2017/03/CentOS-7-%E4%B8%AD%E9%9D%99%E6%80%81-IP-%E4%BB%A5%E5%8F%8A-DNS-%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <url>/2017/03/CentOS-7-%E4%B8%AD%E9%9D%99%E6%80%81-IP-%E4%BB%A5%E5%8F%8A-DNS-%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="设置静态-IP"><a href="#设置静态-IP" class="headerlink" title="设置静态 IP"></a>设置静态 IP</h2><h3 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h3><p><code>root@localhost:~# vim /etc/sysconfig/network-scripts/ifcfg-enp0s3</code></p><h3 id="修改以下配置项"><a href="#修改以下配置项" class="headerlink" title="修改以下配置项"></a>修改以下配置项</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">BOOTPROTO=<span class="hljs-string">&quot;static&quot;</span> <span class="hljs-comment">#dhcp改为static </span><br>ONBOOT=<span class="hljs-string">&quot;yes&quot;</span> <span class="hljs-comment">#开机启用本配置</span><br>IPADDR=192.168.5.192 <span class="hljs-comment">#静态IP</span><br>GATEWAY=192.168.4.1 <span class="hljs-comment">#默认网关</span><br>NETMASK=255.255.252.0 <span class="hljs-comment">#子网掩码</span><br></code></pre></td></tr></table></figure><h3 id="修改后的配置"><a href="#修改后的配置" class="headerlink" title="修改后的配置"></a>修改后的配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@localhost:~<span class="hljs-comment"># cat /etc/sysconfig/network-scripts/ifcfg-enp0s3</span><br>TYPE=<span class="hljs-string">&quot;Ethernet&quot;</span><br>BOOTPROTO=<span class="hljs-string">&quot;static&quot;</span><br>DEFROUTE=<span class="hljs-string">&quot;yes&quot;</span><br>PEERDNS=<span class="hljs-string">&quot;yes&quot;</span><br>PEERROUTES=<span class="hljs-string">&quot;yes&quot;</span><br>IPV4_FAILURE_FATAL=<span class="hljs-string">&quot;no&quot;</span><br>IPV6INIT=<span class="hljs-string">&quot;yes&quot;</span><br>IPV6_AUTOCONF=<span class="hljs-string">&quot;yes&quot;</span><br>IPV6_DEFROUTE=<span class="hljs-string">&quot;yes&quot;</span><br>IPV6_PEERDNS=<span class="hljs-string">&quot;yes&quot;</span><br>IPV6_PEERROUTES=<span class="hljs-string">&quot;yes&quot;</span><br>IPV6_FAILURE_FATAL=<span class="hljs-string">&quot;no&quot;</span><br>IPV6_ADDR_GEN_MODE=<span class="hljs-string">&quot;stable-privacy&quot;</span><br>NAME=<span class="hljs-string">&quot;enp0s3&quot;</span><br>UUID=<span class="hljs-string">&quot;9281a4f6-b04e-4007-8af0-b05a69e6a5aa&quot;</span><br>DEVICE=<span class="hljs-string">&quot;enp0s3&quot;</span><br>ONBOOT=<span class="hljs-string">&quot;yes&quot;</span><br>IPADDR=192.168.5.192<br>GATEWAY=192.168.4.1<br>NETMASK=255.255.252.0<br></code></pre></td></tr></table></figure><span id="more"></span><h3 id="重启网络服务"><a href="#重启网络服务" class="headerlink" title="重启网络服务"></a>重启网络服务</h3><p><code>root@localhost:~# systemctl restart network.service</code></p><h3 id="查看修改后的网络信息"><a href="#查看修改后的网络信息" class="headerlink" title="查看修改后的网络信息"></a>查看修改后的网络信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@localhost:~<span class="hljs-comment"># ip addr</span><br>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1<br>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>    inet 127.0.0.1/8 scope host lo<br>       valid_lft forever preferred_lft forever<br>    inet6 ::1/128 scope host<br>       valid_lft forever preferred_lft forever<br>2: enp0s3: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000<br>    link/ether 08:00:27:79:22:ab brd ff:ff:ff:ff:ff:ff<br>    inet 192.168.5.192/22 brd 192.168.7.255 scope global enp0s3<br>       valid_lft forever preferred_lft forever<br>    inet6 fe80::3723:8466:a91:fc59/64 scope link<br>       valid_lft forever preferred_lft forever<br></code></pre></td></tr></table></figure><h2 id="配置-DNS"><a href="#配置-DNS" class="headerlink" title="配置 DNS"></a>配置 DNS</h2><p>Red Hat Enterprise Linux 7 与 CentOS 7 中默认的网络服务由 NetworkManager 提供，这是动态控制及配置网络的守护进程，它用于保持当前网络设备及连接处于工作状态，同时也支持传统的 ifcfg 类型的配置文件。</p><p>因此在 CentOS 7 中，手工设置 <code>/etc/resolv.conf</code> 里的 DNS，过了一会，发现被系统重新覆盖或者清除了。</p><p>NetworkManager 可以用于以下类型的连接：Ethernet，VLANS，Bridges，Bonds，Teams，Wi-Fi，mobile boradband（如移动3G）以及 IP-over-InfiniBand。针对与这些网络类型，NetworkManager 可以配置他们的网络别名，IP 地址，静态路由，DNS，VPN连接以及很多其它的特殊参数。</p><p>可以用命令行工具 nmcli 来控制 NetworkManager。</p><h3 id="验证网络管理器服务的状态"><a href="#验证网络管理器服务的状态" class="headerlink" title="验证网络管理器服务的状态"></a>验证网络管理器服务的状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@localhost:~<span class="hljs-comment"># systemctl status NetworkManager.service</span><br>● NetworkManager.service - Network Manager<br>   Loaded: loaded (/usr/lib/systemd/system/NetworkManager.service; enabled; vendor preset: enabled)<br>   Active: active (running) since Mon 2017-03-19 13:22:05 CST; 8min ago<br>     Docs: man:NetworkManager(8)<br> Main PID: 626 (NetworkManager)<br>   CGroup: /system.slice/NetworkManager.service<br>           └─626 /usr/sbin/NetworkManager --no-daemon<br></code></pre></td></tr></table></figure><h3 id="显示设备状态"><a href="#显示设备状态" class="headerlink" title="显示设备状态"></a>显示设备状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@localhost:~<span class="hljs-comment"># nmcli device status</span><br>DEVICE  TYPE      STATE      CONNECTION<br>enp0s3  ethernet  connected  enp0s3<br>lo      loopback  unmanaged  --<br></code></pre></td></tr></table></figure><h3 id="显示当前连接-包括不活动的"><a href="#显示当前连接-包括不活动的" class="headerlink" title="显示当前连接(包括不活动的)"></a>显示当前连接(包括不活动的)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@localhost:~<span class="hljs-comment"># nmcli connection show</span><br>NAME    UUID                                  TYPE            DEVICE<br>enp0s3  9281a4f6-b04e-4007-8af0-b05a69e6a5aa  802-3-ethernet  enp0s3<br></code></pre></td></tr></table></figure><h3 id="添加-DNS-设置到指定连接中"><a href="#添加-DNS-设置到指定连接中" class="headerlink" title="添加 DNS 设置到指定连接中"></a>添加 DNS 设置到指定连接中</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@localhost:~<span class="hljs-comment"># nmcli connection modify &quot;enp0s3&quot; ipv4.dns 8.8.8.8</span><br>root@localhost:~<span class="hljs-comment"># nmcli connection modify &quot;enp0s3&quot; +ipv4.dns 223.5.5.5</span><br>root@localhost:~<span class="hljs-comment"># nmcli connection modify &quot;enp0s3&quot; +ipv4.dns 223.6.6.6</span><br></code></pre></td></tr></table></figure><h3 id="将配置生效"><a href="#将配置生效" class="headerlink" title="将配置生效"></a>将配置生效</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@localhost:~<span class="hljs-comment"># nmcli connection up enp0s3</span><br>Connection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/3)<br></code></pre></td></tr></table></figure><h3 id="查看网络接口属性"><a href="#查看网络接口属性" class="headerlink" title="查看网络接口属性"></a>查看网络接口属性</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">root@localhost:~<span class="hljs-comment"># nmcli dev show enp0s3</span><br>GENERAL.DEVICE:                         enp0s3<br>GENERAL.TYPE:                           ethernet<br>GENERAL.HWADDR:                         08:00:27:79:22:AB<br>GENERAL.MTU:                            1500<br>GENERAL.STATE:                          100 (connected)<br>GENERAL.CONNECTION:                     enp0s3<br>GENERAL.CON-PATH:                       /org/freedesktop/NetworkManager/ActiveConnection/3<br>WIRED-PROPERTIES.CARRIER:               on<br>IP4.ADDRESS[1]:                         192.168.5.192/22<br>IP4.GATEWAY:                            192.168.4.1<br>IP4.DNS[1]:                             8.8.8.8<br>IP4.DNS[2]:                             223.5.5.5<br>IP4.DNS[3]:                             223.6.6.6<br>IP6.ADDRESS[1]:                         fe80::3723:8466:a91:fc59/64<br>IP6.GATEWAY:<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rel=noopener是什么</title>
    <link href="/2017/03/rel-noopener%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/2017/03/rel-noopener%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h2 id="问题的出现"><a href="#问题的出现" class="headerlink" title="问题的出现"></a>问题的出现</h2><p>昨晚上用<a href="http://eslint.org/">ESLint</a>检查代码时,出现了这样一行错误：</p><blockquote><p>Using target=”_blank” without rel=”noopener noreferrer” is a security risk: see <a href="https://mathiasbynens.github.io/rel-noopener">https://mathiasbynens.github.io/rel-noopener</a>  react/jsx-no-target-blank</p></blockquote><p>当然加上<code>rel=&quot;noopener noreferrer&quot;</code>之后报错就没有了，可问题是：<strong>what’s this?</strong></p><h2 id="关于rel"><a href="#关于rel" class="headerlink" title="关于rel"></a>关于rel</h2><p>rel是relationship的缩写，用于指定当前文档与href链接的文档的关系（顺便一说，rev属性已在HTML5中废弃）。<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/a">MDN</a>中如此描述：</p><blockquote><p><strong>rel</strong></p><p>对于锚点来说，rel具有href的属性， 该属性指定了目标对象到链接对象的关系。该值是空格分隔的列表关系值。 该值和语义可能将会被一些权威文档编者赋予不同的含义。 在默认的情况下，如果没有其它定义，是无效的，只有在 href 存在的情况下，使用该属性。</p></blockquote><span id="more"></span><p>并且在<code>target </code>属性后面写到：</p><blockquote><p><strong>注意：</strong>使用target时，考虑添加 rel=”noopener norefferrer” 以防止针对 window.opener API 的恶意行为。</p></blockquote><p>由此看来，写上这条属性的好处首先是让链接的语义更加明确，语义明确后，自然是搜索引擎友好，然后还可以提升网页的安全性。</p><h2 id="问题究竟是什么"><a href="#问题究竟是什么" class="headerlink" title="问题究竟是什么"></a>问题究竟是什么</h2><p>关于<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/opener">window.opener</a>，MDN里有这么一句：</p><blockquote><p><strong>备注</strong></p><p>如果当前窗口是由另一个窗口打开的, window.opener保留了那个窗口的引用. 如果当前窗口不是由其他窗口打开的, 则该属性返回 null.</p></blockquote><p>我想问题大概就是在这里吧，链接到信任的站点自然可以灵活地使用，可是一旦链接到钓鱼网站，这个网站可以做什么你总是难以预料。<strong>但总的来说，这种行为的潜在风险是远远大于好处的。</strong></p><h2 id="接下来该怎么做"><a href="#接下来该怎么做" class="headerlink" title="接下来该怎么做"></a>接下来该怎么做</h2><p>对于<code>rel=&quot;noopener&quot;</code>这个属性，在Chrome 49+、Opera 36+中可以将window.opener设置为null，但如果浏览器是比较老的版本，实际上要使用<code>rel=&quot;noopener norefferrer&quot;</code>去完整覆盖，将HTTP头部Referer属性也禁用掉。</p><p>其实我个人还是偏向于听从最开始那篇文章里的建议:</p><blockquote><p>Don’t use target=_blank (or any other target that opens a new navigation context), especially for links in user-generated content, unless you have <a href="https://css-tricks.com/use-target_blank/">a good reason to</a>.</p></blockquote><p>所以说，尤其是网站用来对外提供给用户使用的情况下，请不要低估这个问题，更没有理由去忽视这个问题。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
      <tag>安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用正则表达式大全</title>
    <link href="/2017/02/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%A4%A7%E5%85%A8/"/>
    <url>/2017/02/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%A4%A7%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="一、数字格式"><a href="#一、数字格式" class="headerlink" title="一、数字格式"></a>一、数字格式</h2><ul><li>数字：^[0-9]*$</li><li>n位的数字：^\d{n}$</li><li>至少n位的数字：^\d{n,}$</li><li>m-n位的数字：^\d{m,n}$</li><li>零和非零开头的数字：^(0|[1-9][0-9]*)$</li><li>非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$</li><li>带1-2位小数的正数或负数：^(-)?\d+(.\d{1,2})?$</li><li>正数、负数、和小数：^(-|+)?\d+(.\d+)?$</li><li>有两位小数的正实数：^[0-9]+(.[0-9]{2})?$</li><li>有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$</li><li>非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]<em>){1,3}$ 或 ^+?[1-9][0-9]</em>$</li><li>非零的负整数：^-[1-9][]0-9″*$ 或 ^-[1-9]\d*$</li><li>非负整数：^\d+$ 或 ^[1-9]\d*|0$</li><li>非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$</li><li>非负- 浮点数：^\d+(.\d+)?$ 或 ^[1-9]\d<em>.\d</em>|0.\d*[1-9]\d*|0?.0+|0$</li><li>非正浮点数：^((-\d+(.\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\d<em>.\d</em>|0.\d*[1-9]\d*))|0?.0+|0$</li><li>正浮点数：^[1-9]\d<em>.\d</em>|0.\d*[1-9]\d*$ 或 ^(([0-9]+.[0-9]<em>[1-9][0-9]</em>)|([0-9]<em>[1-9][0-9]<em>.[0-9]+)|([0-9]</em>[1-9][0-9]</em>))$</li><li>负浮点数：^-([1-9]\d<em>.\d</em>|0.\d*[1-9]\d*)$ 或 ^(-(([0-9]+.[0-9]<em>[1-9][0-9]</em>)|([0-9]<em>[1-9][0-9]<em>.[0-9]+)|([0-9]</em>[1-9][0-9]</em>)))$</li><li>浮点数：^(-?\d+)(.\d+)?$ 或 ^-?([1-9]\d<em>.\d</em>|0.\d*[1-9]\d*|0?.0+|0)$</li></ul><span id="more"></span><h2 id="二、校验字符的表达式"><a href="#二、校验字符的表达式" class="headerlink" title="二、校验字符的表达式"></a>二、校验字符的表达式</h2><ul><li>汉字：^[\u4e00-\u9fa5]{0,}$</li><li>英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$</li><li>长度为3-20的所有字符：^.{3,20}$</li><li>由26个英文字母组成的字符串：^[A-Za-z]+$</li><li>由26个大写英文字母组成的字符串：^[A-Z]+$</li><li>由26个小写英文字母组成的字符串：^[a-z]+$</li><li>由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$</li><li>由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$</li><li>中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$</li><li>中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$</li><li>可以输入含有^%&amp;’,;=?$\”等字符：[^%&amp;’,;=?$\x22]+</li><li>禁止输入含有<del>的字符：[^</del>\x22]+</li></ul><h2 id="三、特殊需求表达式"><a href="#三、特殊需求表达式" class="headerlink" title="三、特殊需求表达式"></a>三、特殊需求表达式</h2><ul><li>Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)<em>.\w+([-.]\w+)</em>$</li><li>域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?</li><li>InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=]*)?$</li><li>手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$</li><li>电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^($$\d{3,4}-)|\d{3.4}-)?\d{7,8}$</li><li>国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7}</li><li>身份证号(15位、18位数字)：^\d{15}|\d{18}$</li><li>短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$</li><li>帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$</li><li>密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$</li><li>强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.<em>\d)(?=.</em>[a-z])(?=.*[A-Z]).{8,10}$</li><li>日期格式：^\d{4}-\d{1,2}-\d{1,2}</li><li>一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$</li><li>一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$</li><li>钱的输入格式：<ul><li>有四种钱的表示形式我们可以接受:”10000.00″ 和 “10,000.00″, 和没有 “分” 的 “10000″ 和 “10,000″：^[1-9][0-9]*$</li><li>这表示任意一个不以0开头的数字，但是，这也意味着一个字符”0″不通过，所以我们采用下面的形式：^(0|[1-9][0-9]*)$</li><li>一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$</li><li>这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉，因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$</li><li>必须说明的是，小数点后面至少应该有1位数，所以”10.”是不通过的，但是 “10″ 和 “10.2″ 是通过的：^[0-9]+(.[0-9]{2})?$</li><li>这样我们规定小数点后面必须有两位，如果你认为太苛刻了，可以这样：^[0-9]+(.[0-9]{1,2})?$</li><li>这样就允许用户只写一位小数。下面我们该考虑数字中的逗号了，我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$</li><li>1到3个数字，后面跟着任意个 逗号+3个数字，逗号成为可选，而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$</li><li>备注：这就是最终结果了，别忘了”+”可以用”*”替代。如果你觉得空字符串也可以接受的话(奇怪，为什么?)最后，别忘了在用函数时去掉去掉那个反斜杠，一般的错误都在这里</li></ul></li><li>xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\.[x|X][m|M][l|L]$</li><li>中文字符的正则表达式：[\u4e00-\u9fa5]</li><li>双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))</li><li>空白行的正则表达式：\n\s*\r (可以用来删除空白行)</li><li>HTML标记的正则表达式：&lt;(\S*?)[^&gt;]<em>&gt;.</em>?|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)</li><li>首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</li><li>腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)</li><li>中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字)</li><li>IP地址：((?:(?:25[0-5]|2[0-4]\d|[01]?\d?\d)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d?\d)) </li></ul><p><em>原文地址：<a href="http://www.cnblogs.com/zxin/archive/2013/01/26/2877765.html">http://zxin.cnblogs.com/</a></em></p>]]></content>
    
    
    <categories>
      
      <category>Common</category>
      
    </categories>
    
    
    <tags>
      
      <tag>转载</tag>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2017/01/hello-world/"/>
    <url>/2017/01/hello-world/</url>
    
    <content type="html"><![CDATA[<p><em><strong>欢迎！我白天是个程序员，晚上就是个有抱负的演员。这是我的博客。我住在天朝的帝都，有条叫做 Jack 的狗。</strong></em></p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
