

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Liu Bin">
  <meta name="keywords" content="">
  
    <meta name="description" content="本文是我花了五天时间，一点一点看完的，里面的代码自己也跟着文章一行行写完，调试，精读，压测，项目最终放在了这里。整个学习过程充斥着疑惑、兴奋和震撼，就连下班路上我都在感叹“php居然还可以这样写”，期间还经历了严重的肠胃炎，所以，这篇伟大的文章对我意义非凡，故此记录。  PHP5.5一个比较好的新功能是加入了对迭代生成器和协程的支持.对于生成器,PHP的文档和各种其他的博客文章已经有了非常详细的">
<meta property="og:type" content="article">
<meta property="og:title" content="在PHP中使用协程实现多任务调度">
<meta property="og:url" content="https://liubin92.github.io/2017/08/%E5%9C%A8PHP%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8D%8F%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/index.html">
<meta property="og:site_name" content="liubin&#39;s blog">
<meta property="og:description" content="本文是我花了五天时间，一点一点看完的，里面的代码自己也跟着文章一行行写完，调试，精读，压测，项目最终放在了这里。整个学习过程充斥着疑惑、兴奋和震撼，就连下班路上我都在感叹“php居然还可以这样写”，期间还经历了严重的肠胃炎，所以，这篇伟大的文章对我意义非凡，故此记录。  PHP5.5一个比较好的新功能是加入了对迭代生成器和协程的支持.对于生成器,PHP的文档和各种其他的博客文章已经有了非常详细的">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2017-08-02T10:55:46.000Z">
<meta property="article:modified_time" content="2022-01-24T02:14:23.285Z">
<meta property="article:author" content="Liu Bin">
<meta property="article:tag" content="转载">
<meta property="article:tag" content="PHP">
<meta name="twitter:card" content="summary_large_image">
  
  
  <title>在PHP中使用协程实现多任务调度 - liubin&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"liubin92.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.0.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="在PHP中使用协程实现多任务调度">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      Liu Bin
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2017-08-02 18:55" pubdate>
        2017年8月2日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  

  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">在PHP中使用协程实现多任务调度</h1>
            
            <div class="markdown-body">
              <blockquote>
<p>本文是我花了五天时间，一点一点看完的，里面的代码自己也跟着文章一行行写完，调试，精读，压测，项目最终放在了<a target="_blank" rel="noopener" href="https://github.com/liubin92/cooperative-multitasking">这里</a>。整个学习过程充斥着疑惑、兴奋和震撼，就连下班路上我都在感叹“php居然还可以这样写”，期间还经历了严重的肠胃炎，所以，这篇伟大的文章对我意义非凡，故此记录。</p>
</blockquote>
<p>PHP5.5一个比较好的新功能是加入了对迭代生成器和协程的支持.对于生成器,PHP的文档和各种其他的博客文章已经有了非常详细的讲解.协程相对受到的关注就少了,因为协程虽然有很强大的功能但相对比较复杂, 也比较难被理解,解释起来也比较困难.</p>
<p>这篇文章将尝试通过介绍如何使用协程来实施任务调度, 来解释在PHP中的协程.</p>
<p>我将在前三节做一个简单的背景介绍.如果你已经有了比较好的基础,可以直接跳到“协同多任务处理”一节.</p>
<span id="more"></span>

<h2 id="迭代生成器"><a href="#迭代生成器" class="headerlink" title="迭代生成器"></a>迭代生成器</h2><p>(迭代)生成器也是一个函数,不同的是这个函数的返回值是依次返回,而不是只返回一个单独的值.或者,换句话说,生成器使你能更方便的实现了迭代器接口.下面通过实现一个xrange函数来简单说明：</p>
<figure class="highlight php"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">xrange</span>(<span class="hljs-params"><span class="hljs-variable">$start</span>, <span class="hljs-variable">$end</span>, <span class="hljs-variable">$step</span> = <span class="hljs-number">1</span></span>) </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span> = <span class="hljs-variable">$start</span>; <span class="hljs-variable">$i</span> &lt;= <span class="hljs-variable">$end</span>; <span class="hljs-variable">$i</span> += <span class="hljs-variable">$step</span>) &#123;<br>        <span class="hljs-keyword">yield</span> <span class="hljs-variable">$i</span>;<br>    &#125;<br>&#125;<br> <br><span class="hljs-keyword">foreach</span> (xrange(<span class="hljs-number">1</span>, <span class="hljs-number">1000000</span>) <span class="hljs-keyword">as</span> <span class="hljs-variable">$num</span>) &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-variable">$num</span>, <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面这个xrange()函数提供了和PHP的内建函数range()一样的功能.但是不同的是range()函数返回的是一个包含值从1到100万0的数组(注：请查看手册). 而xrange()函数返回的是依次输出这些值的一个迭代器, 而不会真正以数组形式返回.</p>
<p>这种方法的优点是显而易见的.它可以让你在处理大数据集合的时候不用一次性的加载到内存中.甚至你可以处理无限大的数据流.</p>
<p>当然,也可以不同通过生成器来实现这个功能,而是可以通过继承Iterator接口实现.但通过使用生成器实现起来会更方便,不用再去实现iterator接口中的5个方法了.</p>
<h2 id="生成器为可中断的函数"><a href="#生成器为可中断的函数" class="headerlink" title="生成器为可中断的函数"></a>生成器为可中断的函数</h2><p>要从生成器认识协程, 理解它内部是如何工作是非常重要的: 生成器是一种可中断的函数, 在它里面的yield构成了中断点.</p>
<p>还是看上面的例子, 调用xrange(1,1000000)的时候, xrange()函数里代码其实并没有真正地运行. 它只是返回了一个迭代器：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$range</span> = xrange(<span class="hljs-number">1</span>, <span class="hljs-number">1000000</span>);<br>var_dump(<span class="hljs-variable">$range</span>); <span class="hljs-comment">// object(Generator)#1</span><br>var_dump(<span class="hljs-variable">$range</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Iterator</span>); <span class="hljs-comment">// bool(true)</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>

<p>这也解释了为什么xrange叫做迭代生成器, 因为它返回一个迭代器, 而这个迭代器实现了Iterator接口.</p>
<p>调用迭代器的方法一次, 其中的代码运行一次.例如, 如果你调用$range-&gt;rewind(), 那么xrange()里的代码就会运行到控制流第一次出现yield的地方. 而函数内传递给yield语句的返回值可以通过$range-&gt;current()获取.</p>
<p>为了继续执行生成器中yield后的代码, 你就需要调用$range-&gt;next()方法. 这将再次启动生成器, 直到下一次yield语句出现. 因此,连续调用next()和current()方法, 你就能从生成器里获得所有的值, 直到再没有yield语句出现.</p>
<p>对xrange()来说, 这种情形出现在$i超过$end时. 在这中情况下, 控制流将到达函数的终点,因此将不执行任何代码.一旦这种情况发生,vaild()方法将返回假, 这时迭代结束.</p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协程的支持是在迭代生成器的基础上, 增加了可以回送数据给生成器的功能(调用者发送数据给被调用的生成器函数). 这就把生成器到调用者的单向通信转变为两者之间的双向通信.</p>
<p>传递数据的功能是通过迭代器的send()方法实现的. 下面的logger()协程是这种通信如何运行的例子：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logger</span>(<span class="hljs-params"><span class="hljs-variable">$fileName</span></span>) </span>&#123;<br>    <span class="hljs-variable">$fileHandle</span> = fopen(<span class="hljs-variable">$fileName</span>, <span class="hljs-string">&#x27;a&#x27;</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        fwrite(<span class="hljs-variable">$fileHandle</span>, <span class="hljs-keyword">yield</span> . <span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>&#125;<br> <br><span class="hljs-variable">$logger</span> = logger(<span class="hljs-keyword">__DIR__</span> . <span class="hljs-string">&#x27;/log&#x27;</span>);<br><span class="hljs-variable">$logger</span>-&gt;send(<span class="hljs-string">&#x27;Foo&#x27;</span>);<br><span class="hljs-variable">$logger</span>-&gt;send(<span class="hljs-string">&#x27;Bar&#x27;</span>)<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>

<p>正如你能看到,这儿yield没有作为一个语句来使用, 而是用作一个表达式, 即它能被演化成一个值. 这个值就是调用者传递给send()方法的值. 在这个例子里, yield表达式将首先被”Foo”替代写入Log, 然后被”Bar”替代写入Log.</p>
<p>上面的例子里演示了yield作为接受者, 接下来我们看如何同时进行接收和发送的例子：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">gen</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-variable">$ret</span> = (<span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;yield1&#x27;</span>);<br>    var_dump(<span class="hljs-variable">$ret</span>);<br>    <span class="hljs-variable">$ret</span> = (<span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;yield2&#x27;</span>);<br>    var_dump(<span class="hljs-variable">$ret</span>);<br>&#125;<br> <br><span class="hljs-variable">$gen</span> = gen();<br>var_dump(<span class="hljs-variable">$gen</span>-&gt;current());    <span class="hljs-comment">// string(6) &quot;yield1&quot;</span><br>var_dump(<span class="hljs-variable">$gen</span>-&gt;send(<span class="hljs-string">&#x27;ret1&#x27;</span>)); <span class="hljs-comment">// string(4) &quot;ret1&quot;   (the first var_dump in gen)</span><br>                              <span class="hljs-comment">// string(6) &quot;yield2&quot; (the var_dump of the -&gt;send() return value)</span><br>var_dump(<span class="hljs-variable">$gen</span>-&gt;send(<span class="hljs-string">&#x27;ret2&#x27;</span>)); <span class="hljs-comment">// string(4) &quot;ret2&quot;   (again from within gen)</span><br>                              <span class="hljs-comment">// NULL               (the return value of -&gt;send())</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>

<p>要很快的理解输出的精确顺序可能稍微有点困难, 但你确定要搞清楚为什按照这种方式输出. 以便后续继续阅读.</p>
<p>另外, 我要特别指出的有两点：</p>
<p>第一点,yield表达式两边的括号在PHP7以前不是可选的, 也就是说在PHP5.5和PHP5.6中圆括号是必须的.</p>
<p>第二点,你可能已经注意到调用current()之前没有调用rewind().这是因为生成迭代对象的时候已经隐含地执行了rewind操作.</p>
<h2 id="多任务协作"><a href="#多任务协作" class="headerlink" title="多任务协作"></a>多任务协作</h2><p>如果阅读了上面的logger()例子, 你也许会疑惑“为了双向通信我为什么要使用协程呢？我完全可以使用其他非协程方法实现同样的功能啊?”, 是的, 你是对的, 但上面的例子只是为了演示了基本用法, 这个例子其实并没有真正的展示出使用协程的优点.</p>
<p>正如上面介绍里提到的,协程是非常强大的概念,不过却应用的很稀少而且常常十分复杂.要给出一些简单而真实的例子很难.</p>
<p>在这篇文章里,我决定去做的是使用协程实现多任务协作.我们要解决的问题是你想并发地运行多任务(或者“程序”）.不过我们都知道CPU在一个时刻只能运行一个任务（不考虑多核的情况）.因此处理器需要在不同的任务之间进行切换,而且总是让每个任务运行 “一小会儿”.</p>
<p>多任务协作这个术语中的“协作”很好的说明了如何进行这种切换的：它要求当前正在运行的任务自动把控制传回给调度器,这样就可以运行其他任务了. 这与“抢占”多任务相反, 抢占多任务是这样的：调度器可以中断运行了一段时间的任务, 不管它喜欢还是不喜欢. 协作多任务在Windows的早期版本(windows95)和Mac OS中有使用, 不过它们后来都切换到使用抢先多任务了. 理由相当明确：如果你依靠程序自动交出控制的话, 那么一些恶意的程序将很容易占用整个CPU, 不与其他任务共享.</p>
<p>现在你应当明白协程和任务调度之间的关系：yield指令提供了任务中断自身的一种方法, 然后把控制交回给任务调度器. 因此协程可以运行多个其他任务. 更进一步来说, yield还可以用来在任务和调度器之间进行通信.</p>
<p>为了实现我们的多任务调度, 首先实现“任务” — 一个用轻量级的包装的协程函数:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$taskId</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$coroutine</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$sendValue</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$beforeFirstYield</span> = <span class="hljs-literal">true</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$taskId</span>, <span class="hljs-built_in">Generator</span> <span class="hljs-variable">$coroutine</span></span>) </span>&#123;<br>        <span class="hljs-keyword">$this</span>-&gt;taskId = <span class="hljs-variable">$taskId</span>;<br>        <span class="hljs-keyword">$this</span>-&gt;coroutine = <span class="hljs-variable">$coroutine</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTaskId</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">$this</span>-&gt;taskId;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setSendValue</span>(<span class="hljs-params"><span class="hljs-variable">$sendValue</span></span>) </span>&#123;<br>        <span class="hljs-keyword">$this</span>-&gt;sendValue = <span class="hljs-variable">$sendValue</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">$this</span>-&gt;beforeFirstYield) &#123;<br>            <span class="hljs-keyword">$this</span>-&gt;beforeFirstYield = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">$this</span>-&gt;coroutine-&gt;current();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-variable">$retval</span> = <span class="hljs-keyword">$this</span>-&gt;coroutine-&gt;send(<span class="hljs-keyword">$this</span>-&gt;sendValue);<br>            <span class="hljs-keyword">$this</span>-&gt;sendValue = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable">$retval</span>;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFinished</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> !<span class="hljs-keyword">$this</span>-&gt;coroutine-&gt;valid();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如代码, 一个任务就是用任务ID标记的一个协程(函数). 使用setSendValue()方法, 你可以指定哪些值将被发送到下次的恢复(在之后你会了解到我们需要这个), run()函数确实没有做什么, 除了调用send()方法的协同程序, 要理解为什么添加了一个 beforeFirstYieldflag变量, 需要考虑下面的代码片段：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">gen</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;foo&#x27;</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;bar&#x27;</span>;<br>&#125;<br> <br><span class="hljs-variable">$gen</span> = gen();<br>var_dump(<span class="hljs-variable">$gen</span>-&gt;send(<span class="hljs-string">&#x27;something&#x27;</span>));<br> <br><span class="hljs-comment">// 如之前提到的在send之前, 当$gen迭代器被创建的时候一个renwind()方法已经被隐式调用</span><br><span class="hljs-comment">// 所以实际上发生的应该类似:</span><br><span class="hljs-comment">//$gen-&gt;rewind();</span><br><span class="hljs-comment">//var_dump($gen-&gt;send(&#x27;something&#x27;));</span><br> <br><span class="hljs-comment">//这样renwind的执行将会导致第一个yield被执行, 并且忽略了他的返回值.</span><br><span class="hljs-comment">//真正当我们调用yield的时候, 我们得到的是第二个yield的值! 导致第一个yield的值被忽略.</span><br><span class="hljs-comment">//string(3) &quot;bar&quot;</span><br></code></pre></td></tr></table></figure>

<p>通过添加 beforeFirstYieldcondition 我们可以确定第一个yield的值能被正确返回.</p>
<p>调度器现在不得不比多任务循环要做稍微多点了, 然后才运行多任务：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Scheduler</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$maxTaskId</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$taskMap</span> = []; <span class="hljs-comment">// taskId =&gt; task</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$taskQueue</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">$this</span>-&gt;taskQueue = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SplQueue</span>();<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">newTask</span>(<span class="hljs-params"><span class="hljs-built_in">Generator</span> <span class="hljs-variable">$coroutine</span></span>) </span>&#123;<br>        <span class="hljs-variable">$tid</span> = ++<span class="hljs-keyword">$this</span>-&gt;maxTaskId;<br>        <span class="hljs-variable">$task</span> = <span class="hljs-keyword">new</span> Task(<span class="hljs-variable">$tid</span>, <span class="hljs-variable">$coroutine</span>);<br>        <span class="hljs-keyword">$this</span>-&gt;taskMap[<span class="hljs-variable">$tid</span>] = <span class="hljs-variable">$task</span>;<br>        <span class="hljs-keyword">$this</span>-&gt;schedule(<span class="hljs-variable">$task</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">$tid</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">schedule</span>(<span class="hljs-params">Task <span class="hljs-variable">$task</span></span>) </span>&#123;<br>        <span class="hljs-keyword">$this</span>-&gt;taskQueue-&gt;enqueue(<span class="hljs-variable">$task</span>);<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">while</span> (!<span class="hljs-keyword">$this</span>-&gt;taskQueue-&gt;isEmpty()) &#123;<br>            <span class="hljs-variable">$task</span> = <span class="hljs-keyword">$this</span>-&gt;taskQueue-&gt;dequeue();<br>            <span class="hljs-variable">$task</span>-&gt;run();<br> <br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable">$task</span>-&gt;isFinished()) &#123;<br>                <span class="hljs-keyword">unset</span>(<span class="hljs-keyword">$this</span>-&gt;taskMap[<span class="hljs-variable">$task</span>-&gt;getTaskId()]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">$this</span>-&gt;schedule(<span class="hljs-variable">$task</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>

<p>newTask()方法（使用下一个空闲的任务id）创建一个新任务,然后把这个任务放入任务map数组里. 接着它通过把任务放入任务队列里来实现对任务的调度. 接着run()方法扫描任务队列, 运行任务.如果一个任务结束了, 那么它将从队列里删除, 否则它将在队列的末尾再次被调度.</p>
<p>让我们看看下面具有两个简单（没有什么意义）任务的调度器：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">task1</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span> = <span class="hljs-number">1</span>; <span class="hljs-variable">$i</span> &lt;= <span class="hljs-number">10</span>; ++<span class="hljs-variable">$i</span>) &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;This is task 1 iteration <span class="hljs-subst">$i</span>.\n&quot;</span>;<br>        <span class="hljs-keyword">yield</span>;<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">task2</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span> = <span class="hljs-number">1</span>; <span class="hljs-variable">$i</span> &lt;= <span class="hljs-number">5</span>; ++<span class="hljs-variable">$i</span>) &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;This is task 2 iteration <span class="hljs-subst">$i</span>.\n&quot;</span>;<br>        <span class="hljs-keyword">yield</span>;<br>    &#125;<br>&#125;<br> <br><span class="hljs-variable">$scheduler</span> = <span class="hljs-keyword">new</span> Scheduler;<br> <br><span class="hljs-variable">$scheduler</span>-&gt;newTask(task1());<br><span class="hljs-variable">$scheduler</span>-&gt;newTask(task2());<br> <br><span class="hljs-variable">$scheduler</span>-&gt;run();<br></code></pre></td></tr></table></figure>

<p>两个任务都仅仅回显一条信息,然后使用yield把控制回传给调度器.输出结果如下：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ada">This <span class="hljs-keyword">is</span> <span class="hljs-keyword">task</span> <span class="hljs-number">1</span> iteration <span class="hljs-number">1</span>.<br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">task</span> <span class="hljs-number">2</span> iteration <span class="hljs-number">1</span>.<br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">task</span> <span class="hljs-number">1</span> iteration <span class="hljs-number">2</span>.<br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">task</span> <span class="hljs-number">2</span> iteration <span class="hljs-number">2</span>.<br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">task</span> <span class="hljs-number">1</span> iteration <span class="hljs-number">3</span>.<br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">task</span> <span class="hljs-number">2</span> iteration <span class="hljs-number">3</span>.<br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">task</span> <span class="hljs-number">1</span> iteration <span class="hljs-number">4</span>.<br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">task</span> <span class="hljs-number">2</span> iteration <span class="hljs-number">4</span>.<br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">task</span> <span class="hljs-number">1</span> iteration <span class="hljs-number">5</span>.<br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">task</span> <span class="hljs-number">2</span> iteration <span class="hljs-number">5</span>.<br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">task</span> <span class="hljs-number">1</span> iteration <span class="hljs-number">6</span>.<br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">task</span> <span class="hljs-number">1</span> iteration <span class="hljs-number">7</span>.<br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">task</span> <span class="hljs-number">1</span> iteration <span class="hljs-number">8</span>.<br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">task</span> <span class="hljs-number">1</span> iteration <span class="hljs-number">9</span>.<br>This <span class="hljs-keyword">is</span> <span class="hljs-keyword">task</span> <span class="hljs-number">1</span> iteration <span class="hljs-number">10</span>.<br></code></pre></td></tr></table></figure>

<p>输出确实如我们所期望的：对前五个迭代来说,两个任务是交替运行的, 而在第二个任务结束后, 只有第一个任务继续运行.</p>
<h2 id="与调度器之间通信"><a href="#与调度器之间通信" class="headerlink" title="与调度器之间通信"></a>与调度器之间通信</h2><p>既然调度器已经运行了, 那么我们来看下一个问题：任务和调度器之间的通信.</p>
<p>我们将使用进程用来和操作系统会话的同样的方式来通信：系统调用.</p>
<p>我们需要系统调用的理由是操作系统与进程相比它处在不同的权限级别上. 因此为了执行特权级别的操作（如杀死另一个进程), 就不得不以某种方式把控制传回给内核, 这样内核就可以执行所说的操作了. 再说一遍, 这种行为在内部是通过使用中断指令来实现的. 过去使用的是通用的int指令, 如今使用的是更特殊并且更快速的syscall/sysenter指令.</p>
<p>我们的任务调度系统将反映这种设计：不是简单地把调度器传递给任务（这样就允许它做它想做的任何事), 我们将通过给yield表达式传递信息来与系统调用通信. 这儿yield即是中断, 也是传递信息给调度器（和从调度器传递出信息）的方法.</p>
<p>为了说明系统调用, 我们对可调用的系统调用做一个小小的封装：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SystemCall</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$callback</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-keyword">callable</span> <span class="hljs-variable">$callback</span></span>) </span>&#123;<br>        <span class="hljs-keyword">$this</span>-&gt;callback = <span class="hljs-variable">$callback</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__invoke</span>(<span class="hljs-params">Task <span class="hljs-variable">$task</span>, Scheduler <span class="hljs-variable">$scheduler</span></span>) </span>&#123;<br>        <span class="hljs-variable">$callback</span> = <span class="hljs-keyword">$this</span>-&gt;callback;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">$callback</span>(<span class="hljs-variable">$task</span>, <span class="hljs-variable">$scheduler</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>它和其他任何可调用的对象(使用_invoke)一样的运行, 不过它要求调度器把正在调用的任务和自身传递给这个函数.</p>
<p>为了解决这个问题我们不得不微微的修改调度器的run方法：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-keyword">$this</span>-&gt;taskQueue-&gt;isEmpty()) &#123;<br>        <span class="hljs-variable">$task</span> = <span class="hljs-keyword">$this</span>-&gt;taskQueue-&gt;dequeue();<br>        <span class="hljs-variable">$retval</span> = <span class="hljs-variable">$task</span>-&gt;run();<br> <br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">$retval</span> <span class="hljs-keyword">instanceof</span> SystemCall) &#123;<br>            <span class="hljs-variable">$retval</span>(<span class="hljs-variable">$task</span>, <span class="hljs-keyword">$this</span>);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br> <br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">$task</span>-&gt;isFinished()) &#123;<br>            <span class="hljs-keyword">unset</span>(<span class="hljs-keyword">$this</span>-&gt;taskMap[<span class="hljs-variable">$task</span>-&gt;getTaskId()]);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">$this</span>-&gt;schedule(<span class="hljs-variable">$task</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>第一个系统调用除了返回任务ID外什么都没有做：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTaskId</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SystemCall(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Task <span class="hljs-variable">$task</span>, Scheduler <span class="hljs-variable">$scheduler</span></span>) </span>&#123;<br>        <span class="hljs-variable">$task</span>-&gt;setSendValue(<span class="hljs-variable">$task</span>-&gt;getTaskId());<br>        <span class="hljs-variable">$scheduler</span>-&gt;schedule(<span class="hljs-variable">$task</span>);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个函数设置任务id为下一次发送的值, 并再次调度了这个任务 .由于使用了系统调用, 所以调度器不能自动调用任务, 我们需要手工调度任务（稍后你将明白为什么这么做). 要使用这个新的系统调用的话, 我们要重新编写以前的例子：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">task</span>(<span class="hljs-params"><span class="hljs-variable">$max</span></span>) </span>&#123;<br>    <span class="hljs-variable">$tid</span> = (<span class="hljs-keyword">yield</span> getTaskId()); <span class="hljs-comment">// &lt;-- here&#x27;s the syscall!</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span> = <span class="hljs-number">1</span>; <span class="hljs-variable">$i</span> &lt;= <span class="hljs-variable">$max</span>; ++<span class="hljs-variable">$i</span>) &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;This is task <span class="hljs-subst">$tid</span> iteration <span class="hljs-subst">$i</span>.\n&quot;</span>;<br>        <span class="hljs-keyword">yield</span>;<br>    &#125;<br>&#125;<br> <br><span class="hljs-variable">$scheduler</span> = <span class="hljs-keyword">new</span> Scheduler;<br> <br><span class="hljs-variable">$scheduler</span>-&gt;newTask(task(<span class="hljs-number">10</span>));<br><span class="hljs-variable">$scheduler</span>-&gt;newTask(task(<span class="hljs-number">5</span>));<br> <br><span class="hljs-variable">$scheduler</span>-&gt;run();<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>

<p>这段代码将给出与前一个例子相同的输出. 请注意系统调用如何同其他任何调用一样正常地运行, 只不过预先增加了yield.</p>
<p>要创建新的任务, 然后再杀死它们的话, 需要两个以上的系统调用：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">newTask</span>(<span class="hljs-params"><span class="hljs-built_in">Generator</span> <span class="hljs-variable">$coroutine</span></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SystemCall(<br>        <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Task <span class="hljs-variable">$task</span>, Scheduler <span class="hljs-variable">$scheduler</span></span>) <span class="hljs-keyword">use</span> (<span class="hljs-params"><span class="hljs-variable">$coroutine</span></span>) </span>&#123;<br>            <span class="hljs-variable">$task</span>-&gt;setSendValue(<span class="hljs-variable">$scheduler</span>-&gt;newTask(<span class="hljs-variable">$coroutine</span>));<br>            <span class="hljs-variable">$scheduler</span>-&gt;schedule(<span class="hljs-variable">$task</span>);<br>        &#125;<br>    );<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">killTask</span>(<span class="hljs-params"><span class="hljs-variable">$tid</span></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SystemCall(<br>        <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Task <span class="hljs-variable">$task</span>, Scheduler <span class="hljs-variable">$scheduler</span></span>) <span class="hljs-keyword">use</span> (<span class="hljs-params"><span class="hljs-variable">$tid</span></span>) </span>&#123;<br>            <span class="hljs-variable">$task</span>-&gt;setSendValue(<span class="hljs-variable">$scheduler</span>-&gt;killTask(<span class="hljs-variable">$tid</span>));<br>            <span class="hljs-variable">$scheduler</span>-&gt;schedule(<span class="hljs-variable">$task</span>);<br>        &#125;<br>    );<br>&#125;<br></code></pre></td></tr></table></figure>

<p>killTask函数需要在调度器里增加一个方法：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">killTask</span>(<span class="hljs-params"><span class="hljs-variable">$tid</span></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">isset</span>(<span class="hljs-keyword">$this</span>-&gt;taskMap[<span class="hljs-variable">$tid</span>])) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">unset</span>(<span class="hljs-keyword">$this</span>-&gt;taskMap[<span class="hljs-variable">$tid</span>]);<br> <br>    <span class="hljs-comment">// This is a bit ugly and could be optimized so it does not have to walk the queue,</span><br>    <span class="hljs-comment">// but assuming that killing tasks is rather rare I won&#x27;t bother with it now</span><br>    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">$this</span>-&gt;taskQueue <span class="hljs-keyword">as</span> <span class="hljs-variable">$i</span> =&gt; <span class="hljs-variable">$task</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">$task</span>-&gt;getTaskId() === <span class="hljs-variable">$tid</span>) &#123;<br>            <span class="hljs-keyword">unset</span>(<span class="hljs-keyword">$this</span>-&gt;taskQueue[<span class="hljs-variable">$i</span>]);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>用来测试新功能的微脚本：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">childTask</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-variable">$tid</span> = (<span class="hljs-keyword">yield</span> getTaskId());<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Child task <span class="hljs-subst">$tid</span> still alive!\n&quot;</span>;<br>        <span class="hljs-keyword">yield</span>;<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">task</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-variable">$tid</span> = (<span class="hljs-keyword">yield</span> getTaskId());<br>    <span class="hljs-variable">$childTid</span> = (<span class="hljs-keyword">yield</span> newTask(childTask()));<br> <br>    <span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span> = <span class="hljs-number">1</span>; <span class="hljs-variable">$i</span> &lt;= <span class="hljs-number">6</span>; ++<span class="hljs-variable">$i</span>) &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Parent task <span class="hljs-subst">$tid</span> iteration <span class="hljs-subst">$i</span>.\n&quot;</span>;<br>        <span class="hljs-keyword">yield</span>;<br> <br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">$i</span> == <span class="hljs-number">3</span>) <span class="hljs-keyword">yield</span> killTask(<span class="hljs-variable">$childTid</span>);<br>    &#125;<br>&#125;<br> <br><span class="hljs-variable">$scheduler</span> = <span class="hljs-keyword">new</span> Scheduler;<br><span class="hljs-variable">$scheduler</span>-&gt;newTask(task());<br><span class="hljs-variable">$scheduler</span>-&gt;run();<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>

<p>这段代码将打印以下信息：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Parent</span> task <span class="hljs-number">1</span> iteration <span class="hljs-number">1</span>.<br><span class="hljs-attribute">Child</span> task <span class="hljs-number">2</span> still alive!<br><span class="hljs-attribute">Parent</span> task <span class="hljs-number">1</span> iteration <span class="hljs-number">2</span>.<br><span class="hljs-attribute">Child</span> task <span class="hljs-number">2</span> still alive!<br><span class="hljs-attribute">Parent</span> task <span class="hljs-number">1</span> iteration <span class="hljs-number">3</span>.<br><span class="hljs-attribute">Child</span> task <span class="hljs-number">2</span> still alive!<br><span class="hljs-attribute">Parent</span> task <span class="hljs-number">1</span> iteration <span class="hljs-number">4</span>.<br><span class="hljs-attribute">Parent</span> task <span class="hljs-number">1</span> iteration <span class="hljs-number">5</span>.<br><span class="hljs-attribute">Parent</span> task <span class="hljs-number">1</span> iteration <span class="hljs-number">6</span>.<br></code></pre></td></tr></table></figure>

<p>经过三次迭代以后子任务将被杀死, 因此这就是”Child is still alive”消息结束的时候. 不过你要明白这还不是真正的父子关系. 因为在父任务结束后子任务仍然可以运行, 子任务甚至可以杀死父任务. 可以修改调度器使它具有更层级化的任务结构, 不过这个不是我们这个文章要继续讨论的范围了.</p>
<p>现在你可以实现许多进程管理调用. 例如 wait（它一直等待到任务结束运行时), exec（它替代当前任务)和fork（它创建一个当前任务的克隆). fork非常酷,而 且你可以使用PHP的协程真正地实现它, 因为它们都支持克隆.</p>
<p>让我们把这些留给有兴趣的读者吧,我们来看下一个议题.</p>
<h2 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h2><p>很明显, 我们的任务管理系统的真正很酷的应用应该是web服务器. 它有一个任务是在套接字上侦听是否有新连接, 当有新连接要建立的时候, 它创建一个新任务来处理新连接.</p>
<p>Web服务器最难的部分通常是像读数据这样的套接字操作是阻塞的. 例如PHP将等待到客户端完成发送为止. 对一个Web服务器来说, 这有点不太高效. 因为服务器在一个时间点上只能处理一个连接.</p>
<p>解决方案是确保在真正对套接字读写之前该套接字已经“准备就绪”. 为了查找哪个套接字已经准备好读或者写了, 可以使用 流选择函数.</p>
<p>首先,让我们添加两个新的 syscall, 它们将等待直到指定socket 准备好：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">waitForRead</span>(<span class="hljs-params"><span class="hljs-variable">$socket</span></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SystemCall(<br>        <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Task <span class="hljs-variable">$task</span>, Scheduler <span class="hljs-variable">$scheduler</span></span>) <span class="hljs-keyword">use</span> (<span class="hljs-params"><span class="hljs-variable">$socket</span></span>) </span>&#123;<br>            <span class="hljs-variable">$scheduler</span>-&gt;waitForRead(<span class="hljs-variable">$socket</span>, <span class="hljs-variable">$task</span>);<br>        &#125;<br>    );<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">waitForWrite</span>(<span class="hljs-params"><span class="hljs-variable">$socket</span></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SystemCall(<br>        <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Task <span class="hljs-variable">$task</span>, Scheduler <span class="hljs-variable">$scheduler</span></span>) <span class="hljs-keyword">use</span> (<span class="hljs-params"><span class="hljs-variable">$socket</span></span>) </span>&#123;<br>            <span class="hljs-variable">$scheduler</span>-&gt;waitForWrite(<span class="hljs-variable">$socket</span>, <span class="hljs-variable">$task</span>);<br>        &#125;<br>    );<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这些 syscall 只是在调度器中代理其各自的方法：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br> <br><span class="hljs-comment">// resourceID =&gt; [socket, tasks]</span><br><span class="hljs-keyword">protected</span> <span class="hljs-variable">$waitingForRead</span> = [];<br><span class="hljs-keyword">protected</span> <span class="hljs-variable">$waitingForWrite</span> = [];<br> <br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">waitForRead</span>(<span class="hljs-params"><span class="hljs-variable">$socket</span>, Task <span class="hljs-variable">$task</span></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-keyword">$this</span>-&gt;waitingForRead[(<span class="hljs-keyword">int</span>) <span class="hljs-variable">$socket</span>])) &#123;<br>        <span class="hljs-keyword">$this</span>-&gt;waitingForRead[(<span class="hljs-keyword">int</span>) <span class="hljs-variable">$socket</span>][<span class="hljs-number">1</span>][] = <span class="hljs-variable">$task</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">$this</span>-&gt;waitingForRead[(<span class="hljs-keyword">int</span>) <span class="hljs-variable">$socket</span>] = [<span class="hljs-variable">$socket</span>, [<span class="hljs-variable">$task</span>]];<br>    &#125;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">waitForWrite</span>(<span class="hljs-params"><span class="hljs-variable">$socket</span>, Task <span class="hljs-variable">$task</span></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-keyword">$this</span>-&gt;waitingForWrite[(<span class="hljs-keyword">int</span>) <span class="hljs-variable">$socket</span>])) &#123;<br>        <span class="hljs-keyword">$this</span>-&gt;waitingForWrite[(<span class="hljs-keyword">int</span>) <span class="hljs-variable">$socket</span>][<span class="hljs-number">1</span>][] = <span class="hljs-variable">$task</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">$this</span>-&gt;waitingForWrite[(<span class="hljs-keyword">int</span>) <span class="hljs-variable">$socket</span>] = [<span class="hljs-variable">$socket</span>, [<span class="hljs-variable">$task</span>]];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>waitingForRead 及 waitingForWrite 属性是两个承载等待的socket 及等待它们的任务的数组. 有趣的部分在于下面的方法,它将检查 socket 是否可用, 并重新安排各自任务：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br> <br><span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ioPoll</span>(<span class="hljs-params"><span class="hljs-variable">$timeout</span></span>) </span>&#123;<br>    <span class="hljs-variable">$rSocks</span> = [];<br>    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">$this</span>-&gt;waitingForRead <span class="hljs-keyword">as</span> <span class="hljs-keyword">list</span>(<span class="hljs-variable">$socket</span>)) &#123;<br>        <span class="hljs-variable">$rSocks</span>[] = <span class="hljs-variable">$socket</span>;<br>    &#125;<br> <br>    <span class="hljs-variable">$wSocks</span> = [];<br>    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">$this</span>-&gt;waitingForWrite <span class="hljs-keyword">as</span> <span class="hljs-keyword">list</span>(<span class="hljs-variable">$socket</span>)) &#123;<br>        <span class="hljs-variable">$wSocks</span>[] = <span class="hljs-variable">$socket</span>;<br>    &#125;<br> <br>    <span class="hljs-variable">$eSocks</span> = []; <span class="hljs-comment">// dummy</span><br> <br>    <span class="hljs-keyword">if</span> (!stream_select(<span class="hljs-variable">$rSocks</span>, <span class="hljs-variable">$wSocks</span>, <span class="hljs-variable">$eSocks</span>, <span class="hljs-variable">$timeout</span>)) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$rSocks</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$socket</span>) &#123;<br>        <span class="hljs-keyword">list</span>(, <span class="hljs-variable">$tasks</span>) = <span class="hljs-keyword">$this</span>-&gt;waitingForRead[(<span class="hljs-keyword">int</span>) <span class="hljs-variable">$socket</span>];<br>        <span class="hljs-keyword">unset</span>(<span class="hljs-keyword">$this</span>-&gt;waitingForRead[(<span class="hljs-keyword">int</span>) <span class="hljs-variable">$socket</span>]);<br> <br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$tasks</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$task</span>) &#123;<br>            <span class="hljs-keyword">$this</span>-&gt;schedule(<span class="hljs-variable">$task</span>);<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$wSocks</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$socket</span>) &#123;<br>        <span class="hljs-keyword">list</span>(, <span class="hljs-variable">$tasks</span>) = <span class="hljs-keyword">$this</span>-&gt;waitingForWrite[(<span class="hljs-keyword">int</span>) <span class="hljs-variable">$socket</span>];<br>        <span class="hljs-keyword">unset</span>(<span class="hljs-keyword">$this</span>-&gt;waitingForWrite[(<span class="hljs-keyword">int</span>) <span class="hljs-variable">$socket</span>]);<br> <br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$tasks</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$task</span>) &#123;<br>            <span class="hljs-keyword">$this</span>-&gt;schedule(<span class="hljs-variable">$task</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>stream_select 函数接受承载读取、写入以及待检查的socket的数组（我们无需考虑最后一类). 数组将按引用传递, 函数只会保留那些状态改变了的数组元素. 我们可以遍历这些数组, 并重新安排与之相关的任务.</p>
<p>为了正常地执行上面的轮询动作, 我们将在调度器里增加一个特殊的任务：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ioPollTask</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">$this</span>-&gt;taskQueue-&gt;isEmpty()) &#123;<br>            <span class="hljs-keyword">$this</span>-&gt;ioPoll(<span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">$this</span>-&gt;ioPoll(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">yield</span>;<br>    &#125;<br>&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>

<p>需要在某个地方注册这个任务, 例如, 你可以在run()方法的开始增加$this-&gt;newTask($this-&gt;ioPollTask()). 然后就像其他任务一样每执行完整任务循环一次就执行轮询操作一次（这么做一定不是最好的方法), ioPollTask将使用0秒的超时来调用ioPoll, 也就是stream_select将立即返回（而不是等待）.</p>
<p>只有任务队列为空时,我们才使用null超时,这意味着它一直等到某个套接口准备就绪.如果我们没有这么做,那么轮询任务将一而再, 再而三的循环运行, 直到有新的连接建立. 这将导致100%的CPU利用率. 相反, 让操作系统做这种等待会更有效.</p>
<p>现在编写服务器就相对容易了：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br> <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">server</span>(<span class="hljs-params"><span class="hljs-variable">$port</span></span>) </span>&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Starting server at port <span class="hljs-subst">$port</span>...\n&quot;</span>;<br> <br>    <span class="hljs-variable">$socket</span> = @stream_socket_server(<span class="hljs-string">&quot;tcp://localhost:<span class="hljs-subst">$port</span>&quot;</span>, <span class="hljs-variable">$errNo</span>, <span class="hljs-variable">$errStr</span>);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable">$socket</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Exception</span>(<span class="hljs-variable">$errStr</span>, <span class="hljs-variable">$errNo</span>);<br> <br>    stream_set_blocking(<span class="hljs-variable">$socket</span>, <span class="hljs-number">0</span>);<br> <br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">yield</span> waitForRead(<span class="hljs-variable">$socket</span>);<br>        <span class="hljs-variable">$clientSocket</span> = stream_socket_accept(<span class="hljs-variable">$socket</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">yield</span> newTask(handleClient(<span class="hljs-variable">$clientSocket</span>));<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleClient</span>(<span class="hljs-params"><span class="hljs-variable">$socket</span></span>) </span>&#123;<br>    <span class="hljs-keyword">yield</span> waitForRead(<span class="hljs-variable">$socket</span>);<br>    <span class="hljs-variable">$data</span> = fread(<span class="hljs-variable">$socket</span>, <span class="hljs-number">8192</span>);<br> <br>    <span class="hljs-variable">$msg</span> = <span class="hljs-string">&quot;Received following request:\n\n<span class="hljs-subst">$data</span>&quot;</span>;<br>    <span class="hljs-variable">$msgLength</span> = strlen(<span class="hljs-variable">$msg</span>);<br> <br>    <span class="hljs-variable">$response</span> = <span class="hljs-string">&lt;&lt;&lt;RES</span><br><span class="hljs-string">HTTP/1.1 200 OK\r</span><br><span class="hljs-string">Content-Type: text/plain\r</span><br><span class="hljs-string">Content-Length: <span class="hljs-subst">$msgLength</span>\r</span><br><span class="hljs-string">Connection: close\r</span><br><span class="hljs-string">\r</span><br><span class="hljs-string"><span class="hljs-subst">$msg</span></span><br><span class="hljs-string">RES</span>;<br> <br>    <span class="hljs-keyword">yield</span> waitForWrite(<span class="hljs-variable">$socket</span>);<br>    fwrite(<span class="hljs-variable">$socket</span>, <span class="hljs-variable">$response</span>);<br> <br>    fclose(<span class="hljs-variable">$socket</span>);<br>&#125;<br> <br><span class="hljs-variable">$scheduler</span> = <span class="hljs-keyword">new</span> Scheduler;<br><span class="hljs-variable">$scheduler</span>-&gt;newTask(server(<span class="hljs-number">8000</span>));<br><span class="hljs-variable">$scheduler</span>-&gt;run();<br></code></pre></td></tr></table></figure>

<p>这段代码实现了接收localhost:8000上的连接, 然后返回发送来的内容作为HTTP响应. 当然它还能处理真正的复杂HTTP请求, 上面的代码片段只是演示了一般性的概念.</p>
<p>你可以使用类似于ab -n 10000 -c 100 localhost:8000/这样命令来测试服务器. 这条命令将向服务器发送10000个请求, 并且其中100个请求将同时到达. 使用这样的数目, 我得到了处于中间的10毫秒的响应时间. 不过还有一个问题：有少数几个请求真正处理的很慢（如5秒), 这就是为什么总吞吐量只有2000请求/秒（如果是10毫秒的响应时间的话, 总的吞吐量应该更像是10000请求/秒)</p>
<h2 id="协程堆栈"><a href="#协程堆栈" class="headerlink" title="协程堆栈"></a>协程堆栈</h2><p>如果你试图用我们的调度系统建立更大的系统的话, 你将很快遇到问题：我们习惯了把代码分解为更小的函数, 然后调用它们. 然而, 如果使用了协程的话, 就不能这么做了. 例如,看下面代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">echoTimes</span>(<span class="hljs-params"><span class="hljs-variable">$msg</span>, <span class="hljs-variable">$max</span></span>) </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span> = <span class="hljs-number">1</span>; <span class="hljs-variable">$i</span> &lt;= <span class="hljs-variable">$max</span>; ++<span class="hljs-variable">$i</span>) &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;<span class="hljs-subst">$msg</span> iteration <span class="hljs-subst">$i</span>\n&quot;</span>;<br>        <span class="hljs-keyword">yield</span>;<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">task</span>(<span class="hljs-params"></span>) </span>&#123;<br>    echoTimes(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-number">10</span>); <span class="hljs-comment">// print foo ten times</span><br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;---\n&quot;</span>;<br>    echoTimes(<span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// print bar five times</span><br>    <span class="hljs-keyword">yield</span>; <span class="hljs-comment">// force it to be a coroutine</span><br>&#125;<br> <br><span class="hljs-variable">$scheduler</span> = <span class="hljs-keyword">new</span> Scheduler;<br><span class="hljs-variable">$scheduler</span>-&gt;newTask(task());<br><span class="hljs-variable">$scheduler</span>-&gt;run();<br></code></pre></td></tr></table></figure>

<p>这段代码试图把重复循环“输出n次“的代码嵌入到一个独立的协程里,然后从主任务里调用它. 然而它无法运行. 正如在这篇文章的开始所提到的, 调用生成器（或者协程）将没有真正地做任何事情, 它仅仅返回一个对象.这 也出现在上面的例子里:echoTimes调用除了放回一个（无用的）协程对象外不做任何事情.</p>
<p>为了仍然允许这么做,我们需要在这个裸协程上写一个小小的封装.我们将调用它：“协程堆栈”. 因为它将管理嵌套的协程调用堆栈. 这将是通过生成协程来调用子协程成为可能：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">$retval</span> = (<span class="hljs-keyword">yield</span> someCoroutine(<span class="hljs-variable">$foo</span>, <span class="hljs-variable">$bar</span>));<br></code></pre></td></tr></table></figure>

<p>使用yield,子协程也能再次返回值：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function">yield <span class="hljs-title">retval</span><span class="hljs-params">(<span class="hljs-string">&quot;I&#x27;m a return value!&quot;</span>)</span></span>;<br></code></pre></td></tr></table></figure>

<p>retval函数除了返回一个值的封装外没有做任何其他事情.这个封装将表示它是一个返回值.</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoroutineReturnValue</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$value</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$value</span></span>) </span>&#123;<br>        <span class="hljs-keyword">$this</span>-&gt;value = <span class="hljs-variable">$value</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getValue</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">$this</span>-&gt;value;<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">retval</span>(<span class="hljs-params"><span class="hljs-variable">$value</span></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CoroutineReturnValue(<span class="hljs-variable">$value</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>为了把协程转变为协程堆栈（它支持子调用）,我们将不得不编写另外一个函数（很明显,它是另一个协程）：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br> <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stackedCoroutine</span>(<span class="hljs-params"><span class="hljs-built_in">Generator</span> <span class="hljs-variable">$gen</span></span>) </span>&#123;<br>    <span class="hljs-variable">$stack</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SplStack</span>;<br> <br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-variable">$value</span> = <span class="hljs-variable">$gen</span>-&gt;current();<br> <br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">$value</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Generator</span>) &#123;<br>            <span class="hljs-variable">$stack</span>-&gt;push(<span class="hljs-variable">$gen</span>);<br>            <span class="hljs-variable">$gen</span> = <span class="hljs-variable">$value</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br> <br>        <span class="hljs-variable">$isReturnValue</span> = <span class="hljs-variable">$value</span> <span class="hljs-keyword">instanceof</span> CoroutineReturnValue;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-variable">$gen</span>-&gt;valid() || <span class="hljs-variable">$isReturnValue</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable">$stack</span>-&gt;isEmpty()) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br> <br>            <span class="hljs-variable">$gen</span> = <span class="hljs-variable">$stack</span>-&gt;pop();<br>            <span class="hljs-variable">$gen</span>-&gt;send(<span class="hljs-variable">$isReturnValue</span> ? <span class="hljs-variable">$value</span>-&gt;getValue() : <span class="hljs-literal">NULL</span>);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br> <br>        <span class="hljs-variable">$gen</span>-&gt;send(<span class="hljs-keyword">yield</span> <span class="hljs-variable">$gen</span>-&gt;key() =&gt; <span class="hljs-variable">$value</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个函数在调用者和当前正在运行的子协程之间扮演着简单代理的角色.在$gen-&gt;send(yield $gen-&gt;key()=&gt;$value)；这行完成了代理功能.另外它检查返回值是否是生成器,万一是生成器的话,它将开始运行这个生成器,并把前一个协程压入堆栈里.一旦它获得了CoroutineReturnValue的话,它将再次请求堆栈弹出,然后继续执行前一个协程.</p>
<p>为了使协程堆栈在任务里可用,任务构造器里的$this-coroutine =$coroutine;这行需要替代为$this-&gt;coroutine = StackedCoroutine($coroutine);.</p>
<p>现在我们可以稍微改进上面web服务器例子：把wait+read(和wait+write和warit+accept)这样的动作分组为函数.为了分组相关的 功能,我将使用下面类：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoSocket</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$socket</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$socket</span></span>) </span>&#123;<br>        <span class="hljs-keyword">$this</span>-&gt;socket = <span class="hljs-variable">$socket</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">accept</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">yield</span> waitForRead(<span class="hljs-keyword">$this</span>-&gt;socket);<br>        <span class="hljs-keyword">yield</span> retval(<span class="hljs-keyword">new</span> CoSocket(stream_socket_accept(<span class="hljs-keyword">$this</span>-&gt;socket, <span class="hljs-number">0</span>)));<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">read</span>(<span class="hljs-params"><span class="hljs-variable">$size</span></span>) </span>&#123;<br>        <span class="hljs-keyword">yield</span> waitForRead(<span class="hljs-keyword">$this</span>-&gt;socket);<br>        <span class="hljs-keyword">yield</span> retval(fread(<span class="hljs-keyword">$this</span>-&gt;socket, <span class="hljs-variable">$size</span>));<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">write</span>(<span class="hljs-params"><span class="hljs-variable">$string</span></span>) </span>&#123;<br>        <span class="hljs-keyword">yield</span> waitForWrite(<span class="hljs-keyword">$this</span>-&gt;socket);<br>        fwrite(<span class="hljs-keyword">$this</span>-&gt;socket, <span class="hljs-variable">$string</span>);<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">close</span>(<span class="hljs-params"></span>) </span>&#123;<br>        @fclose(<span class="hljs-keyword">$this</span>-&gt;socket);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在服务器可以编写的稍微简洁点了：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br> <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">server</span>(<span class="hljs-params"><span class="hljs-variable">$port</span></span>) </span>&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Starting server at port <span class="hljs-subst">$port</span>...\n&quot;</span>;<br> <br>    <span class="hljs-variable">$socket</span> = @stream_socket_server(<span class="hljs-string">&quot;tcp://localhost:<span class="hljs-subst">$port</span>&quot;</span>, <span class="hljs-variable">$errNo</span>, <span class="hljs-variable">$errStr</span>);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable">$socket</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Exception</span>(<span class="hljs-variable">$errStr</span>, <span class="hljs-variable">$errNo</span>);<br> <br>    stream_set_blocking(<span class="hljs-variable">$socket</span>, <span class="hljs-number">0</span>);<br> <br>    <span class="hljs-variable">$socket</span> = <span class="hljs-keyword">new</span> CoSocket(<span class="hljs-variable">$socket</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">yield</span> newTask(<br>            handleClient(<span class="hljs-keyword">yield</span> <span class="hljs-variable">$socket</span>-&gt;accept())<br>        );<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleClient</span>(<span class="hljs-params"><span class="hljs-variable">$socket</span></span>) </span>&#123;<br>    <span class="hljs-variable">$data</span> = (<span class="hljs-keyword">yield</span> <span class="hljs-variable">$socket</span>-&gt;read(<span class="hljs-number">8192</span>));<br> <br>    <span class="hljs-variable">$msg</span> = <span class="hljs-string">&quot;Received following request:\n\n<span class="hljs-subst">$data</span>&quot;</span>;<br>    <span class="hljs-variable">$msgLength</span> = strlen(<span class="hljs-variable">$msg</span>);<br> <br>    <span class="hljs-variable">$response</span> = <span class="hljs-string">&lt;&lt;&lt;RES</span><br><span class="hljs-string">HTTP/1.1 200 OK\r</span><br><span class="hljs-string">Content-Type: text/plain\r</span><br><span class="hljs-string">Content-Length: <span class="hljs-subst">$msgLength</span>\r</span><br><span class="hljs-string">Connection: close\r</span><br><span class="hljs-string">\r</span><br><span class="hljs-string"><span class="hljs-subst">$msg</span></span><br><span class="hljs-string">RES</span>;<br> <br>    <span class="hljs-keyword">yield</span> <span class="hljs-variable">$socket</span>-&gt;write(<span class="hljs-variable">$response</span>);<br>    <span class="hljs-keyword">yield</span> <span class="hljs-variable">$socket</span>-&gt;close();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>作为一个优秀的程序员, 相信你已经察觉到上面的例子缺少错误处理. 几乎所有的 socket 都是易出错的. 我没有这样做的原因一方面固然是因为错误处理的乏味（特别是 socket), 另一方面也在于它很容易使代码体积膨胀.</p>
<p>不过, 我仍然想讲下常见的协程错误处理：协程允许使用 throw() 方法在其内部抛出一个错误.</p>
<p>throw() 方法接受一个 Exception, 并将其抛出到协程的当前悬挂点, 看看下面代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">gen</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Foo\n&quot;</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">yield</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-built_in">Exception</span> <span class="hljs-variable">$e</span>) &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Exception: <span class="hljs-subst">&#123;$e-&gt;getMessage()&#125;</span>\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Bar\n&quot;</span>;<br>&#125;<br> <br><span class="hljs-variable">$gen</span> = gen();<br><span class="hljs-variable">$gen</span>-&gt;rewind();                     <span class="hljs-comment">// echos &quot;Foo&quot;</span><br><span class="hljs-variable">$gen</span>-&gt;throw(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Exception</span>(<span class="hljs-string">&#x27;Test&#x27;</span>)); <span class="hljs-comment">// echos &quot;Exception: Test&quot;</span><br>                                    <span class="hljs-comment">// and &quot;Bar&quot;</span><br></code></pre></td></tr></table></figure>

<p>这非常好, 有没有? 因为我们现在可以使用系统调用以及子协程调用异常抛出了.</p>
<p>不过我们要对系统调用Scheduler::run() 方法做一些小调整：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$retval</span> <span class="hljs-keyword">instanceof</span> SystemCall) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-variable">$retval</span>(<span class="hljs-variable">$task</span>, <span class="hljs-keyword">$this</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-built_in">Exception</span> <span class="hljs-variable">$e</span>) &#123;<br>        <span class="hljs-variable">$task</span>-&gt;setException(<span class="hljs-variable">$e</span>);<br>        <span class="hljs-keyword">$this</span>-&gt;schedule(<span class="hljs-variable">$task</span>);<br>    &#125;<br>    <span class="hljs-keyword">continue</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Task 类也要添加 throw 调用处理：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$exception</span> = <span class="hljs-literal">null</span>;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setException</span>(<span class="hljs-params"><span class="hljs-variable">$exception</span></span>) </span>&#123;<br>        <span class="hljs-keyword">$this</span>-&gt;exception = <span class="hljs-variable">$exception</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">$this</span>-&gt;beforeFirstYield) &#123;<br>            <span class="hljs-keyword">$this</span>-&gt;beforeFirstYield = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">$this</span>-&gt;coroutine-&gt;current();<br>        &#125; <span class="hljs-keyword">elseif</span> (<span class="hljs-keyword">$this</span>-&gt;exception) &#123;<br>            <span class="hljs-variable">$retval</span> = <span class="hljs-keyword">$this</span>-&gt;coroutine-&gt;throw(<span class="hljs-keyword">$this</span>-&gt;exception);<br>            <span class="hljs-keyword">$this</span>-&gt;exception = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable">$retval</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-variable">$retval</span> = <span class="hljs-keyword">$this</span>-&gt;coroutine-&gt;send(<span class="hljs-keyword">$this</span>-&gt;sendValue);<br>            <span class="hljs-keyword">$this</span>-&gt;sendValue = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable">$retval</span>;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在, 我们已经可以在系统调用中使用异常抛出了！例如,要调用 killTask,让我们在传递 ID 不可用时抛出一个异常：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">killTask</span>(<span class="hljs-params"><span class="hljs-variable">$tid</span></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SystemCall(<br>        <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Task <span class="hljs-variable">$task</span>, Scheduler <span class="hljs-variable">$scheduler</span></span>) <span class="hljs-keyword">use</span> (<span class="hljs-params"><span class="hljs-variable">$tid</span></span>) </span>&#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable">$scheduler</span>-&gt;killTask(<span class="hljs-variable">$tid</span>)) &#123;<br>                <span class="hljs-variable">$scheduler</span>-&gt;schedule(<span class="hljs-variable">$task</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">InvalidArgumentException</span>(<span class="hljs-string">&#x27;Invalid task ID!&#x27;</span>);<br>            &#125;<br>        &#125;<br>    );<br>&#125;<br></code></pre></td></tr></table></figure>

<p>试试看：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">task</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">yield</span> killTask(<span class="hljs-number">500</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-built_in">Exception</span> <span class="hljs-variable">$e</span>) &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;Tried to kill task 500 but failed: &#x27;</span>, <span class="hljs-variable">$e</span>-&gt;getMessage(), <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这些代码现在尚不能正常运作,因为 stackedCoroutine 函数无法正确处理异常.要修复需要做些调整：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stackedCoroutine</span>(<span class="hljs-params"><span class="hljs-built_in">Generator</span> <span class="hljs-variable">$gen</span></span>) </span>&#123;<br>    <span class="hljs-variable">$stack</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SplStack</span>;<br>    <span class="hljs-variable">$exception</span> = <span class="hljs-literal">null</span>;<br> <br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable">$exception</span>) &#123;<br>                <span class="hljs-variable">$gen</span>-&gt;throw(<span class="hljs-variable">$exception</span>);<br>                <span class="hljs-variable">$exception</span> = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br> <br>            <span class="hljs-variable">$value</span> = <span class="hljs-variable">$gen</span>-&gt;current();<br> <br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable">$value</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Generator</span>) &#123;<br>                <span class="hljs-variable">$stack</span>-&gt;push(<span class="hljs-variable">$gen</span>);<br>                <span class="hljs-variable">$gen</span> = <span class="hljs-variable">$value</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br> <br>            <span class="hljs-variable">$isReturnValue</span> = <span class="hljs-variable">$value</span> <span class="hljs-keyword">instanceof</span> CoroutineReturnValue;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-variable">$gen</span>-&gt;valid() || <span class="hljs-variable">$isReturnValue</span>) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-variable">$stack</span>-&gt;isEmpty()) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br> <br>                <span class="hljs-variable">$gen</span> = <span class="hljs-variable">$stack</span>-&gt;pop();<br>                <span class="hljs-variable">$gen</span>-&gt;send(<span class="hljs-variable">$isReturnValue</span> ? <span class="hljs-variable">$value</span>-&gt;getValue() : <span class="hljs-literal">NULL</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br> <br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-variable">$sendValue</span> = (<span class="hljs-keyword">yield</span> <span class="hljs-variable">$gen</span>-&gt;key() =&gt; <span class="hljs-variable">$value</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-built_in">Exception</span> <span class="hljs-variable">$e</span>) &#123;<br>                <span class="hljs-variable">$gen</span>-&gt;throw(<span class="hljs-variable">$e</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br> <br>            <span class="hljs-variable">$gen</span>-&gt;send(<span class="hljs-variable">$sendValue</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-built_in">Exception</span> <span class="hljs-variable">$e</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable">$stack</span>-&gt;isEmpty()) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-variable">$e</span>;<br>            &#125;<br> <br>            <span class="hljs-variable">$gen</span> = <span class="hljs-variable">$stack</span>-&gt;pop();<br>            <span class="hljs-variable">$exception</span> = <span class="hljs-variable">$e</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>在这篇文章里,我使用多任务协作构建了一个任务调度器, 其中包括执行“系统调用”, 做非阻塞操作和处理错误. 所有这些里真正很酷的事情是任务的结果代码看起来完全同步, 甚至任务正在执行大量的异步操作的时候也是这样.</p>
<p>如果你打算从套接口读取数据的话, 你将不需要传递某个回调函数或者注册一个事件侦听器. 相反, 你只要书写yield $socket-&gt;read(). 这儿大部分都是你常常也要编写的,只 在它的前面增加yield.</p>
<p>当我第一次听到协程的时候, 我发现这个概念完全令人折服, 正是因为这个激励我在PHP中实现了它. 同时我发现协程真正非常的令人惊叹:在令人敬畏的代码和一大堆乱代码之间只有一线之隔, 我认为协程恰好处在这条线上, 不多不少. 不过, 要说使用上面所述的方法书写异步代码是否真的有益, 这个就见仁见智了.</p>
<p>但, 不管咋样, 我认为这是一个有趣的话题, 而且我希望你也能找到它的乐趣. 欢迎评论:)</p>
<ul>
<li><em>原文地址：<a target="_blank" rel="noopener" href="http://www.laruence.com/2015/05/28/3038.html">风雪之隅 —— 28 May 15 在PHP中使用协程实现多任务调度</a></em></li>
<li><em>英文原文地址：<a target="_blank" rel="noopener" href="http://nikic.github.io/2012/12/22/Cooperative-multitasking-using-coroutines-in-PHP.html">Cooperative multitasking using coroutines (in PHP!)</a></em></li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/PHP/">PHP</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E8%BD%AC%E8%BD%BD/">转载</a>
                    
                      <a class="hover-with-bg" href="/tags/PHP/">PHP</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2017/08/C%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8sscanf-%E8%A7%A3%E6%9E%90%E5%AD%97%E7%AC%A6%E4%B8%B2/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">C语言使用sscanf()解析字符串</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2017/07/MySQL-%E7%94%A8%E6%88%B7%E4%B8%8E%E6%8E%88%E6%9D%83/">
                        <span class="hidden-mobile">MySQL 用户与授权</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
